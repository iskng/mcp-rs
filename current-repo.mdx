<directory_structure>
mcp-rs
├── examples
│   ├── lifecycle_example.rs
│   └── server_test.rs
├── python_client
│   ├── venv
│   ├── client.py
│   ├── requirements.txt
│   └── run_client.sh
├── src
│   ├── schema
│   │   └── schema.json
│   ├── tools
│   │   ├── message_parser.rs
│   │   ├── mod.rs
│   │   ├── process_manager.rs
│   │   ├── progress.rs
│   │   └── tool_registry.rs
│   ├── transport
│   │   ├── mod.rs
│   │   ├── sse.rs
│   │   ├── sse_server.rs
│   │   ├── stdio.rs
│   │   ├── websocket.rs
│   │   └── websocket_server.rs
│   ├── types
│   │   ├── initialize.rs
│   │   ├── mod.rs
│   │   ├── prompts.rs
│   │   ├── resources.rs
│   │   └── tools.rs
│   ├── client.rs
│   ├── errors.rs
│   ├── lib.rs
│   ├── lifecycle.rs
│   ├── lifecycle_context.rs
│   ├── messages.rs
│   ├── resources.rs
│   ├── server.rs
│   ├── server_session.rs
│   └── utils.rs
├── target
├── .gitignore
├── Cargo.toml
├── README.md
└── python-sdk.mdx

</directory_structure>

<file_info>
path: README.md
name: README.md
</file_info>
# MCP-rs: Rust Implementation of the Model Context Protocol

MCP-rs is a type-safe, efficient, and ergonomic Rust implementation of the [Model Context Protocol (MCP)](https://github.com/microsoft/mcp), designed to enable seamless integration between AI applications and external data sources or tools.

## Current Status

This repository contains a working implementation of the MCP protocol with the following components:

- **Rust Server**: A fully functional MCP server with support for tools, resources, and lifecycle management
- **Python Client**: A Python client that can connect to the server, list tools, and call them
- **Calculator Tool**: A sample tool that performs arithmetic operations (add, subtract, multiply, divide)
- **Server-Sent Events (SSE) Transport**: Real-time communication between client and server
- **WebSocket Transport**: Alternative transport for bidirectional communication

The `server_test` example is fully functional and works as a Cursor tool, allowing you to run an MCP server and interact with it using the Python client.

## Features

- **Type-Safe**: Leverages Rust's strong type system to ensure protocol correctness at compile time
- **Async-First**: Built on Tokio for high-performance, non-blocking I/O operations
- **Multiple Transports**: Supports STDIO, Server-Sent Events (SSE), and WebSocket transports
- **Schema Validation**: Automatic JSON Schema generation for protocol types
- **Extensible**: Easy to add new message handlers, tools, resources, and prompts
- **Python Compatibility**: Works with the standard MCP Python library

## Quick Start

### Running the Server

```bash
# Run the server_test example
cargo run --example server_test
```

This will start an MCP server on port 8090 with the calculator tool registered.

### Running the Python Client

```bash
# Navigate to the Python client directory
cd python_client

# Run the client script
./run_client.sh
```

The Python client will:
1. Connect to the MCP server
2. Initialize the connection
3. List available tools
4. Test the calculator tool with various operations

### Creating Your Own MCP Server

```rust
use mcp_rs::{ServerSession, Transport, sse_server::SseServerTransport};
use mcp_rs::types::tools::{Tool, ToolBuilder, ToolParameterType};

#[tokio::main]
async fn main() {
    // Create a new server with application state
    let mut server = ServerSession::new(());
    
    // Register a calculator tool
    server.register_tool_builder(
        server
            .build_tool("calculator", "Performs arithmetic operations")
            .add_parameter(/* ... */)
            // ... add more parameters
            .return_type("number")
            .streaming(false)
            .cancellable(false)
            .timeout(30)
    );
    
    // Register handler for the calculator tool
    server.register_handler("tools/call", |state, params| {
        // Handle tool calls
    });
    
    // Start the server with SSE transport
    let transport = SseServerTransport::new();
    server.run(transport).await;
}
```

## Examples

The repository includes several examples to demonstrate different MCP features:

- **server_test**: A complete MCP server with a calculator tool and SSE transport
- **lifecycle_example**: Demonstrates the lifecycle management features
- **websocket_transport_example**: Shows how to use WebSocket transport
- **tool_execution**: Illustrates implementing and registering tools
- **mcp-server-example**: A standalone MCP server implementation

To run an example:

```bash
cargo run --example server_test
```

## Python Client

The repository includes a Python client in the `python_client` directory. This client:

- Uses the standard MCP Python library
- Connects to the MCP server using SSE transport
- Lists available tools
- Calls the calculator tool with different operations

To run the Python client:

```bash
cd python_client
./run_client.sh
```

## Documentation

For detailed documentation, see the `docs` directory or run:

```bash
cargo doc --open
```

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request. 

<file_info>
path: Cargo.toml
name: Cargo.toml
</file_info>
[package]
name = "mcp-rs"
version = "0.1.0"
edition = "2024"
description = "Rust implementation of the Model Context Protocol (MCP)"
license = "MIT"
repository = "https://github.com/username/mcp-rs"
readme = "README.md"
keywords = ["ai", "protocol", "mcp", "model-context-protocol"]
categories = ["api-bindings", "asynchronous"]

[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
tokio = { version = "1.36", features = ["full"] }
async-trait = "0.1"
thiserror = "2.0.11"
schemars = "0.8"
jsonschema = "0.17"

futures = "0.3"
uuid = { version = "1.7", features = ["v4", "serde"] }
tracing = "0.1"
log = "0.4"
url = "2.4"
reqwest = { version = "0.12.12", features = ["json", "stream"] }
tokio-util = { version = "0.7", features = ["codec"] }
futures-util = "0.3"
bytes = "1.5"
tokio-tungstenite = "0.26.2"
base64 = "0.22.1"
mime_guess = "2.0.4"
axum = { version = "0.8.1", features = ["ws"] }
tower-http = { version = "0.6.2", features = ["cors"] }
tower = "0.5.2"
http = "1.2.0"
scopeguard = "1.2"
async-stream = "0.3.5"
anyhow = "1.0.96"

[dev-dependencies]
tokio-test = "0.4"
async-std = { version = "1.12", features = ["attributes"] }
insta = "1.34"
tracing-subscriber = "0.3"



[lib]
name = "mcp_rs"
path = "src/lib.rs"


<file_info>
path: src/transport/sse_server.rs
name: sse_server.rs
</file_info>
//! Server-side implementation of the SSE transport
//!
//! This module provides an SSE server implementation that:
//! - Accepts SSE connections from clients at the `/sse` endpoint
//! - Accepts HTTP POST requests from clients at the `/message` endpoint
//! - Routes messages between clients and the MCP server

use crate::errors::Error;
use crate::messages::Message;
use crate::transport::Transport;
use async_stream;
use async_trait::async_trait;
use axum::{
    Router,
    extract::{ Extension, Json, Query, State },
    http::StatusCode,
    response::{ IntoResponse, Sse, sse::Event },
    routing::{ get, post },
};
use futures_util::StreamExt;
use http::{ HeaderValue, Method, header };
use serde_json;
use std::collections::HashMap;
use std::convert::Infallible;
use std::net::SocketAddr;
use std::sync::{ Arc, Mutex };
use std::time::{ Duration, Instant };
use tokio::sync::{ broadcast, mpsc, oneshot };
use tower_http::cors::{ Any, CorsLayer };
use uuid::Uuid;

use super::TransportLifecycleEvent;

/// Maximum number of concurrent clients
const MAX_CLIENTS: usize = 100;

/// Configuration options for the SSE server
#[derive(Debug, Clone)]
pub struct SseServerOptions {
    /// Address to bind the server to
    pub bind_address: SocketAddr,
    /// Optional authentication token to validate requests
    pub auth_token: Option<String>,
    /// Connection timeout in seconds
    pub connection_timeout: std::time::Duration,
    /// Keep-alive interval in seconds
    pub keep_alive_interval: u64,
    /// CORS allowed origins
    pub allowed_origins: Option<Vec<String>>,
    /// Whether to require authentication
    pub require_auth: bool,
}

impl Default for SseServerOptions {
    fn default() -> Self {
        Self {
            bind_address: "127.0.0.1:8090".parse().unwrap(),
            auth_token: None,
            connection_timeout: std::time::Duration::from_secs(30),
            keep_alive_interval: 30,
            allowed_origins: None,
            require_auth: false,
        }
    }
}

/// A client connection
#[derive(Debug)]
struct ClientConnection {
    id: String,
    connected_at: std::time::SystemTime,
    last_activity: std::time::SystemTime,
    sender: broadcast::Sender<String>, // Changed to String to avoid Clone bound issues
}

/// Client connection information
#[derive(Debug, Clone)]
struct ClientInfo {
    /// Client ID
    id: String,
    /// Last activity timestamp
    last_activity: Instant,
    /// Message sender for this client
    tx: Option<mpsc::Sender<Result<Message, Error>>>,
}

/// Server application state
struct AppState {
    /// Replace client-specific channels with a single broadcast channel
    broadcast_tx: broadcast::Sender<Message>,
    /// Map of client connections
    clients_map: tokio::sync::Mutex<HashMap<String, ClientInfo>>,
    /// Transport message transmitter
    message_tx: mpsc::Sender<(String, Result<Message, Error>)>,
    /// Authorization token, if required
    auth_token: Option<String>,
    /// Whether authentication is required
    require_auth: bool,
    /// Transport for sending messages
    transport: Arc<tokio::sync::Mutex<Box<dyn Transport>>>,
    /// Map of client senders
    transport_clients: std::sync::Mutex<HashMap<String, ClientConnection>>,
    /// Session map: maps session IDs to client IDs
    session_map: Arc<tokio::sync::Mutex<HashMap<String, String>>>,
    /// Client-specific channels: maps client IDs to broadcast senders
    client_channels: Arc<tokio::sync::Mutex<HashMap<String, broadcast::Sender<Message>>>>,
}

impl AppState {
    fn new(
        message_tx: mpsc::Sender<(String, Result<Message, Error>)>,
        auth_token: Option<String>,
        require_auth: bool,
        transport: Box<dyn Transport>
    ) -> Self {
        Self {
            broadcast_tx: broadcast::channel(100).0,
            clients_map: tokio::sync::Mutex::new(HashMap::new()),
            message_tx,
            auth_token,
            require_auth,
            transport: Arc::new(tokio::sync::Mutex::new(transport)),
            transport_clients: std::sync::Mutex::new(HashMap::new()),
            session_map: Arc::new(tokio::sync::Mutex::new(HashMap::new())),
            client_channels: Arc::new(tokio::sync::Mutex::new(HashMap::new())),
        }
    }
}

/// Server-side implementation of the SSE transport
pub struct SseServerTransport {
    /// Map of client IDs to connection info
    clients: Arc<Mutex<HashMap<String, ClientConnection>>>,
    /// Channel for incoming messages from clients
    message_rx: mpsc::Receiver<(String, Result<Message, Error>)>,
    /// Channel for sending messages to specific clients
    message_tx: mpsc::Sender<(String, Result<Message, Error>)>,
    /// Channel to notify when the server should shut down
    shutdown_tx: Option<oneshot::Sender<()>>,
    /// Server options
    options: SseServerOptions,
    /// Server handle
    server_handle: Option<tokio::task::JoinHandle<()>>,
    /// Is the transport connected
    connected: bool,
    /// Lifecycle event handlers
    lifecycle_handlers: Vec<Box<dyn Fn(TransportLifecycleEvent) + Send + Sync>>,
    /// Broadcast channel for messages
    broadcast_tx: broadcast::Sender<Message>,
    /// Session map: maps session IDs to client IDs
    session_map: Arc<tokio::sync::Mutex<HashMap<String, String>>>,
    /// Client-specific channels: maps client IDs to broadcast senders
    client_channels: Arc<tokio::sync::Mutex<HashMap<String, broadcast::Sender<Message>>>>,
}

impl SseServerTransport {
    /// Create a new SSE server transport with default options
    pub fn new() -> Self {
        Self::with_options(SseServerOptions::default())
    }

    /// Create a new SSE server transport with the specified options
    pub fn with_options(options: SseServerOptions) -> Self {
        let (message_tx, message_rx) = mpsc::channel(100);
        let (broadcast_tx, _) = broadcast::channel(100);

        Self {
            clients: Arc::new(Mutex::new(HashMap::new())),
            message_rx,
            message_tx,
            shutdown_tx: None,
            options,
            server_handle: None,
            connected: false,
            lifecycle_handlers: Vec::new(),
            broadcast_tx,
            session_map: Arc::new(tokio::sync::Mutex::new(HashMap::new())),
            client_channels: Arc::new(tokio::sync::Mutex::new(HashMap::new())),
        }
    }

    /// Notify lifecycle event handlers
    fn notify_lifecycle(&self, event: TransportLifecycleEvent) {
        for handler in &self.lifecycle_handlers {
            handler(event.clone());
        }
    }

    /// Start the SSE server
    pub async fn start(&mut self, bind_addr: Option<SocketAddr>) -> Result<(), Error> {
        // Check if already connected
        if self.connected {
            return Err(Error::Transport("SSE server already started".to_string()));
        }

        // Notify Starting lifecycle event
        self.notify_lifecycle(TransportLifecycleEvent::Starting);

        // Use provided address or fall back to the one from options
        let bind_addr = bind_addr.unwrap_or(self.options.bind_address);

        // Create a new broadcast channel - ensure we have a fresh one
        let (broadcast_tx, _) = broadcast::channel(100);
        self.broadcast_tx = broadcast_tx.clone();

        // Share session map and client channels
        let session_map = self.session_map.clone();
        let client_channels = self.client_channels.clone();

        // Create a new channel pair for the server-side transport
        let (_server_tx, server_rx) = mpsc::channel(100);

        // Create app state
        let app_state = Arc::new(AppState {
            broadcast_tx: broadcast_tx.clone(),
            clients_map: tokio::sync::Mutex::new(HashMap::new()),
            message_tx: self.message_tx.clone(),
            auth_token: self.options.auth_token.clone(),
            require_auth: self.options.require_auth,
            transport: Arc::new(
                tokio::sync::Mutex::new(
                    Box::new(SseServerTransport {
                        clients: Arc::new(Mutex::new(HashMap::new())),
                        message_rx: server_rx,
                        message_tx: self.message_tx.clone(),
                        shutdown_tx: None,
                        options: self.options.clone(),
                        server_handle: None,
                        connected: false,
                        lifecycle_handlers: Vec::new(),
                        broadcast_tx: broadcast_tx.clone(),
                        session_map: session_map.clone(),
                        client_channels: client_channels.clone(),
                    }) as Box<dyn Transport>
                )
            ),
            transport_clients: std::sync::Mutex::new(HashMap::new()),
            session_map,
            client_channels,
        });

        // Set the APP_STATE reference if it exists in the codebase
        // This part is kept as is, assuming APP_STATE is defined elsewhere
        #[allow(unused_variables)]
        let app_state_clone = app_state.clone();
        #[cfg(feature = "global_state")]
        {
            let _ = APP_STATE.set(app_state_clone);
        }

        // Create a CORS layer
        let cors = match &self.options.allowed_origins {
            Some(origins) if !origins.is_empty() => {
                let mut layer = CorsLayer::new()
                    .allow_methods([Method::GET, Method::POST, Method::OPTIONS])
                    .allow_headers([header::CONTENT_TYPE, header::AUTHORIZATION])
                    .max_age(Duration::from_secs(3600));

                // Add allowed origins
                for origin in origins {
                    if origin == "*" {
                        layer = layer.allow_origin(Any);
                        break;
                    } else {
                        match HeaderValue::from_str(origin) {
                            Ok(origin) => {
                                layer = layer.allow_origin(origin);
                            }
                            Err(e) => {
                                tracing::warn!("Invalid origin: {}, error: {}", origin, e);
                            }
                        }
                    }
                }

                layer
            }
            _ => CorsLayer::permissive(),
        };

        // Build the router with the protocol-compliant paths
        let app = Router::new()
            .route("/sse", get(handle_sse_connection))
            .route("/message", post(handle_client_message)) // Corrected path
            .layer(Extension(Arc::clone(&app_state)))
            .layer(cors)
            .with_state(app_state);

        // Spawn the server
        tracing::info!("Starting SSE server on {}", bind_addr);

        // Create the TCP listener
        let listener = tokio::net::TcpListener
            ::bind(bind_addr).await
            .map_err(|e| Error::Transport(format!("Failed to bind to {}: {}", bind_addr, e)))?;

        // Create shutdown channel
        let (shutdown_tx, shutdown_rx) = oneshot::channel::<()>();
        self.shutdown_tx = Some(shutdown_tx);

        // Set up the server with graceful shutdown
        let server = axum::serve(listener, app.into_make_service()).with_graceful_shutdown(async {
            let _ = shutdown_rx.await;
            tracing::info!("Shutting down SSE server");
        });

        // Spawn a task that runs the server
        self.server_handle = Some(
            tokio::spawn(async move {
                if let Err(e) = server.await {
                    tracing::error!("Server error: {}", e);
                }
            })
        );

        self.connected = true;
        tracing::info!("SSE server started on {}", bind_addr);
        tracing::info!("SSE endpoint: http://{}/sse", bind_addr);
        tracing::info!("Message endpoint: http://{}/message", bind_addr); // Updated log message

        // Notify Started lifecycle event
        self.notify_lifecycle(TransportLifecycleEvent::Started);

        Ok(())
    }

    /// Get the number of connected clients
    pub fn connected_clients(&self) -> usize {
        self.clients.lock().unwrap().len()
    }
}

/// Handle a client message received via HTTP POST
async fn handle_client_message(
    State(state): State<Arc<AppState>>,
    Query(params): Query<HashMap<String, String>>,
    Json(message): Json<Message>
) -> impl IntoResponse {
    // Extract the session_id from query parameters
    let session_id = match params.get("session_id") {
        Some(id) => id,
        None => {
            tracing::error!("Missing session_id in message request");
            return StatusCode::BAD_REQUEST.into_response();
        }
    };

    // Verify the session exists
    let client_id = {
        let clients = state.clients_map.lock().await;
        match clients.get(session_id) {
            Some(info) => {
                tracing::debug!("Received message for valid session: {}", session_id);
                info.id.clone()
            }
            None => {
                tracing::error!("Invalid session_id: {}", session_id);
                return StatusCode::UNAUTHORIZED.into_response();
            }
        }
    };

    tracing::debug!("Received client message from session {}: {:?}", session_id, message);

    // Forward the message to the transport's message handler
    if let Err(e) = state.message_tx.send((client_id, Ok(message))).await {
        tracing::error!("Failed to forward message to server: {}", e);
        return StatusCode::INTERNAL_SERVER_ERROR.into_response();
    }

    // Return a simple acknowledgment
    // The actual response will be sent via the SSE connection
    StatusCode::OK.into_response()
}

/// Handle an SSE connection
async fn handle_sse_connection(State(state): State<Arc<AppState>>) -> impl IntoResponse {
    // Generate client ID for internal tracking only
    let client_id = Uuid::new_v4().to_string();
    tracing::info!("New SSE connection established, ID: {}", client_id);

    // Generate a session ID for this connection
    let session_id = Uuid::new_v4().to_string();

    // Create the session-specific message endpoint URI
    let session_uri = format!("/message?session_id={}", session_id);

    // Create a client-specific broadcast channel
    let (client_tx, client_rx) = broadcast::channel::<Message>(100);

    // Store the session info and channel in our maps
    {
        let mut clients = state.clients_map.lock().await;
        clients.insert(session_id.clone(), ClientInfo {
            id: client_id.clone(),
            last_activity: Instant::now(),
            tx: None,
        });

        let mut session_map = state.session_map.lock().await;
        session_map.insert(session_id.clone(), client_id.clone());

        let mut client_channels = state.client_channels.lock().await;
        client_channels.insert(client_id.clone(), client_tx.clone());
    }

    // Create subscription for both client-specific and global broadcasts
    let mut client_stream = client_rx;
    let mut global_stream = state.broadcast_tx.subscribe();

    // Create the SSE stream
    let stream =
        async_stream::stream! {
        // Send initial endpoint event with the session URI
        let endpoint_event = Event::default()
            .event("endpoint")
            .data(session_uri.clone());
        yield Ok::<_, Infallible>(endpoint_event);

        tracing::info!("Sent endpoint event: {}", session_uri);

        // Listen for messages from both streams
        loop {
            tokio::select! {
                // Check client-specific messages
                client_msg = client_stream.recv() => {
                    match client_msg {
                        Ok(message) => {
                            let data = serde_json::to_string(&message)
                                .unwrap_or_else(|e| format!("{{\"error\":\"Failed to serialize message: {}\"}}", e));
                            let event = Event::default().event("message").data(data);
                            yield Ok::<_, Infallible>(event);
                        },
                        Err(e) => {
                            tracing::error!("Error receiving client-specific message: {}", e);
                            // Don't break the stream on individual message errors
                        }
                    }
                },

                // Check global broadcast messages
                global_msg = global_stream.recv() => {
                    match global_msg {
                        Ok(message) => {
                            let data = serde_json::to_string(&message)
                                .unwrap_or_else(|e| format!("{{\"error\":\"Failed to serialize message: {}\"}}", e));
                            let event = Event::default().event("message").data(data);
                            yield Ok::<_, Infallible>(event);
                        },
                        Err(e) => {
                            tracing::error!("Error receiving global message: {}", e);
                            break; // Break if global stream fails
                        }
                    }
                }
            }
        }

        // Clean up session when connection closes
        {
            let mut clients = state.clients_map.lock().await;
            clients.remove(&session_id);

            let mut session_map = state.session_map.lock().await;
            session_map.remove(&session_id);

            let mut client_channels = state.client_channels.lock().await;
            client_channels.remove(&client_id);

            tracing::info!("SSE connection closed, removed session ID: {}", session_id);
        }
    };

    // Return SSE stream with keepalive
    Sse::new(stream).keep_alive(
        axum::response::sse::KeepAlive::new().interval(Duration::from_secs(15)).text("keep-alive")
    )
}

/// Check if a request is authorized
fn is_authorized(auth_header: Option<&str>, token: &str) -> bool {
    if let Some(auth_str) = auth_header {
        if auth_str == format!("Bearer {}", token) {
            return true;
        }
    }
    false
}

#[async_trait]
impl Transport for SseServerTransport {
    async fn receive(&mut self) -> Result<(Option<String>, Message), Error> {
        if !self.connected {
            // Start the server if it's not already running
            self.start(None).await?;
        }

        // Wait for messages from clients
        match self.message_rx.recv().await {
            Some((client_id, result)) => {
                // Return the message with the client ID
                result.map(|msg| (Some(client_id), msg))
            }
            None => Err(Error::Transport("SSE server message channel closed".to_string())),
        }
    }

    async fn send_to(&mut self, client_id: &str, message: &Message) -> Result<(), Error> {
        // Try to send to the specific client if we have a channel for it
        let mut sent = false;

        if !client_id.is_empty() {
            if let Some(client_tx) = self.client_channels.lock().await.get(client_id) {
                if let Err(e) = client_tx.send(message.clone()) {
                    tracing::warn!("Failed to send to client {}: {}", client_id, e);
                    // Fall through to broadcast as a fallback
                } else {
                    sent = true;
                }
            } else {
                tracing::warn!("Client {} not found, falling back to broadcast", client_id);
            }
        }

        // If we couldn't send to the specific client, broadcast to all
        if !sent {
            self.send(message).await?;
        }

        Ok(())
    }

    async fn send(&mut self, message: &Message) -> Result<(), Error> {
        // Broadcast message to all connected clients
        let receivers = self.broadcast_tx.receiver_count();
        if receivers == 0 {
            tracing::warn!("No connected clients to receive broadcast message");
            // Don't return error - just warn and continue
            return Ok(());
        }

        match self.broadcast_tx.send(message.clone()) {
            Ok(n) => {
                tracing::debug!("Broadcast message to {} receivers", n);
                Ok(())
            }
            Err(e) => {
                // Create a new broadcast channel if the old one is closed
                let (new_tx, _) = broadcast::channel(100);
                self.broadcast_tx = new_tx;

                tracing::warn!("Broadcast channel error, recreated: {}", e);
                // Try again with the new channel
                Err(Error::Transport(format!("Failed to broadcast message: {}", e)))
            }
        }
    }

    async fn is_connected(&self) -> bool {
        self.connected
    }

    async fn close(&mut self) -> Result<(), Error> {
        if !self.connected {
            return Ok(());
        }

        tracing::info!("Closing SSE server transport");

        // Notify that we're closing
        for handler in &self.lifecycle_handlers {
            handler(TransportLifecycleEvent::Closing);
        }

        // Signal server to shut down
        if let Some(tx) = self.shutdown_tx.take() {
            // Using let _ = tx.send(()) without .await since oneshot doesn't implement Future
            let _ = tx.send(());
        }

        // Wait for server to shut down
        if let Some(handle) = self.server_handle.take() {
            let _ = handle.await;
        }

        self.connected = false;

        // Notify that we've closed
        for handler in &self.lifecycle_handlers {
            handler(TransportLifecycleEvent::Closed);
        }

        tracing::info!("SSE server transport closed");

        Ok(())
    }

    fn register_lifecycle_handler(
        &mut self,
        handler: Box<dyn Fn(TransportLifecycleEvent) + Send + Sync>
    ) {
        self.lifecycle_handlers.push(handler);
    }
}


<file_info>
path: src/tools/mod.rs
name: mod.rs
</file_info>
//! Tool Support for MCP-rs
//!
//! This module provides implementations for the tool execution system,
//! including process management, progress tracking, and tool registration.

pub mod message_parser;
pub mod process_manager;
pub mod progress;
pub mod tool_registry;

// Re-export commonly used types
pub use process_manager::{ToolOutput, ToolOutputType, ToolProcessManager};
pub use progress::{ToolProgress, ToolProgressTracker};
pub use tool_registry::{ToolDefinition, ToolRegistry};


<file_info>
path: src/transport/websocket.rs
name: websocket.rs
</file_info>
//! WebSocket Transport
//!
//! This module implements the WebSocket transport for the MCP library, enabling
//! full-duplex communication over WebSockets. It is suitable for web-based
//! and networked applications requiring real-time communication.

use async_trait::async_trait;
use futures::future::{FutureExt};
use futures::{SinkExt, StreamExt};
use std::sync::Arc;
use std::time::Duration;
use tokio::sync::{Mutex, mpsc, oneshot};
use tokio_tungstenite::{
    connect_async, tungstenite::protocol::Message as WsMessage,
};
use url::Url;

use crate::errors::Error;
use crate::messages::Message;
use crate::transport::{Transport, TransportLifecycleEvent};

/// Default connection timeout
const DEFAULT_CONNECTION_TIMEOUT: Duration = Duration::from_secs(30);
/// Default heartbeat interval
const DEFAULT_HEARTBEAT_INTERVAL: Duration = Duration::from_secs(30);
/// Maximum reconnection attempts
const MAX_RECONNECT_ATTEMPTS: usize = 5;
/// Default reconnection delay
const DEFAULT_RECONNECT_DELAY: Duration = Duration::from_secs(2);

/// WebSocket transport options
#[derive(Debug, Clone)]
pub struct WebSocketOptions {
    /// Connection timeout
    pub connection_timeout: Duration,
    /// Heartbeat interval
    pub heartbeat_interval: Duration,
    /// Reconnection delay
    pub reconnect_delay: Duration,
    /// Authentication token
    pub auth_token: Option<String>,
    /// Custom headers
    pub headers: Option<Vec<(String, String)>>,
}

impl Default for WebSocketOptions {
    fn default() -> Self {
        Self {
            connection_timeout: DEFAULT_CONNECTION_TIMEOUT,
            heartbeat_interval: DEFAULT_HEARTBEAT_INTERVAL,
            reconnect_delay: DEFAULT_RECONNECT_DELAY,
            auth_token: None,
            headers: None,
        }
    }
}

/// WebSocket transport for MCP
pub struct WebSocketTransport {
    /// The WebSocket URL
    url: String,
    /// Receiver for incoming messages
    rx: Arc<Mutex<mpsc::Receiver<Result<Message, Error>>>>,
    /// Sender for outgoing messages
    tx: mpsc::Sender<Message>,
    /// Connection status
    connected: Arc<Mutex<bool>>,
    /// WebSocket options
    options: WebSocketOptions,
    /// New flag to track if the transport is ready for sending
    ready: Arc<Mutex<bool>>,
    /// Connection task
    connection_task: Option<tokio::task::JoinHandle<()>>,
    /// Signal to indicate the transport is shutting down
    shutdown: Arc<Mutex<bool>>,
    /// Lifecycle event handlers
    lifecycle_handlers: Arc<Mutex<Vec<Box<dyn Fn(TransportLifecycleEvent) + Send + Sync>>>>,
}

impl WebSocketTransport {
    /// Create a new WebSocket transport with default options
    pub async fn new(url: String) -> Result<Self, Error> {
        Self::with_options(url, WebSocketOptions::default()).await
    }

    /// Create a new WebSocket transport with custom options
    pub async fn with_options(url: String, options: WebSocketOptions) -> Result<Self, Error> {
        // Validate URL
        let _ = Url::parse(&url)
            .map_err(|e| Error::Transport(format!("Invalid WebSocket URL: {}", e)))?;

        // Create message channels
        let (tx_in, rx_in) = mpsc::channel::<Result<Message, Error>>(100);
        let (tx_out, rx_out) = mpsc::channel::<Message>(100);

        let connected = Arc::new(Mutex::new(false));
        let ready = Arc::new(Mutex::new(false));
        let shutdown = Arc::new(Mutex::new(false));
        let lifecycle_handlers = Arc::new(Mutex::new(Vec::new()));

        // Notify Starting lifecycle event
        Self::notify_lifecycle_event(&lifecycle_handlers, TransportLifecycleEvent::Starting).await;

        let connected_clone = connected.clone();
        let ready_clone = ready.clone();
        let shutdown_clone = shutdown.clone();
        let url_clone = url.clone();
        let options_clone = options.clone();
        let lifecycle_handlers_clone = lifecycle_handlers.clone();

        // Start background task for WebSocket communication
        let connection_task = tokio::spawn(async move {
            tracing::info!("Starting WebSocket connection task");
            Self::run_connection_loop(
                url_clone,
                options_clone,
                tx_in,
                rx_out,
                connected_clone,
                ready_clone,
                shutdown_clone,
                lifecycle_handlers_clone,
            )
            .await;
            tracing::info!("WebSocket connection task completed");
        });

        Ok(Self {
            url,
            rx: Arc::new(Mutex::new(rx_in)),
            tx: tx_out,
            connected,
            options,
            ready,
            connection_task: Some(connection_task),
            shutdown,
            lifecycle_handlers,
        })
    }

    /// Helper method to notify lifecycle event handlers
    async fn notify_lifecycle_event(
        handlers: &Arc<Mutex<Vec<Box<dyn Fn(TransportLifecycleEvent) + Send + Sync>>>>,
        event: TransportLifecycleEvent,
    ) {
        let handlers_guard = handlers.lock().await;
        for handler in handlers_guard.iter() {
            handler(event.clone());
        }
    }

    /// Run the WebSocket connection loop
    async fn run_connection_loop(
        url: String,
        options: WebSocketOptions,
        tx_in: mpsc::Sender<Result<Message, Error>>,
        rx_out: mpsc::Receiver<Message>,
        connected: Arc<Mutex<bool>>,
        ready: Arc<Mutex<bool>>,
        shutdown: Arc<Mutex<bool>>,
        lifecycle_handlers: Arc<Mutex<Vec<Box<dyn Fn(TransportLifecycleEvent) + Send + Sync>>>>,
    ) {
        // Create a new channel for reconnection signals
        let (reconnect_tx, _reconnect_rx) = mpsc::channel::<()>(1);
        let mut reconnect_attempts = 0;

        // Instead of trying to handle complex reconnection logic with ownership issues,
        // let's simplify and just retry connection in a loop when it fails
        loop {
            if reconnect_attempts >= MAX_RECONNECT_ATTEMPTS {
                let err = Error::Transport(format!(
                    "Failed to connect after {} attempts",
                    MAX_RECONNECT_ATTEMPTS
                ));
                let _ = tx_in.send(Err(err)).await;

                // Notify Error lifecycle event
                Self::notify_lifecycle_event(&lifecycle_handlers, TransportLifecycleEvent::Error)
                    .await;
                break;
            }

            let result = Self::handle_connection(
                url.clone(),
                options.clone(),
                tx_in.clone(),
                rx_out,
                connected.clone(),
                ready.clone(),
                shutdown.clone(),
                lifecycle_handlers.clone(),
            )
            .await;

            if result {
                // Connection ended normally, reset reconnect attempts
                reconnect_attempts = 0;
            } else {
                // Connection failed, increment reconnect attempts
                reconnect_attempts += 1;

                // Notify Error lifecycle event
                Self::notify_lifecycle_event(&lifecycle_handlers, TransportLifecycleEvent::Error)
                    .await;

                // Wait with exponential backoff before reconnecting
                let backoff = (2_u64).pow(reconnect_attempts.min(10) as u32)
                    * (options.reconnect_delay.as_millis() as u64);
                tracing::info!(
                    "Reconnecting in {} ms (attempt {}/{})",
                    backoff,
                    reconnect_attempts,
                    MAX_RECONNECT_ATTEMPTS
                );
                tokio::time::sleep(Duration::from_millis(backoff)).await;
            }

            // We can't reconnect because rx_out was moved into handle_connection
            // In a real implementation, we would need to create a new channel
            // and integrate it with the client's message loop
            break;
        }

        // Mark as disconnected
        *connected.lock().await = false;
        *ready.lock().await = false;

        // Notify Closed lifecycle event
        Self::notify_lifecycle_event(&lifecycle_handlers, TransportLifecycleEvent::Closed).await;
    }

    /// Handle a single WebSocket connection
    /// Returns true if connection ended normally, false if it failed
    async fn handle_connection(
        url: String,
        options: WebSocketOptions,
        tx_in: mpsc::Sender<Result<Message, Error>>,
        mut rx_out: mpsc::Receiver<Message>,
        connected: Arc<Mutex<bool>>,
        ready: Arc<Mutex<bool>>,
        shutdown: Arc<Mutex<bool>>,
        lifecycle_handlers: Arc<Mutex<Vec<Box<dyn Fn(TransportLifecycleEvent) + Send + Sync>>>>,
    ) -> bool {
        tracing::info!("Connecting to WebSocket at {}", url);

        // Check if we're shutting down
        if *shutdown.lock().await {
            tracing::info!("Shutdown signal received, aborting connection");
            return false;
        }

        // First, explicitly set connected and ready to false at the start
        {
            let mut connected_guard = connected.lock().await;
            *connected_guard = false;
            tracing::debug!("Set connected flag to false during connection setup");
        }

        {
            let mut ready_guard = ready.lock().await;
            *ready_guard = false;
            tracing::debug!("Set ready flag to false during connection setup");
        }

        let mut url_with_auth = url.clone();
        if let Some(token) = &options.auth_token {
            url_with_auth.push_str(&format!("?token={}", token));
        }

        match connect_async(&url_with_auth).await {
            Ok((ws_stream, _)) => {
                tracing::info!("WebSocket connection established");

                // Set connected flag to true
                {
                    let mut connected_guard = connected.lock().await;
                    *connected_guard = true;
                    tracing::debug!("Set connected flag to true after successful connection");
                }

                // Notify Started lifecycle event
                Self::notify_lifecycle_event(&lifecycle_handlers, TransportLifecycleEvent::Started)
                    .await;

                let (mut ws_sender, mut ws_receiver) = ws_stream.split();
                let tx_in_clone = tx_in.clone();
                let ready_clone = ready.clone();

                // Create a channel for the sender task to signal it's ready
                let (sender_ready_tx, sender_ready_rx) = oneshot::channel();

                let sender_handle = tokio::spawn(async move {
                    tracing::info!("Starting WebSocket sender task");

                    // Signal that the sender is ready
                    if sender_ready_tx.send(()).is_err() {
                        tracing::error!("Failed to signal sender ready");
                        return;
                    }

                    while let Some(msg) = rx_out.recv().await {
                        match serde_json::to_string(&msg) {
                            Ok(json) => {
                                tracing::debug!("Sending message: {}", json);
                                if let Err(e) = ws_sender.send(WsMessage::Text(json.into())).await {
                                    tracing::error!("WebSocket send error: {}", e);
                                    break;
                                }
                            }
                            Err(e) => {
                                tracing::error!("JSON serialization error: {}", e);
                                continue;
                            }
                        }
                    }
                    tracing::warn!("WebSocket sender task ended");
                });

                let receiver_handle = tokio::spawn(async move {
                    tracing::info!("Starting WebSocket receiver task");
                    while let Some(result) = ws_receiver.next().await {
                        match result {
                            Ok(ws_msg) => {
                                if ws_msg.is_text() {
                                    let text = ws_msg.to_text().unwrap();
                                    tracing::debug!("Received raw message: {}", text);
                                    match serde_json::from_str::<Message>(text) {
                                        Ok(message) => {
                                            tracing::debug!("Parsed message: {:?}", message);
                                            if tx_in_clone.send(Ok(message)).await.is_err() {
                                                tracing::error!(
                                                    "Failed to forward message to client"
                                                );
                                                break;
                                            }
                                        }
                                        Err(e) => {
                                            tracing::warn!("Failed to parse message: {}", e);
                                            if tx_in_clone.send(Err(Error::Json(e))).await.is_err()
                                            {
                                                break;
                                            }
                                        }
                                    }
                                } else if ws_msg.is_close() {
                                    tracing::info!("WebSocket closed by server");
                                    break;
                                }
                            }
                            Err(e) => {
                                tracing::error!("WebSocket receiver error: {}", e);
                                let _ =
                                    tx_in_clone.send(Err(Error::Transport(e.to_string()))).await;
                                break;
                            }
                        }
                    }
                    tracing::warn!("WebSocket receiver task ended");
                });

                // Wait for the sender task to signal it's ready
                match tokio::time::timeout(tokio::time::Duration::from_secs(5), sender_ready_rx)
                    .await
                {
                    Ok(Ok(())) => {
                        tracing::info!("WebSocket sender task is ready");

                        // Set ready flag to true
                        let mut ready_guard = ready_clone.lock().await;
                        *ready_guard = true;
                        tracing::debug!("Set ready flag to true after sender signaled ready");
                        drop(ready_guard); // Explicitly drop the guard to release the lock
                    }
                    Ok(Err(_)) => {
                        tracing::error!("Sender task failed to signal ready");
                        return false;
                    }
                    Err(_) => {
                        tracing::error!("Timed out waiting for sender task to be ready");
                        return false;
                    }
                }

                tokio::select! {
                    _ = sender_handle => {
                        tracing::info!("Sender task completed");
                        let mut ready_guard = ready.lock().await;
                        *ready_guard = false;
                        tracing::debug!("Set ready flag to false after sender task completed");
                        false
                    }
                    _ = receiver_handle => {
                        tracing::info!("Receiver task completed");
                        let mut ready_guard = ready.lock().await;
                        *ready_guard = false;
                        tracing::debug!("Set ready flag to false after receiver task completed");
                        false
                    }
                }
            }
            Err(e) => {
                tracing::error!("WebSocket connection error: {}", e);
                let err = Error::Transport(format!("WebSocket connection error: {}", e));
                let _ = tx_in.send(Err(err)).await;

                // Ensure flags are set to false on error
                {
                    let mut connected_guard = connected.lock().await;
                    *connected_guard = false;
                    tracing::debug!("Set connected flag to false after connection error");
                }

                {
                    let mut ready_guard = ready.lock().await;
                    *ready_guard = false;
                    tracing::debug!("Set ready flag to false after connection error");
                }

                false
            }
        }
    }
}

impl Drop for WebSocketTransport {
    fn drop(&mut self) {
        if let Some(handle) = self.connection_task.take() {
            handle.abort();
        }
    }
}

#[async_trait]
impl Transport for WebSocketTransport {
    async fn receive(&mut self) -> Result<(Option<String>, Message), Error> {
        let mut rx = self.rx.lock().await;
        rx.recv()
            .await
            .ok_or_else(|| Error::Transport("WebSocket receive channel closed".to_string()))?
            .map(|msg| (None, msg)) // Client transport, so no client ID
    }

    async fn send(&mut self, message: &Message) -> Result<(), Error> {
        tracing::debug!("WebSocketTransport.send called");

        // First check connection without locking 'ready'
        {
            let connected = *self.connected.lock().await;
            if !connected {
                tracing::error!("WebSocket is not connected");
                return Err(Error::Transport("WebSocket is not connected".to_string()));
            }
            tracing::debug!("WebSocket is connected");
        }

        // Check the ready flag first before waiting, using a short-lived lock
        let start = std::time::Instant::now();
        let timeout = std::time::Duration::from_secs(10); // 10 second timeout

        let mut is_ready = false;
        tracing::debug!("Checking if WebSocket is ready...");

        // Loop but release the lock each time to avoid deadlock
        while !is_ready {
            // Short-lived lock to check ready state
            {
                let ready_guard = self.ready.lock().await;
                is_ready = *ready_guard;
                if is_ready {
                    tracing::debug!("WebSocket is ready for sending");
                    break;
                }
            }

            // Check timeout without holding any locks
            if start.elapsed() > timeout {
                tracing::error!("Timeout waiting for WebSocket to be ready");
                return Err(Error::Transport(
                    "Timeout waiting for WebSocket to be ready for sending".to_string(),
                ));
            }

            // Log and sleep without holding any locks
            tracing::debug!("WebSocket not ready yet, waiting...");
            tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
        }

        tracing::debug!("Sending message via WebSocket channel: {:?}", message);
        match self.tx.send(message.clone()).await {
            Ok(_) => {
                tracing::debug!("Message sent to channel successfully");
                Ok(())
            }
            Err(e) => {
                tracing::error!("Failed to send message to WebSocket channel: {}", e);
                Err(Error::Transport(
                    "Failed to send message to WebSocket channel".to_string(),
                ))
            }
        }
    }

    async fn send_to(&mut self, _client_id: &str, message: &Message) -> Result<(), Error> {
        // For client transports, send_to is the same as send since there's only one connection
        self.send(message).await
    }

    async fn is_connected(&self) -> bool {
        *self.connected.lock().await
    }

    async fn close(&mut self) -> Result<(), Error> {
        tracing::info!("Closing WebSocket transport");

        // Notify Closing lifecycle event
        Self::notify_lifecycle_event(&self.lifecycle_handlers, TransportLifecycleEvent::Closing)
            .await;

        // Set shutdown flag first
        let mut shutdown_guard = self.shutdown.lock().await;
        *shutdown_guard = true;
        drop(shutdown_guard);

        // Abort the connection task
        if let Some(handle) = self.connection_task.take() {
            tracing::debug!("Aborting WebSocket connection task");
            handle.abort();
            tracing::debug!("WebSocket connection task aborted");
        }

        // Set connected and ready to false
        *self.connected.lock().await = false;
        *self.ready.lock().await = false;

        // Notify Closed lifecycle event
        Self::notify_lifecycle_event(&self.lifecycle_handlers, TransportLifecycleEvent::Closed)
            .await;

        tracing::info!("WebSocket transport closed");
        Ok(())
    }

    fn register_lifecycle_handler(
        &mut self,
        handler: Box<dyn Fn(TransportLifecycleEvent) + Send + Sync>,
    ) {
        // Clone Arc and spawn task to handle the async lock
        let handlers_arc = self.lifecycle_handlers.clone();
        tokio::spawn(async move {
            let mut handlers = handlers_arc.lock().await;
            handlers.push(handler);
        });
    }
}


<file_info>
path: examples/server_test.rs
name: server_test.rs
</file_info>
use mcp_rs::{
    Error,
    server_session::{ ServerSession, ServerSessionOptions },
    transport::{
        Transport,
        TransportLifecycleEvent,
        sse_server::{ SseServerOptions, SseServerTransport },
        websocket_server::WebSocketServerTransport,
    },
    types::{
        initialize::{
            LoggingCapabilities,
            PromptCapabilities,
            ResourceCapabilities,
            ServerCapabilities,
            ToolCapabilities,
        },
        resources::{ ListResourcesParams, ListResourcesResult, Resource },
        tools::{
            CallToolParams,
            CallToolResult,
            TextContent,
            ToolParameterBuilder,
            ToolParameterType,
        },
    },
    utils::validation::ValidationConfig,
};
use std::collections::HashMap;
use std::net::SocketAddr;
use std::sync::{ Arc, Mutex };
use tracing::{ Level, error, info };

/// Server state to manage resources and server status
#[derive(Clone)]
struct AppState {
    /// Map of resource URI to resource data
    resources: Arc<Mutex<HashMap<String, (Resource, String)>>>,
    /// Count of requests processed
    request_count: Arc<Mutex<u64>>,
    /// Connected clients
    connected_clients: Arc<Mutex<HashMap<String, String>>>,
    /// Transport lifecycle state
    transport_state: Arc<Mutex<String>>,
}

impl Default for AppState {
    fn default() -> Self {
        Self {
            resources: Arc::new(Mutex::new(HashMap::new())),
            request_count: Arc::new(Mutex::new(0)),
            connected_clients: Arc::new(Mutex::new(HashMap::new())),
            transport_state: Arc::new(Mutex::new("uninitialized".to_string())),
        }
    }
}

/// Simple command-line arguments for server configuration
struct ServerConfig {
    transport: String,
    bind: String,
    validate: bool,
    verbose: bool,
}

impl Default for ServerConfig {
    fn default() -> Self {
        Self {
            transport: "sse".to_string(),
            bind: "127.0.0.1:8090".to_string(),
            validate: true,
            verbose: false,
        }
    }
}

// Constants
const SERVER_ADDR: &str = "127.0.0.1:8090";
const VENV_DIR: &str = "/tmp/mcp_venv";

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Create a default server configuration
    let config = ServerConfig::default();

    // Set up logging
    let log_level = if config.verbose { Level::DEBUG } else { Level::INFO };
    tracing_subscriber::fmt().with_max_level(log_level).init();

    // Create server state
    let state = AppState::default();

    // Create server session with custom options
    let mut server_session = ServerSession::new(state.clone(), ServerSessionOptions {
        name: "MCP-RS Example Server".to_string(),
        version: Some(env!("CARGO_PKG_VERSION").to_string()),
        validation: ValidationConfig {
            validate_requests: config.validate,
            validate_responses: config.validate,
        },
        capabilities: ServerCapabilities {
            resources: Some(ResourceCapabilities {
                subscribe: true,
                list_changed: true,
            }),
            tools: Some(ToolCapabilities { list_changed: true }),
            prompts: Some(PromptCapabilities { list_changed: true }),
            logging: Some(LoggingCapabilities {}),
            experimental: None,
        },
        instructions: Some("Example MCP server ready for commands".to_string()),
    });

    // Register application-specific handlers
    register_handlers(&mut server_session);

    // Parse socket address
    let addr: SocketAddr = config.bind.parse()?;

    // Create a oneshot channel to signal when the server is ready
    let (server_ready_tx, server_ready_rx) = tokio::sync::oneshot::channel();

    // Start the server in a separate task
    let server_handle = tokio::spawn(async move {
        match config.transport.as_str() {
            "sse" => {
                info!("Starting server with SSE transport on {}", addr);
                // Create a custom transport with specific options
                let mut transport = SseServerTransport::with_options(SseServerOptions {
                    bind_address: addr,
                    auth_token: None,
                    connection_timeout: std::time::Duration::from_secs(30),
                    keep_alive_interval: 30,
                    allowed_origins: None,
                    require_auth: false,
                });

                // Register lifecycle handler
                let state_for_lifecycle = state.clone();
                transport.register_lifecycle_handler(
                    Box::new(move |event| {
                        handle_lifecycle_event(event, &state_for_lifecycle);
                    })
                );

                info!("Server started! Listening for connections...");

                // Signal that the server is ready
                let _ = server_ready_tx.send(addr);

                // Run the server with SSE transport
                server_session.run(transport).await
            }
            "ws" => {
                info!("Starting server with WebSocket transport on {}", addr);
                let mut transport = WebSocketServerTransport::new();

                // Register lifecycle handler
                let state_for_lifecycle = state.clone();
                transport.register_lifecycle_handler(
                    Box::new(move |event| {
                        handle_lifecycle_event(event, &state_for_lifecycle);
                    })
                );

                info!("Server started! Listening for connections...");

                // Signal that the server is ready
                let _ = server_ready_tx.send(addr);

                // Run the server with WebSocket transport
                server_session.run(transport).await
            }
            _ => {
                let err = Error::Other(format!("Unsupported transport: {}", config.transport));
                return Err(err);
            }
        }
    });

    // Wait for the server to be ready
    match server_ready_rx.await {
        Ok(addr) => {
            info!("Server is ready on {}", addr);

            // Run Python client if requested (via environment variable)
            if std::env::var("RUN_PYTHON_CLIENT").unwrap_or_default() == "1" {
                run_python_client().await?;
            }
        }
        Err(e) => {
            return Err(format!("Failed to receive server ready signal: {}", e).into());
        }
    }

    // Wait for the server task to complete
    match server_handle.await {
        Ok(result) => {
            if let Err(e) = result {
                return Err(format!("Server error: {}", e).into());
            }
        }
        Err(e) => {
            return Err(format!("Server task error: {}", e).into());
        }
    }

    info!("Server stopped gracefully");
    Ok(())
}

/// Register application-specific method handlers
fn register_handlers(server: &mut ServerSession<AppState>) {
    // Register the calculator tool
    info!("Registering calculator tool");

    // Create the calculator tool definition using the ToolBuilder API
    let calc_tool = server
        .build_tool("calculator", "Performs arithmetic operations")
        .add_parameter(
            ToolParameterBuilder::new("operation", ToolParameterType::String)
                .description("Operation to perform (add, subtract, multiply, divide)")
                .required(true)
                .enum_values(vec!["add", "subtract", "multiply", "divide"])
                .default("add")
                .unwrap()
                .build()
        )
        .add_parameter(
            ToolParameterBuilder::new("a", ToolParameterType::Number)
                .description("First operand")
                .required(true)
                .build()
        )
        .add_parameter(
            ToolParameterBuilder::new("b", ToolParameterType::Number)
                .description("Second operand")
                .required(true)
                .build()
        )
        .return_type("number")
        .return_schema(
            serde_json::json!({
                "type": "object",
                "properties": {
                    "result": {
                        "type": "number",
                        "description": "The result of the calculation"
                    }
                },
                "required": ["result"]
            })
        )
        .streaming(false)
        .cancellable(false)
        .timeout(30)
        .build();

    // Register the calculator as an in-process tool
    server.register_in_process_tool(calc_tool, calculator_handler);

    // Resources list handler
    server.register_handler("resources/list", |state, params: ListResourcesParams| {
        let state = state.clone();
        Box::pin(async move {
            info!("Listing resources");

            // Increment request counter
            {
                let mut count = state.request_count.lock().unwrap();
                *count += 1;
            }

            // Get resources
            let resources = state.resources.lock().unwrap();
            let resources_list = resources
                .iter()
                .map(|(_, (resource, _))| resource.clone())
                .collect::<Vec<_>>();

            Ok(ListResourcesResult {
                resources: resources_list,
                next_page_token: None,
            })
        })
    });
}

/// Calculator tool implementation
fn calculator_handler(params: CallToolParams) -> Result<CallToolResult, Error> {
    // Extract operation and operands
    let operation = params.arguments
        .get("operation")
        .and_then(|v| v.as_str())
        .unwrap_or("add");
    let a = params.arguments
        .get("a")
        .and_then(|v| v.as_f64())
        .unwrap_or(0.0);
    let b = params.arguments
        .get("b")
        .and_then(|v| v.as_f64())
        .unwrap_or(0.0);

    // Perform calculation
    let result = match operation {
        "add" => a + b,
        "subtract" => a - b,
        "multiply" => a * b,
        "divide" => {
            if b == 0.0 {
                return Err(Error::InvalidParams("Division by zero".to_string()));
            }
            a / b
        }
        _ => {
            return Err(Error::InvalidParams(format!("Unknown operation: {}", operation)));
        }
    };

    // Log the calculation
    info!("Calculator: {} {} {} = {}", a, operation, b, result);

    // Create a TextContent struct for the result
    let text_content = TextContent {
        content_type: "text".to_string(),
        text: format!("The result of {} {} {} is {}", a, operation, b, result),
        annotations: None,
    };

    // Return result
    Ok(CallToolResult {
        // Use content field for Python/JS clients as a Vec of content items
        content: vec![serde_json::to_value(text_content).unwrap()],
        // Set isError flag to false
        is_error: false,
    })
}

/// Handle transport lifecycle events
fn handle_lifecycle_event(event: TransportLifecycleEvent, state: &AppState) {
    match event {
        TransportLifecycleEvent::Starting => {
            *state.transport_state.lock().unwrap() = "starting".to_string();
            info!("Transport starting");
        }
        TransportLifecycleEvent::Started => {
            *state.transport_state.lock().unwrap() = "started".to_string();
            info!("Transport started");
        }
        TransportLifecycleEvent::ClientConnected(client_id) => {
            info!("Client connected: {}", client_id);
            state.connected_clients
                .lock()
                .unwrap()
                .insert(client_id.clone(), "connected".to_string());
        }
        TransportLifecycleEvent::ClientDisconnected(client_id) => {
            info!("Client disconnected: {}", client_id);
            state.connected_clients.lock().unwrap().remove(&client_id);
        }
        TransportLifecycleEvent::Closing => {
            *state.transport_state.lock().unwrap() = "closing".to_string();
            info!("Transport closing");
        }
        TransportLifecycleEvent::Closed => {
            *state.transport_state.lock().unwrap() = "closed".to_string();
            info!("Transport closed");
        }
        TransportLifecycleEvent::Error => {
            *state.transport_state.lock().unwrap() = "error".to_string();
            error!("Transport error occurred");
        }
    }
}

/// Run a Python client that connects to the MCP server
async fn run_python_client() -> Result<(), Box<dyn std::error::Error>> {
    info!("Running Python client from python_client directory...");

    // Run the Python client script
    let output = std::process::Command
        ::new("bash")
        .arg("-c")
        .arg("cd python_client && ./run_client.sh --debug")
        .output()?;

    // Print stdout
    println!("\n--- Python Client Output (stdout) ---");
    println!("{}", String::from_utf8_lossy(&output.stdout));

    // Print stderr if there is any
    if !output.stderr.is_empty() {
        println!("\n--- Python Client Output (stderr) ---");
        println!("{}", String::from_utf8_lossy(&output.stderr));
    }

    // Check exit status
    if output.status.success() {
        info!("Python client completed successfully");
    } else {
        info!("Python client exited with status: {}", output.status);
    }

    Ok(())
}


<file_info>
path: src/types/prompts.rs
name: prompts.rs
</file_info>
//! MCP Prompt Types
//!
//! This module defines types related to prompts in the MCP protocol, including
//! `Prompt` and `PromptArgument`, which are used to manage and template interactive
//! user inputs or AI queries.

use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// A type of content that can be sent in a message
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
#[serde(tag = "type", content = "content")]
pub enum ContentPart {
    /// Text content
    #[serde(rename = "text")]
    Text(String),
    /// Image content (referenced by resource URI)
    #[serde(rename = "image")]
    Image { uri: String },
    /// Tool call content
    #[serde(rename = "tool_call")]
    ToolCall {
        /// Name of the tool to call
        tool_name: String,
        /// Parameters for the tool call
        parameters: HashMap<String, serde_json::Value>,
    },
    /// Tool result content
    #[serde(rename = "tool_result")]
    ToolResult {
        /// Name of the tool that was called
        tool_name: String,
        /// Result of the tool call
        result: serde_json::Value,
    },
}

/// Role of a message sender
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
#[serde(rename_all = "lowercase")]
pub enum Role {
    /// System message
    System,
    /// Human user message
    User,
    /// AI assistant message
    Assistant,
    /// Tool message (for tool calls or results)
    Tool,
}

/// A message in a prompt template
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct Message {
    /// Role of the message sender
    pub role: Role,
    /// Content of the message
    pub content: Vec<ContentPart>,
}

/// Represents a template argument
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct PromptArgument {
    /// Name of the argument
    pub name: String,
    /// Type of the argument (e.g., "string", "number")
    #[serde(rename = "type")]
    pub type_name: String,
    /// Description of the argument
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// Whether the argument is required
    #[serde(skip_serializing_if = "Option::is_none")]
    pub required: Option<bool>,
    /// Default value for the argument
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default: Option<serde_json::Value>,
    /// Schema for the argument, if complex
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema: Option<serde_json::Value>,
}

/// Represents a prompt template
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct Prompt {
    /// Unique name for the prompt
    pub name: String,
    /// Description of the prompt
    pub description: String,
    /// Template messages
    pub messages: Vec<Message>,
    /// Arguments for templating
    #[serde(skip_serializing_if = "Option::is_none")]
    pub arguments: Option<Vec<PromptArgument>>,
}

/// Parameters for listing prompts
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct ListPromptsParams {
    /// Optional pagination token
    #[serde(skip_serializing_if = "Option::is_none")]
    pub page_token: Option<String>,
    /// Optional limit on the number of prompts to return
    #[serde(skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i32>,
}

/// Result of listing prompts
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct ListPromptsResult {
    /// List of prompts
    pub prompts: Vec<Prompt>,
    /// Token for the next page (if there are more prompts)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_page_token: Option<String>,
}

/// Parameters for creating a prompt
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct CreatePromptParams {
    /// Unique name for the prompt
    pub name: String,
    /// Description of the prompt
    pub description: String,
    /// Template messages
    pub messages: Vec<Message>,
    /// Arguments for templating
    #[serde(skip_serializing_if = "Option::is_none")]
    pub arguments: Option<Vec<PromptArgument>>,
}

/// Result of creating a prompt
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct CreatePromptResult {
    /// The created prompt
    pub prompt: Prompt,
}

/// Parameters for updating a prompt
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct UpdatePromptParams {
    /// Name of the prompt to update
    pub name: String,
    /// New description for the prompt
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// New template messages
    #[serde(skip_serializing_if = "Option::is_none")]
    pub messages: Option<Vec<Message>>,
    /// New arguments for templating
    #[serde(skip_serializing_if = "Option::is_none")]
    pub arguments: Option<Vec<PromptArgument>>,
}

/// Result of updating a prompt
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct UpdatePromptResult {
    /// The updated prompt
    pub prompt: Prompt,
}

/// Parameters for deleting a prompt
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct DeletePromptParams {
    /// Name of the prompt to delete
    pub name: String,
}

/// Result of deleting a prompt
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct DeletePromptResult {
    /// Indicates whether the prompt was successfully deleted
    pub success: bool,
}

/// Parameters for rendering a prompt
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct RenderPromptParams {
    /// Name of the prompt to render
    pub name: String,
    /// Arguments for template substitution
    pub arguments: HashMap<String, serde_json::Value>,
}

/// Result of rendering a prompt
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct RenderPromptResult {
    /// Rendered messages
    pub messages: Vec<Message>,
}


<file_info>
path: src/resources.rs
name: resources.rs
</file_info>
/// Resource lifecycle state
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ResourceLifecycleState {
    /// Resource is created but not fully initialized
    Created,

    /// Resource is initialized and ready for use
    Ready,

    /// Resource has been modified
    Modified,

    /// Resource is being closed
    Closing,

    /// Resource is closed
    Closed,
}

/// Trait for resource implementations
#[async_trait]
pub trait ResourceImpl: Send + Sync + 'static {
    /// Get the resource content
    async fn read(&self) -> Result<Vec<u8>, Error>;

    /// Write content to the resource
    async fn write(&mut self, content: &[u8]) -> Result<(), Error>;

    /// Close the resource and release any associated resources
    async fn close(&mut self) -> Result<(), Error>;
}

/// Base resource structure
#[derive(Clone)]
pub struct Resource {
    /// Resource URI
    pub uri: String,

    /// Resource name
    pub name: String,

    /// Resource description
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,

    /// Resource mime type
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mime_type: Option<String>,

    /// Resource implementation
    #[serde(skip)]
    pub implementation: Arc<Mutex<Option<Box<dyn ResourceImpl>>>>,

    /// Resource lifecycle state
    #[serde(skip)]
    pub lifecycle_state: Arc<Mutex<ResourceLifecycleState>>,

    /// Subscribers to resource changes
    #[serde(skip)]
    pub subscribers: Arc<Mutex<Vec<mpsc::Sender<ResourceChangeNotification>>>>,
}

impl Resource {
    /// Create a new resource
    pub fn new(uri: String, name: String) -> Self {
        Self {
            uri,
            name,
            description: None,
            mime_type: None,
            implementation: Arc::new(Mutex::new(None)),
            lifecycle_state: Arc::new(Mutex::new(ResourceLifecycleState::Created)),
            subscribers: Arc::new(Mutex::new(Vec::new())),
        }
    }

    /// Set the resource implementation
    pub async fn set_implementation(
        &self,
        implementation: Box<dyn ResourceImpl>
    ) -> Result<(), Error> {
        let mut impl_guard = self.implementation.lock().await;
        *impl_guard = Some(implementation);

        // Update lifecycle state
        let mut state_guard = self.lifecycle_state.lock().await;
        *state_guard = ResourceLifecycleState::Ready;

        Ok(())
    }

    /// Read the resource content
    pub async fn read(&self) -> Result<Vec<u8>, Error> {
        // Check lifecycle state
        {
            let state_guard = self.lifecycle_state.lock().await;
            if *state_guard == ResourceLifecycleState::Closed {
                return Err(Error::Resource("Resource is closed".to_string()));
            }
        }

        // Get implementation
        let impl_guard = self.implementation.lock().await;
        match &*impl_guard {
            Some(implementation) => implementation.read().await,
            None => Err(Error::Resource("Resource has no implementation".to_string())),
        }
    }

    /// Write to the resource
    pub async fn write(&self, content: &[u8]) -> Result<(), Error> {
        // Check lifecycle state
        {
            let state_guard = self.lifecycle_state.lock().await;
            if *state_guard == ResourceLifecycleState::Closed {
                return Err(Error::Resource("Resource is closed".to_string()));
            }
        }

        // Get implementation
        let mut impl_guard = self.implementation.lock().await;
        match &mut *impl_guard {
            Some(implementation) => {
                let result = implementation.write(content).await;

                // Update lifecycle state
                if result.is_ok() {
                    let mut state_guard = self.lifecycle_state.lock().await;
                    *state_guard = ResourceLifecycleState::Modified;

                    // Notify subscribers
                    self.notify_change().await;
                }

                result
            }
            None => Err(Error::Resource("Resource has no implementation".to_string())),
        }
    }

    /// Close the resource
    pub async fn close(&self) -> Result<(), Error> {
        // Check lifecycle state
        {
            let state_guard = self.lifecycle_state.lock().await;
            if *state_guard == ResourceLifecycleState::Closed {
                return Ok(());
            }
        }

        // Update lifecycle state
        {
            let mut state_guard = self.lifecycle_state.lock().await;
            *state_guard = ResourceLifecycleState::Closing;
        }

        // Get implementation
        let mut impl_guard = self.implementation.lock().await;
        let result = match &mut *impl_guard {
            Some(implementation) => implementation.close().await,
            None => Ok(()),
        };

        // Update lifecycle state
        {
            let mut state_guard = self.lifecycle_state.lock().await;
            *state_guard = ResourceLifecycleState::Closed;
        }

        // Clear subscribers
        {
            let mut subscribers_guard = self.subscribers.lock().await;
            subscribers_guard.clear();
        }

        result
    }

    /// Subscribe to resource changes
    pub async fn subscribe(&self) -> mpsc::Receiver<ResourceChangeNotification> {
        let (tx, rx) = mpsc::channel(10);

        // Add subscriber
        {
            let mut subscribers_guard = self.subscribers.lock().await;
            subscribers_guard.push(tx);
        }

        rx
    }

    /// Notify subscribers of a change
    async fn notify_change(&self) {
        let notification = ResourceChangeNotification {
            uri: self.uri.clone(),
            timestamp: std::time::SystemTime::now().into(),
        };

        let mut subscribers_guard = self.subscribers.lock().await;
        subscribers_guard.retain(|tx| { tx.try_send(notification.clone()).is_ok() });
    }
}


<file_info>
path: src/types/mod.rs
name: mod.rs
</file_info>
//! MCP Type Definitions
//!
//! This module re-exports various type definitions used in the MCP protocol, organizing
//! them into submodules for clarity and ease of use. It includes types for initialization,
//! prompts, resources, and tools.

pub mod initialize;
pub mod prompts;
pub mod resources;
pub mod tools;

// Re-export common types from each module
pub use initialize::{
    ClientCapabilities, Implementation, InitializeRequestParams, InitializeResult,
    ServerCapabilities,
};
pub use prompts::{ContentPart, Message, Prompt, PromptArgument, Role};
pub use resources::{ListResourcesParams, ListResourcesResult, Resource};
pub use tools::{CallToolParams, CallToolResult, Tool, ToolParameter};


<file_info>
path: src/lib.rs
name: lib.rs
</file_info>
//! MCP Rust Library
//!
//! This crate provides a Rust implementation of the Model Context Protocol (MCP),
//! enabling seamless integration between AI applications and external data sources
//! or tools. It includes both client and server components, supporting various
//! transports like STDIO and SSE, with a focus on type safety, performance, and
//! extensibility.

// Re-export core components
pub mod client;
pub mod errors;
pub mod lifecycle;
pub mod lifecycle_context;
pub mod messages;
pub mod server;
pub mod server_session;
pub mod tools;
pub mod transport;
pub mod types;
pub mod utils;
// Re-export commonly used items
pub use errors::Error;
pub use lifecycle::{
    ClientLifecycleState,
    LifecycleContext,
    LifecycleManager,
    NegotiatedCapabilities,
    ProtocolVersion,
    RequestContext,
    ServerLifecycleState,
};
pub use transport::Transport;
pub use transport::sse::SseTransport;
pub use transport::stdio::StdioTransport;


<file_info>
path: src/server_session.rs
name: server_session.rs
</file_info>
//! MCP Server Session
//!
//! This module provides a high-level server session interface that automatically
//! handles protocol operations like initialization and shutdown.
//!
use futures::future::BoxFuture;
use std::collections::HashMap;
use tracing::{ debug, info };
use std::sync::Arc;

use crate::errors::Error;
use crate::server::Server;
use crate::transport::Transport;
use crate::types::initialize::{
    Implementation,
    InitializeRequestParams,
    InitializeResult,
    ServerCapabilities,
};
use crate::types::tools::{ CallToolResult, Tool, CallToolParams, ToolBuilder, ToolParameterType };
use crate::utils::validation::ValidationConfig;

/// Configuration options for the server session
#[derive(Clone, Debug)]
pub struct ServerSessionOptions {
    /// Server name
    pub name: String,
    /// Server version
    pub version: Option<String>,
    /// Validation configuration
    pub validation: ValidationConfig,
    /// Server capabilities
    pub capabilities: ServerCapabilities,
    /// Instructions to send to client during initialization
    pub instructions: Option<String>,
}

impl Default for ServerSessionOptions {
    fn default() -> Self {
        Self {
            name: "MCP Server".to_string(),
            version: Some(env!("CARGO_PKG_VERSION").to_string()),
            validation: ValidationConfig::default(),
            capabilities: ServerCapabilities {
                resources: None,
                tools: None,
                prompts: None,
                logging: None,
                experimental: None,
            },
            instructions: None,
        }
    }
}

/// MCP server session that automatically handles protocol operations
pub struct ServerSession<T: Clone + Send + Sync + 'static> {
    /// Server instance
    server: Server<T>,
    /// Session options
    options: ServerSessionOptions,
    /// Whether the session has been started
    started: bool,
}

impl<T: Clone + Send + Sync + 'static> ServerSession<T> {
    /// Create a new server session with the given state and options
    pub fn new(state: T, options: ServerSessionOptions) -> Self {
        // Create server with the given validation config
        let server = Server::new(state)
            .validate_requests(options.validation.validate_requests)
            .validate_responses(options.validation.validate_responses);

        // Create the session
        let mut session = Self {
            server,
            options: options.clone(),
            started: false,
        };

        // Register core protocol handlers
        Self::register_core_handlers(&mut session.server, options);

        session
    }

    /// Create a new server session with default options
    pub fn with_default_options(state: T) -> Self {
        Self::new(state, ServerSessionOptions::default())
    }

    /// Register a method handler
    pub fn register_handler<P, R, F>(&mut self, method: &str, handler: F)
        where
            P: for<'de> serde::de::Deserialize<'de> + Send + Sync + 'static,
            R: serde::Serialize + Send + Sync + 'static,
            F: Fn(&T, P) -> BoxFuture<'static, Result<R, Error>> + Send + Sync + 'static
    {
        self.server.register_handler(method, handler);
    }

    /// Register an external tool with the server
    pub fn register_external_tool(
        &mut self,
        tool: Tool,
        command: String,
        args: Vec<String>,
        env: HashMap<String, String>
    ) {
        // Register with the server's tool registry asynchronously
        let tool_clone = tool.clone();
        let tool_registry = self.server.tool_registry.clone();

        tokio::spawn(async move {
            let _ = tool_registry.register_external_tool(tool_clone, command, args, env).await;
        });
    }

    /// Register an in-process tool with a handler function
    pub fn register_in_process_tool<F>(&mut self, tool: Tool, handler: F)
        where F: Fn(CallToolParams) -> Result<CallToolResult, Error> + Send + Sync + 'static
    {
        // Register with the server's tool registry asynchronously
        let tool_clone = tool.clone();
        let tool_registry = self.server.tool_registry.clone();

        // Create a handler that will be processed asynchronously
        let handler_arc = Arc::new(handler);
        let handler_clone = handler_arc.clone();

        tokio::spawn(async move {
            let _ = tool_registry.register_in_process_tool(tool_clone, move |params|
                handler_clone(params)
            ).await;
        });
    }

    /// Start building a tool with the given name and description.
    /// Returns a ToolBuilder that can be used to configure the tool.
    pub fn build_tool(
        &self,
        name: impl Into<String>,
        description: impl Into<String>
    ) -> crate::types::tools::ToolBuilder {
        crate::types::tools::ToolBuilder::new(name, description)
    }

    /// Run the server session with the given transport
    pub async fn run<TR: Transport>(&mut self, transport: TR) -> Result<(), Error> {
        if self.started {
            return Err(Error::Initialization("Server already started".to_string()));
        }

        self.started = true;
        info!("Starting MCP server session with {} transport", std::any::type_name::<TR>());

        // Run the server
        self.server.run(transport).await
    }

    /// Register core protocol handlers
    fn register_core_handlers(server: &mut Server<T>, options: ServerSessionOptions) {
        // Initialize handler
        server.register_initialize_handler(move |_state, params: InitializeRequestParams| {
            let options_clone = options.clone();

            Box::pin(async move {
                debug!("Initializing server");

                Ok(InitializeResult {
                    protocol_version: params.protocol_version,
                    server_info: Some(Implementation {
                        name: options_clone.name,
                        version: options_clone.version,
                    }),
                    capabilities: options_clone.capabilities,
                    instructions: options_clone.instructions,
                })
            })
        });

        // Ping handler
        server.register_handler("ping", |state, _: serde_json::Value| {
            let state_clone = state.clone();

            Box::pin(async move {
                debug!("Ping received");
                Ok(serde_json::json!({ "status": "ok" }))
            })
        });

        // Tools/list handler to return all registered tools
        let tool_registry = server.tool_registry.clone();
        server.register_handler(
            "tools/list",
            move |_state, _params: crate::types::tools::ListToolsParams| {
                let registry = tool_registry.clone();

                Box::pin(async move {
                    // Get the list of registered tools using the tool registry
                    let tools = registry.list_tools().await;

                    // Return the tools
                    Ok(crate::types::tools::ListToolsResult {
                        tools,
                        next_page_token: None,
                    })
                })
            }
        );

        // Tools/call handler - generic handler for all tools
        let tool_registry = server.tool_registry.clone();
        server.register_handler("tools/call", move |_state, params: CallToolParams| {
            let registry = tool_registry.clone();
            let params_clone = params.clone();

            Box::pin(async move {
                // Execute the tool using the enhanced registry
                match registry.execute_tool_with_params(params_clone).await {
                    Ok(result) => Ok(result),
                    Err(e) => {
                        // Return a properly formatted error
                        Ok(CallToolResult {
                            content: vec![
                                serde_json::json!({
                                "error": e.to_string(),
                                "status": "error"
                            })
                            ],
                            is_error: true,
                        })
                    }
                }
            })
        });
    }
}


<file_info>
path: src/tools/tool_registry.rs
name: tool_registry.rs
</file_info>
use crate::errors::Error;
use crate::tools::process_manager::ToolProcessManager;
use crate::types::tools::{ Tool, CallToolParams, CallToolResult, TextContent };
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::{ Mutex, mpsc };

use super::process_manager::ToolOutput;

/// Handler type for in-process tools
type ToolHandler = Arc<dyn (Fn(CallToolParams) -> Result<CallToolResult, Error>) + Send + Sync>;

/// Tool definition variants to properly represent different tool types
pub enum ToolDefinition {
    /// External tool executed as a subprocess
    External {
        tool: Tool,
        command: String,
        args: Vec<String>,
        env: HashMap<String, String>,
    },
    /// In-process tool executed directly
    InProcess {
        tool: Tool,
        handler: ToolHandler,
    },
}

impl ToolDefinition {
    /// Get the tool metadata regardless of type
    pub fn get_tool(&self) -> &Tool {
        match self {
            ToolDefinition::External { tool, .. } => tool,
            ToolDefinition::InProcess { tool, .. } => tool,
        }
    }
}

pub struct ToolRegistry {
    tools: Arc<Mutex<HashMap<String, ToolDefinition>>>,
    process_manager: Arc<ToolProcessManager>,
}

impl ToolRegistry {
    pub fn new() -> Self {
        Self {
            tools: Arc::new(Mutex::new(HashMap::new())),
            process_manager: Arc::new(ToolProcessManager::new()),
        }
    }

    /// Register a tool in the registry
    pub async fn register_tool(
        &self,
        tool: Tool,
        command: String,
        args: Vec<String>,
        env: HashMap<String, String>
    ) -> Result<(), Error> {
        let mut tools = self.tools.lock().await;
        tools.insert(tool.name.clone(), ToolDefinition::External {
            tool,
            command,
            args,
            env,
        });
        Ok(())
    }

    /// Register an in-process tool with a function handler
    pub async fn register_in_process_tool(
        &self,
        tool: Tool,
        handler: impl (Fn(CallToolParams) -> Result<CallToolResult, Error>) + Send + Sync + 'static
    ) -> Result<(), Error> {
        let mut tools = self.tools.lock().await;

        // Store the tool definition with its handler
        tools.insert(tool.name.clone(), ToolDefinition::InProcess {
            tool,
            handler: Arc::new(handler),
        });

        Ok(())
    }

    /// Register an external tool that executes as a subprocess
    ///
    /// This is a convenience method that can be called directly instead of
    /// going through the Server.
    pub async fn register_external_tool(
        &self,
        tool: Tool,
        command: String,
        args: Vec<String>,
        env: HashMap<String, String>
    ) -> Result<(), Error> {
        println!(
            "DEBUG: Registering external tool directly in ToolRegistry: {} with command: {}",
            tool.name,
            command
        );
        self.register_tool(tool, command, args, env).await
    }

    pub async fn list_tools(&self) -> Vec<Tool> {
        let tools = self.tools.lock().await;
        println!(
            "LISTING TOOLS CALLED: Available tools in registry: {}",
            tools.keys().cloned().collect::<Vec<String>>().join(", ")
        );
        tools
            .values()
            .map(|def| def.get_tool().clone())
            .collect()
    }

    /// Execute a tool using CallToolParams and return a CallToolResult
    pub async fn execute_tool_with_params(
        &self,
        params: CallToolParams
    ) -> Result<CallToolResult, Error> {
        let tool_name = &params.name;
        let tools = self.tools.lock().await;

        let definition = tools
            .get(tool_name)
            .ok_or_else(|| Error::Tool(format!("Tool not found: {}", tool_name)))?;

        match definition {
            ToolDefinition::InProcess { handler, .. } => {
                // Execute the in-process handler directly
                handler(params.clone())
            }
            ToolDefinition::External { .. } => {
                // For external tools, use the process executor
                drop(tools); // Release the lock before the async operation
                let receiver = self.execute_tool(tool_name, params.arguments).await?;
                self.process_tool_output(receiver).await
            }
        }
    }

    /// Process the output from a tool execution to create a CallToolResult
    async fn process_tool_output(
        &self,
        mut receiver: mpsc::Receiver<ToolOutput>
    ) -> Result<CallToolResult, Error> {
        let mut stdout_content = String::new();
        let mut stderr_content = String::new();

        // Process output messages
        while let Some(output) = receiver.recv().await {
            match output.output_type {
                super::process_manager::ToolOutputType::Stdout => {
                    stdout_content.push_str(&output.content);
                }
                super::process_manager::ToolOutputType::Stderr => {
                    stderr_content.push_str(&output.content);
                }
            }
        }

        // Determine if there's an error based on stderr content
        let is_error = !stderr_content.is_empty();

        // Prepare the result content
        let content = if is_error {
            // Return stderr as error text
            vec![
                serde_json
                    ::to_value(TextContent {
                        content_type: "text".to_string(),
                        text: stderr_content,
                        annotations: None,
                    })
                    .unwrap()
            ]
        } else {
            // Try to parse stdout as JSON, fall back to text if it fails
            match serde_json::from_str::<serde_json::Value>(&stdout_content) {
                Ok(json_value) => { vec![json_value] }
                Err(_) => {
                    vec![
                        serde_json
                            ::to_value(TextContent {
                                content_type: "text".to_string(),
                                text: stdout_content,
                                annotations: None,
                            })
                            .unwrap()
                    ]
                }
            }
        };

        Ok(CallToolResult {
            content,
            is_error,
        })
    }

    pub async fn execute_tool(
        &self,
        tool_name: &str,
        parameters: HashMap<String, serde_json::Value>
    ) -> Result<mpsc::Receiver<ToolOutput>, Error> {
        let tools = self.tools.lock().await;
        let definition = tools
            .get(tool_name)
            .ok_or_else(|| Error::Tool(format!("Tool not found: {}", tool_name)))?;

        // Handle based on tool type
        match definition {
            ToolDefinition::InProcess { .. } => {
                return Err(
                    Error::Tool(
                        format!("Tool '{}' is an in-process tool and should be executed with execute_tool_with_params", tool_name)
                    )
                );
            }
            ToolDefinition::External { command, args, env, .. } => {
                // Prepare parameters as environment variables
                let mut tool_env = env.clone();
                for (key, value) in &parameters {
                    tool_env.insert(format!("PARAM_{}", key.to_uppercase()), value.to_string());
                }

                // Also pass parameters as JSON
                tool_env.insert(
                    "TOOL_PARAMETERS".to_string(),
                    serde_json::to_string(&parameters).map_err(|e| Error::Json(e))?
                );

                // Convert args to &str array
                let args_ref: Vec<&str> = args
                    .iter()
                    .map(|s| s.as_str())
                    .collect();

                // Execute the tool
                let tool_id = format!("{}_{}", tool_name, uuid::Uuid::new_v4());
                self.process_manager.spawn_process(&tool_id, command, &args_ref, tool_env).await
            }
        }
    }

    /// Check if a tool exists in the registry
    pub async fn has_tool(&self, tool_name: &str) -> bool {
        let tools = self.tools.lock().await;
        tools.contains_key(tool_name)
    }

    /// Get a tool definition by name
    pub async fn get_tool(&self, tool_name: &str) -> Option<Tool> {
        let tools = self.tools.lock().await;
        tools.get(tool_name).map(|def| def.get_tool().clone())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::types::tools::{ Tool, ToolBuilder, ToolParameterType };

    #[tokio::test]
    async fn test_in_process_tool() {
        // Create a simple calculator tool
        let calc_tool = ToolBuilder::new("calculator", "Performs basic arithmetic")
            .add_parameter(
                crate::types::tools::ToolParameterBuilder
                    ::new("a", ToolParameterType::Number)
                    .required(true)
                    .build()
            )
            .add_parameter(
                crate::types::tools::ToolParameterBuilder
                    ::new("b", ToolParameterType::Number)
                    .required(true)
                    .build()
            )
            .add_parameter(
                crate::types::tools::ToolParameterBuilder
                    ::new("operation", ToolParameterType::String)
                    .enum_values(vec!["add", "subtract", "multiply", "divide"])
                    .required(true)
                    .build()
            )
            .build();

        // Create a registry
        let registry = ToolRegistry::new();

        // Register the calculator tool
        registry
            .register_in_process_tool(calc_tool, |params: CallToolParams| {
                let a = params.arguments
                    .get("a")
                    .and_then(|v| v.as_f64())
                    .ok_or_else(|| Error::InvalidParams("Missing parameter 'a'".to_string()))?;

                let b = params.arguments
                    .get("b")
                    .and_then(|v| v.as_f64())
                    .ok_or_else(|| Error::InvalidParams("Missing parameter 'b'".to_string()))?;

                let operation = params.arguments
                    .get("operation")
                    .and_then(|v| v.as_str())
                    .ok_or_else(||
                        Error::InvalidParams("Missing parameter 'operation'".to_string())
                    )?;

                let result = match operation {
                    "add" => a + b,
                    "subtract" => a - b,
                    "multiply" => a * b,
                    "divide" => {
                        if b == 0.0 {
                            return Err(Error::InvalidParams("Cannot divide by zero".to_string()));
                        }
                        a / b
                    }
                    _ => {
                        return Err(
                            Error::InvalidParams(format!("Unknown operation: {}", operation))
                        );
                    }
                };

                Ok(CallToolResult {
                    content: vec![serde_json::json!({ "result": result })],
                    is_error: false,
                })
            }).await
            .unwrap();

        // Execute the tool
        let params = CallToolParams {
            name: "calculator".to_string(),
            arguments: [
                ("a".to_string(), serde_json::json!(2)),
                ("b".to_string(), serde_json::json!(3)),
                ("operation".to_string(), serde_json::json!("add")),
            ]
                .into_iter()
                .collect(),
        };

        let result = registry.execute_tool_with_params(params).await.unwrap();
        assert!(!result.is_error);

        let result_value = result.content[0]
            .get("result")
            .and_then(|v| v.as_f64())
            .unwrap();
        assert_eq!(result_value, 5.0);
    }
}


<file_info>
path: src/tools/progress.rs
name: progress.rs
</file_info>
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::Mutex;
use tokio::sync::broadcast;

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ToolProgress {
    pub tool_name: String,
    pub tool_id: String,
    pub progress: f64, // 0.0 to 1.0
    pub message: Option<String>,
    pub timestamp: u64,
}

pub struct ToolProgressTracker {
    progress: Arc<Mutex<HashMap<String, ToolProgress>>>,
    sender: broadcast::Sender<ToolProgress>,
}

impl ToolProgressTracker {
    pub fn new() -> Self {
        let (sender, _) = broadcast::channel(100);
        Self {
            progress: Arc::new(Mutex::new(HashMap::new())),
            sender,
        }
    }

    pub fn subscribe(&self) -> broadcast::Receiver<ToolProgress> {
        self.sender.subscribe()
    }

    pub async fn update_progress(&self, progress: ToolProgress) {
        let mut progress_map = self.progress.lock().await;
        progress_map.insert(progress.tool_id.clone(), progress.clone());
        let _ = self.sender.send(progress);
    }

    pub async fn get_progress(&self, tool_id: &str) -> Option<ToolProgress> {
        let progress_map = self.progress.lock().await;
        progress_map.get(tool_id).cloned()
    }
}


<file_info>
path: src/client.rs
name: client.rs
</file_info>
//! MCP Client
//!
//! This module implements the MCP client, responsible for connecting to MCP servers,
//! sending requests, and receiving responses. It abstracts the underlying transport
//! layer, allowing for easy integration with different communication channels.

use serde::{ Serialize, de::DeserializeOwned };
use std::collections::HashMap;
use std::sync::Arc;
use std::sync::atomic::{ AtomicI32, Ordering };
use tokio::sync::oneshot;
use tokio::sync::{ Mutex, mpsc };
use tokio::task::JoinHandle;

use crate::errors::Error;
use crate::messages::{
    GenericRequest,
    Message as McpMessage,
    Notification,
    Response,
    ResponseOutcome,
};
use crate::transport::Transport;
use crate::types::initialize::{ InitializeRequestParams, InitializeResult };
use crate::types::prompts::{
    ContentPart,
    CreatePromptParams,
    CreatePromptResult,
    DeletePromptParams,
    DeletePromptResult,
    ListPromptsParams,
    ListPromptsResult,
    Message,
    RenderPromptParams,
    RenderPromptResult,
    Role,
    UpdatePromptParams,
    UpdatePromptResult,
};
use crate::types::resources::{
    CreateResourceParams,
    CreateResourceResult,
    DeleteResourceParams,
    DeleteResourceResult,
    FileResource,
    GetResourceParams,
    GetResourceResult,
    ListResourcesParams,
    ListResourcesResult,
    UpdateResourceParams,
    UpdateResourceResult,
};
use crate::types::tools::{ CallToolParams, CallToolResult, ListToolsParams, ListToolsResult };
use crate::utils::validation::{ ValidationConfig, validate_request, validate_response };

/// A client for communicating with an MCP server
pub struct Client<T> {
    /// The transport used for communication
    transport: Arc<Mutex<T>>,
    /// Counter for generating request IDs
    request_id_counter: AtomicI32,
    /// Pending requests waiting for responses
    pending_requests: Arc<Mutex<HashMap<i32, oneshot::Sender<Result<Response, Error>>>>>,
    /// Notification listeners
    notification_listeners: Arc<Mutex<Vec<mpsc::Sender<Notification>>>>,
    /// Background task handle for the message loop
    message_loop_handle: Option<JoinHandle<Result<(), Error>>>,
    /// Validation configuration
    validation_config: ValidationConfig,
}

impl<T: Transport + 'static> Client<T> {
    /// Create a new client with the given transport
    pub fn new(transport: T) -> Self {
        Self {
            transport: Arc::new(Mutex::new(transport)),
            request_id_counter: AtomicI32::new(1),
            pending_requests: Arc::new(Mutex::new(HashMap::new())),
            notification_listeners: Arc::new(Mutex::new(Vec::new())),
            message_loop_handle: None,
            validation_config: ValidationConfig::default(),
        }
    }

    /// Set validation configuration
    pub fn with_validation_config(mut self, config: ValidationConfig) -> Self {
        self.validation_config = config;
        self
    }

    /// Enable or disable request validation
    pub fn validate_requests(mut self, validate: bool) -> Self {
        self.validation_config.validate_requests = validate;
        self
    }

    /// Enable or disable response validation
    pub fn validate_responses(mut self, validate: bool) -> Self {
        self.validation_config.validate_responses = validate;
        self
    }

    /// Start the message handling loop in a background task
    pub fn start_message_loop(&mut self) -> Result<(), Error> {
        if self.message_loop_handle.is_some() {
            return Err(Error::Other("Message loop already started".to_string()));
        }

        let transport = self.transport.clone();
        let pending_requests = self.pending_requests.clone();
        let notification_listeners = self.notification_listeners.clone();

        let handle = tokio::spawn(async move {
            tracing::info!("Starting client message loop");
            loop {
                // Use a timeout to periodically check for messages and ensure we don't hold the lock indefinitely
                let mut transport_guard = transport.lock().await;

                let message_result = match
                    tokio::time::timeout(
                        std::time::Duration::from_millis(100),
                        transport_guard.receive()
                    ).await
                {
                    Ok(result) => {
                        // Received a message or error before timeout
                        drop(transport_guard);

                        result
                    }
                    Err(_) => {
                        // Timeout occurred, release lock and continue
                        drop(transport_guard);
                        tracing::debug!("Message loop released transport lock after timeout");
                        // Small sleep to avoid tight loop
                        tokio::time::sleep(tokio::time::Duration::from_millis(10)).await;
                        continue;
                    }
                };

                // Process the message or error
                match message_result {
                    Ok((_, message)) =>
                        match message {
                            McpMessage::Response(response) => {
                                tracing::debug!("Received response with id={}", response.id);
                                let mut requests = pending_requests.lock().await;
                                let sender = requests.remove(&response.id);
                                tracing::debug!(
                                    "Sender found for id={}: {}",
                                    response.id,
                                    sender.is_some()
                                );
                                if let Some(sender) = sender {
                                    if sender.send(Ok(response.clone())).is_err() {
                                        tracing::warn!(
                                            "Failed to send response to oneshot channel for id={}",
                                            response.id
                                        );
                                    }
                                } else {
                                    tracing::warn!(
                                        "No sender found for response id={}",
                                        response.id
                                    );
                                }
                            }
                            McpMessage::Notification(notification) => {
                                tracing::debug!("Received notification: {}", notification.method);
                                let listeners = notification_listeners.lock().await.clone();
                                for listener in listeners {
                                    let _ = listener.try_send(notification.clone());
                                }
                            }
                            McpMessage::Request(_) => {
                                tracing::warn!("Client received unexpected request");
                            }
                        }
                    Err(e) => {
                        tracing::error!("Message loop error: {}", e);
                        return Err(e);
                    }
                }
            }
        });

        self.message_loop_handle = Some(handle);
        Ok(())
    }
    /// Stop the message handling loop
    pub async fn stop_message_loop(&mut self) -> Result<(), Error> {
        if let Some(handle) = self.message_loop_handle.take() {
            handle.abort();
            let _ = handle.await;
        }
        Ok(())
    }

    /// Send a request and wait for a response
    pub async fn send_request<P, R>(&self, method: &str, params: P) -> Result<R, Error>
        where P: Serialize + Send + Sync, R: DeserializeOwned + Send + Sync
    {
        let id = self.request_id_counter.fetch_add(1, Ordering::SeqCst);
        tracing::debug!("Preparing request id={} for method={}", id, method);

        let request = GenericRequest {
            jsonrpc: "2.0".to_string(),
            id: Some(id),
            method: method.to_string(),
            params: Some(serde_json::to_value(params).map_err(Error::Json)?),
        };

        if let Err(e) = validate_request(&request, &self.validation_config) {
            tracing::error!("Request validation failed: {}", e);
            return Err(e);
        }

        let (tx, rx) = oneshot::channel();

        {
            let mut pending = self.pending_requests.lock().await;
            tracing::debug!("Registering request id={} in pending_requests", id);
            pending.insert(id, tx);
        }

        tracing::debug!("About to acquire transport lock for request id={}", id);
        let send_result = {
            let start = std::time::Instant::now();

            // Use a timeout to acquire the transport lock to avoid deadlocks
            let transport_lock_result = tokio::time::timeout(
                std::time::Duration::from_secs(10),
                self.transport.lock()
            ).await;

            match transport_lock_result {
                Ok(mut transport_guard) => {
                    let elapsed = start.elapsed();
                    tracing::debug!(
                        "Acquired transport lock for request id={} after {:?}",
                        id,
                        elapsed
                    );

                    tracing::debug!("Sending request id={} via transport", id);
                    let result = transport_guard.send(&McpMessage::Request(request)).await;
                    tracing::debug!(
                        "Transport.send completed for request id={}, result: {:?}",
                        id,
                        result.is_ok()
                    );
                    result
                }
                Err(_) => {
                    tracing::error!(
                        "Timeout waiting to acquire transport lock for request id={}",
                        id
                    );
                    Err(Error::Transport("Timeout waiting to acquire transport lock".to_string()))
                }
            }
        };
        tracing::debug!("Released transport lock for request id={}", id);

        if let Err(e) = send_result {
            tracing::error!("Failed to send request id={}: {}", id, e);
            let mut pending = self.pending_requests.lock().await;
            pending.remove(&id);
            return Err(e);
        }

        tracing::debug!("Request id={} sent successfully, waiting for response", id);

        let response = tokio::time
            ::timeout(std::time::Duration::from_secs(30), rx).await
            .map_err(|_| {
                Error::Transport(format!("Timeout waiting for response to request id={}", id))
            })?
            .map_err(|_| Error::Transport("Response channel closed".to_string()))?;

        let response = response?;

        if self.validation_config.validate_responses {
            if let Err(e) = validate_response(&response, method, &self.validation_config) {
                tracing::error!("Response validation failed: {}", e);
                return Err(e);
            }
        }

        match response.outcome {
            ResponseOutcome::Success { result } => {
                tracing::debug!("Received successful response for id={}", id);
                Ok(serde_json::from_value(result).map_err(Error::Json)?)
            }
            ResponseOutcome::Error { error } => {
                tracing::error!(
                    "Received error response for id={}: {} (code: {})",
                    id,
                    error.message,
                    error.code
                );
                Err(
                    Error::Protocol(
                        format!("Server returned error: {} (code: {})", error.message, error.code)
                    )
                )
            }
        }
    }

    /// Register a listener for notifications
    pub async fn register_notification_listener(&self) -> mpsc::Receiver<Notification> {
        let (tx, rx) = mpsc::channel(100);

        let mut listeners = self.notification_listeners.lock().await;
        listeners.push(tx);

        rx
    }

    /// Initialize the connection with the server
    pub async fn initialize(
        &self,
        params: InitializeRequestParams
    ) -> Result<InitializeResult, Error> {
        self.send_request("initialize", params).await
    }

    /// List available resources
    pub async fn list_resources(
        &self,
        params: ListResourcesParams
    ) -> Result<ListResourcesResult, Error> {
        self.send_request("resources/list", params).await
    }

    /// Get a resource by URI
    pub async fn get_resource(
        &self,
        params: GetResourceParams
    ) -> Result<GetResourceResult, Error> {
        self.send_request("resources/get", params).await
    }

    /// Create a new resource
    pub async fn create_resource(
        &self,
        params: CreateResourceParams
    ) -> Result<CreateResourceResult, Error> {
        self.send_request("resources/create", params).await
    }

    /// Update an existing resource
    pub async fn update_resource(
        &self,
        params: UpdateResourceParams
    ) -> Result<UpdateResourceResult, Error> {
        self.send_request("resources/update", params).await
    }

    /// Delete a resource
    pub async fn delete_resource(
        &self,
        params: DeleteResourceParams
    ) -> Result<DeleteResourceResult, Error> {
        self.send_request("resources/delete", params).await
    }

    /// List available prompts
    pub async fn list_prompts(
        &self,
        params: ListPromptsParams
    ) -> Result<ListPromptsResult, Error> {
        self.send_request("prompts/list", params).await
    }

    /// Create a new prompt
    pub async fn create_prompt(
        &self,
        params: CreatePromptParams
    ) -> Result<CreatePromptResult, Error> {
        self.send_request("prompts/create", params).await
    }

    /// Update an existing prompt
    pub async fn update_prompt(
        &self,
        params: UpdatePromptParams
    ) -> Result<UpdatePromptResult, Error> {
        self.send_request("prompts/update", params).await
    }

    /// Delete a prompt
    pub async fn delete_prompt(
        &self,
        params: DeletePromptParams
    ) -> Result<DeletePromptResult, Error> {
        self.send_request("prompts/delete", params).await
    }

    /// Render a prompt with the given arguments
    pub async fn render_prompt(
        &self,
        params: RenderPromptParams
    ) -> Result<RenderPromptResult, Error> {
        self.send_request("prompts/render", params).await
    }

    /// List available tools
    pub async fn list_tools(&self, params: ListToolsParams) -> Result<ListToolsResult, Error> {
        self.send_request("tools/list", params).await
    }

    /// Call a tool
    pub async fn call_tool(&self, params: CallToolParams) -> Result<CallToolResult, Error> {
        self.send_request("tools/call", params).await
    }

    /// Close the client and its transport
    pub async fn close(&self) -> Result<(), Error> {
        let mut transport = self.transport.lock().await;
        transport.close().await
    }

    /// Create a FileResource instance without uploading it
    pub fn file_resource(
        &self,
        name: &str,
        path: &std::path::Path,
        description: Option<String>,
        mime_type: Option<String>,
        is_binary: bool
    ) -> Result<FileResource, Error> {
        FileResource::new(None, name.to_string(), path, description, mime_type, is_binary).map_err(
            |e| Error::Resource(format!("Failed to create file resource: {}", e))
        )
    }
}

/// Builder for creating and configuring a client
pub struct ClientBuilder<T> {
    transport: T,
}

impl<T: Transport + 'static> ClientBuilder<T> {
    /// Create a new client builder with the given transport
    pub fn new(transport: T) -> Self {
        Self { transport }
    }

    /// Build the client and start its message loop
    pub async fn build(self) -> Result<Client<T>, Error> {
        let mut client = Client::new(self.transport);
        client.start_message_loop()?;
        Ok(client)
    }
}

/// A session-oriented wrapper for the MCP client
///
/// This provides a higher-level session-based interface for working with MCP servers,
/// including support for file resources, progress notifications, and message creation.
pub struct ClientSession<T: Transport + 'static> {
    /// The underlying client
    client: Client<T>,
    /// Session state information
    session_info: Arc<Mutex<Option<InitializeResult>>>,
    /// Indicates whether the session is started
    is_started: bool,
    /// Server information
    server_info: Option<InitializeResult>,
}

impl<T: Transport + 'static> ClientSession<T> {
    /// Create a new client session with the given transport
    pub fn new(transport: T) -> Self {
        Self {
            client: Client::new(transport),
            session_info: Arc::new(Mutex::new(None)),
            is_started: false,
            server_info: None,
        }
    }

    /// Configure validation for this session
    pub fn with_validation_config(self, config: ValidationConfig) -> Self {
        Self {
            client: self.client.with_validation_config(config),
            session_info: self.session_info,
            is_started: self.is_started,
            server_info: self.server_info,
        }
    }

    /// Start the session by initializing the message loop
    pub async fn start(&mut self) -> Result<(), Error> {
        if self.is_started {
            tracing::warn!("ClientSession.start() called but session is already started");
            return Ok(());
        }

        tracing::info!("Starting client session message loop");
        self.client.start_message_loop()?;
        self.is_started = true;
        Ok(())
    }

    /// Initialize the connection with the server and store session info
    pub async fn initialize(
        &mut self,
        params: InitializeRequestParams
    ) -> Result<InitializeResult, Error> {
        if !self.is_started {
            return Err(
                Error::Protocol(
                    "Session not started. Call start() before making requests.".to_string()
                )
            );
        }

        tracing::info!("Sending initialize request");
        let result = self.client.initialize(params).await?;
        self.server_info = Some(result.clone());
        tracing::info!("Initialize request completed successfully");
        Ok(result)
    }

    /// Get the current session information if initialized
    pub async fn session_info(&self) -> Option<InitializeResult> {
        let session_info = self.session_info.lock().await;
        session_info.clone()
    }

    /// Close the session, stopping the message loop and closing the transport
    pub async fn close(&mut self) -> Result<(), Error> {
        self.client.stop_message_loop().await?;
        self.client.close().await
    }

    /// Send a request to the server and await the response
    pub async fn send_request<P, R>(&self, method: &str, params: P) -> Result<R, Error>
        where P: Serialize + Send + Sync, R: DeserializeOwned + Send + Sync
    {
        self.client.send_request(method, params).await
    }

    /// Register a listener for notifications
    pub async fn register_notification_listener(&self) -> mpsc::Receiver<Notification> {
        self.client.register_notification_listener().await
    }

    //==== File Resource Methods ====

    /// Create a file resource from a local path
    pub async fn create_file_resource(
        &self,
        name: &str,
        path: &std::path::Path,
        description: Option<String>,
        mime_type: Option<String>
    ) -> Result<CreateResourceResult, Error> {
        // Create a FileResource object
        let file_resource = FileResource::new(
            None,
            name.to_string(),
            path,
            description,
            mime_type,
            false // Not binary
        ).map_err(|e| Error::Resource(format!("Failed to create file resource: {}", e)))?;

        // Convert to params and create on the server
        let params = file_resource
            .to_create_params()
            .map_err(|e| Error::Resource(format!("Failed to read file: {}", e)))?;

        self.client.create_resource(params).await
    }

    /// Create a binary file resource from a local path
    pub async fn create_binary_file_resource(
        &self,
        name: &str,
        path: &std::path::Path,
        description: Option<String>,
        mime_type: Option<String>
    ) -> Result<CreateResourceResult, Error> {
        // Create a FileResource object
        let file_resource = FileResource::new(
            None,
            name.to_string(),
            path,
            description,
            mime_type,
            true // Binary
        ).map_err(|e| Error::Resource(format!("Failed to create file resource: {}", e)))?;

        // Convert to params and create on the server
        let params = file_resource
            .to_create_params()
            .map_err(|e| Error::Resource(format!("Failed to read file: {}", e)))?;

        self.client.create_resource(params).await
    }

    //==== Tools and Notifications Methods ====

    /// Call a tool with the given parameters
    pub async fn call_tool(&self, params: CallToolParams) -> Result<CallToolResult, Error> {
        self.client.call_tool(params).await
    }

    /// Send a progress notification to the server
    pub async fn send_progress_notification(
        &self,
        tool_name: &str,
        progress: f64,
        message: Option<String>
    ) -> Result<(), Error> {
        // Create the notification message
        let notification = Notification {
            jsonrpc: "2.0".to_string(),
            method: "tools/progress".to_string(),
            params: Some(
                serde_json::json!({
                "tool_name": tool_name,
                "progress": progress,
                "message": message
            })
            ),
        };

        // Send the notification
        let mut transport = self.client.transport.lock().await;
        transport.send(&McpMessage::Notification(notification)).await
    }

    //==== Message Creation Methods ====

    /// Create a message for sampling
    pub fn create_message(&self, role: Role, content: Vec<ContentPart>) -> Message {
        Message { role, content }
    }

    /// Create a text content part
    pub fn create_text_content(&self, text: &str) -> ContentPart {
        ContentPart::Text(text.to_string())
    }

    /// Create an image content part from a resource URI
    pub fn create_image_content(&self, uri: &str) -> ContentPart {
        ContentPart::Image {
            uri: uri.to_string(),
        }
    }

    //==== Standard MCP Operations ====

    /// List available resources
    pub async fn list_resources(
        &self,
        params: ListResourcesParams
    ) -> Result<ListResourcesResult, Error> {
        self.client.list_resources(params).await
    }

    /// Get a specific resource
    pub async fn get_resource(
        &self,
        params: GetResourceParams
    ) -> Result<GetResourceResult, Error> {
        self.client.get_resource(params).await
    }

    /// Create a new resource
    pub async fn create_resource(
        &self,
        params: CreateResourceParams
    ) -> Result<CreateResourceResult, Error> {
        self.client.create_resource(params).await
    }

    /// Update an existing resource
    pub async fn update_resource(
        &self,
        params: UpdateResourceParams
    ) -> Result<UpdateResourceResult, Error> {
        self.client.update_resource(params).await
    }

    /// Delete a resource
    pub async fn delete_resource(
        &self,
        params: DeleteResourceParams
    ) -> Result<DeleteResourceResult, Error> {
        self.client.delete_resource(params).await
    }

    /// List available prompts
    pub async fn list_prompts(
        &self,
        params: ListPromptsParams
    ) -> Result<ListPromptsResult, Error> {
        self.client.list_prompts(params).await
    }

    /// Create a new prompt
    pub async fn create_prompt(
        &self,
        params: CreatePromptParams
    ) -> Result<CreatePromptResult, Error> {
        self.client.create_prompt(params).await
    }

    /// Update an existing prompt
    pub async fn update_prompt(
        &self,
        params: UpdatePromptParams
    ) -> Result<UpdatePromptResult, Error> {
        self.client.update_prompt(params).await
    }

    /// Delete a prompt
    pub async fn delete_prompt(
        &self,
        params: DeletePromptParams
    ) -> Result<DeletePromptResult, Error> {
        self.client.delete_prompt(params).await
    }

    /// Render a prompt with the given arguments
    pub async fn render_prompt(
        &self,
        params: RenderPromptParams
    ) -> Result<RenderPromptResult, Error> {
        self.client.render_prompt(params).await
    }

    /// List available tools
    pub async fn list_tools(&self, params: ListToolsParams) -> Result<ListToolsResult, Error> {
        self.client.list_tools(params).await
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::errors::error_codes;
    use crate::messages::error_response;
    use crate::transport::TransportLifecycleEvent;
    use async_trait::async_trait;
    use std::sync::atomic::{ AtomicBool, Ordering };

    struct MockTransport {
        connected: Arc<AtomicBool>,
        response: Option<McpMessage>,
    }

    impl MockTransport {
        fn new(response: Option<McpMessage>) -> Self {
            Self {
                connected: Arc::new(AtomicBool::new(true)),
                response,
            }
        }
    }

    #[async_trait]
    impl Transport for MockTransport {
        async fn receive(&mut self) -> Result<(Option<String>, McpMessage), Error> {
            if let Some(response) = self.response.take() {
                return Ok((None, response));
            }
            Err(Error::Transport("No more messages".to_string()))
        }

        async fn send(&mut self, _message: &McpMessage) -> Result<(), Error> {
            Ok(())
        }

        async fn send_to(&mut self, _client_id: &str, message: &McpMessage) -> Result<(), Error> {
            // For client transports, send_to is the same as send
            self.send(message).await
        }

        async fn is_connected(&self) -> bool {
            self.connected.load(Ordering::SeqCst)
        }

        async fn close(&mut self) -> Result<(), Error> {
            self.connected.store(false, Ordering::SeqCst);
            Ok(())
        }

        fn register_lifecycle_handler(
            &mut self,
            _handler: Box<dyn Fn(TransportLifecycleEvent) + Send + Sync>
        ) {
            // For mock transport, we can simply ignore the handler
            // or store it if needed for testing
        }
    }

    #[tokio::test]
    async fn test_send_request_success() {
        let response = McpMessage::Response(Response {
            jsonrpc: "2.0".to_string(),
            id: 1,
            outcome: ResponseOutcome::Success {
                result: serde_json::json!({"protocol_version": "1.0"}),
            },
        });

        let transport = MockTransport::new(Some(response));
        let client = Client::new(transport);

        let result: InitializeResult = client
            .send_request("initialize", InitializeRequestParams {
                protocol_version: "1.0".to_string(),
                capabilities: crate::types::initialize::ClientCapabilities {
                    roots: None,
                    experimental: None,
                    sampling: None,
                },
                client_info: None,
            }).await
            .unwrap();

        assert_eq!(result.protocol_version, "1.0");
    }

    #[tokio::test]
    async fn test_send_request_error() {
        let response = McpMessage::Response(
            error_response(1, error_codes::METHOD_NOT_FOUND, "Method not found", None)
        );

        let transport = MockTransport::new(Some(response));
        let client = Client::new(transport);

        let result = client.send_request::<(), ()>("unknown_method", ()).await;

        assert!(result.is_err());
    }
}


<file_info>
path: examples/lifecycle_example.rs
name: lifecycle_example.rs
</file_info>
//! MCP Lifecycle Management Example
//!
//! This example demonstrates the MCP lifecycle management system, showing how
//! clients and servers transition through the different phases of the protocol.

use mcp_rs::lifecycle::*;
use mcp_rs::types::InitializeRequestParams;
use mcp_rs::{
    Error,
    client::ClientSession,
    server::Server,
    transport::{ sse::SseTransport, sse_server::{ SseServerOptions, SseServerTransport } },
    types::initialize::{ ClientCapabilities, Implementation, InitializeResult },
    utils::validation::ValidationConfig,
};

use std::net::SocketAddr;
use std::sync::{ Arc, Mutex };
use std::time::Duration;
use tokio::time::sleep;
use tracing::{ Level, debug, info };

/// Custom server context for lifecycle events
#[derive(Clone)]
struct ServerAppContext {
    startup_time: std::time::Instant,
    request_count: Arc<Mutex<u64>>,
    in_shutdown: Arc<Mutex<bool>>,
}

impl ServerAppContext {
    fn new() -> Self {
        Self {
            startup_time: std::time::Instant::now(),
            request_count: Arc::new(Mutex::new(0)),
            in_shutdown: Arc::new(Mutex::new(false)),
        }
    }

    fn increment_request_count(&self) {
        let mut count = self.request_count.lock().unwrap();
        *count += 1;
    }

    fn get_request_count(&self) -> u64 {
        let count = self.request_count.lock().unwrap();
        *count
    }
}

impl LifecycleContext for ServerAppContext {
    fn on_startup(&mut self) -> Result<(), Error> {
        info!("Server is starting up");
        Ok(())
    }

    fn on_initialized(
        &mut self,
        protocol_version: ProtocolVersion,
        capabilities: &NegotiatedCapabilities
    ) -> Result<(), Error> {
        info!("Server initialized with protocol version {}", protocol_version);
        info!("Negotiated capabilities: {:#?}", capabilities);
        Ok(())
    }

    fn before_request(&mut self, context: &RequestContext) -> Result<(), Error> {
        self.increment_request_count();
        debug!(
            "Processing request {} ({}): {}",
            self.get_request_count(),
            context.request_id,
            context.method
        );
        Ok(())
    }

    fn after_request<T>(
        &mut self,
        context: &RequestContext,
        result: &Result<T, Error>
    ) -> Result<(), Error> {
        match result {
            Ok(_) => debug!("Request {} completed successfully", context.request_id),
            Err(e) => debug!("Request {} failed: {}", context.request_id, e),
        }
        Ok(())
    }

    fn on_shutdown(&mut self) -> Result<(), Error> {
        let mut shutdown = self.in_shutdown.lock().unwrap();
        *shutdown = true;
        info!(
            "Server is shutting down after {} seconds of operation",
            self.startup_time.elapsed().as_secs()
        );
        info!("Processed {} requests", self.get_request_count());
        Ok(())
    }
}

/// Custom client context for lifecycle events
#[derive(Clone)]
struct ClientAppContext {
    startup_time: std::time::Instant,
    connected: Arc<Mutex<bool>>,
}

impl ClientAppContext {
    fn new() -> Self {
        Self {
            startup_time: std::time::Instant::now(),
            connected: Arc::new(Mutex::new(false)),
        }
    }

    fn set_connected(&self, connected: bool) {
        let mut conn = self.connected.lock().unwrap();
        *conn = connected;
    }
}

impl LifecycleContext for ClientAppContext {
    fn on_startup(&mut self) -> Result<(), Error> {
        info!("Client is starting up");
        Ok(())
    }

    fn on_initialized(
        &mut self,
        protocol_version: ProtocolVersion,
        capabilities: &NegotiatedCapabilities
    ) -> Result<(), Error> {
        self.set_connected(true);
        info!("Client initialized with protocol version {}", protocol_version);
        info!("Negotiated capabilities: {:#?}", capabilities);
        Ok(())
    }

    fn before_request(&mut self, _context: &RequestContext) -> Result<(), Error> {
        Ok(())
    }

    fn after_request<T>(
        &mut self,
        _context: &RequestContext,
        _result: &Result<T, Error>
    ) -> Result<(), Error> {
        Ok(())
    }

    fn on_shutdown(&mut self) -> Result<(), Error> {
        self.set_connected(false);
        info!(
            "Client is shutting down after {} seconds of operation",
            self.startup_time.elapsed().as_secs()
        );
        Ok(())
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    // Set up logging
    tracing_subscriber::fmt().with_max_level(Level::DEBUG).init();

    info!("Starting MCP Lifecycle Example");

    // Start server in a separate task
    let server_handle = tokio::spawn(run_server());

    // Wait for server to start
    sleep(Duration::from_millis(500)).await;

    // Start client
    let client_result = run_client().await;

    // Wait for server to process client shutdown
    sleep(Duration::from_millis(500)).await;

    // Request server shutdown
    let server_result = server_handle.await??;

    // Return client result
    client_result?;
    server_result?;

    info!("Example completed successfully");
    Ok(())
}

/// Run the MCP server with lifecycle management
async fn run_server() -> Result<Result<(), Error>, Box<dyn std::error::Error + Send + Sync>> {
    info!("Starting MCP server");

    // Create server context with lifecycle hooks
    let context = ServerAppContext::new();

    // Create lifecycle manager
    let lifecycle = LifecycleManager::new(context.clone())
        .with_init_timeout(Duration::from_secs(30))
        .with_shutdown_timeout(Duration::from_secs(10));

    // Start the lifecycle
    lifecycle.start().await?;

    // Create and configure the server
    let mut server = Server::new(context).with_validation_config(ValidationConfig {
        validate_requests: true,
        validate_responses: true,
    });

    // Configure SSE server options
    let bind_addr: SocketAddr = "127.0.0.1:8000".parse()?;
    let sse_options = SseServerOptions {
        bind_address: bind_addr,
        auth_token: None,
        connection_timeout: Duration::from_secs(30),
        keep_alive_interval: 30,
        allowed_origins: Some(vec!["*".to_string()]),
        require_auth: false,
    };

    // Create SSE transport
    let mut sse_transport = SseServerTransport::with_options(sse_options);

    // Register basic methods
    server.register_initialize_handler(|state, params| {
        let state = state.clone();
        Box::pin(async move {
            info!("Received initialize request from client");
            state.increment_request_count();

            // Return a proper initialize result
            Ok(InitializeResult {
                protocol_version: params.protocol_version,
                server_info: Some(Implementation {
                    name: "MCP Lifecycle Example Server".to_string(),
                    version: Some(env!("CARGO_PKG_VERSION").to_string()),
                }),
                capabilities: mcp_rs::types::initialize::ServerCapabilities {
                    logging: Some(mcp_rs::types::initialize::LoggingCapabilities {}),
                    resources: Some(mcp_rs::types::initialize::ResourceCapabilities {
                        list_changed: true,
                        subscribe: true,
                    }),
                    tools: Some(mcp_rs::types::initialize::ToolCapabilities {
                        list_changed: true,
                    }),
                    prompts: Some(mcp_rs::types::initialize::PromptCapabilities {
                        list_changed: true,
                    }),
                    experimental: None,
                },
                instructions: Some("This is an example MCP lifecycle server".to_string()),
            })
        })
    });

    // Start the SSE transport
    sse_transport.start(None).await?;

    info!("SSE server started on {}", bind_addr);
    info!("SSE endpoint: http://{}/sse", bind_addr);
    info!("Messages endpoint: http://{}/messages/", bind_addr);

    // Run the server with the SSE transport (this will block until the server is shut down)
    let result = server.run(sse_transport).await;

    // Log and return the result
    match &result {
        Ok(_) => info!("Server shut down gracefully"),
        Err(e) => info!("Server shut down with error: {}", e),
    }

    Ok(result)
}

/// Run the MCP client with lifecycle management
async fn run_client() -> Result<(), Error> {
    info!("Starting MCP client");

    // Create client context with lifecycle hooks
    let context = ClientAppContext::new();

    // Create SSE transport for the client
    let server_url = "http://127.0.0.1:8000";
    let transport = SseTransport::new(server_url).await?;
    info!("Connected to SSE endpoint: {}/sse", server_url);

    // Create client session
    let mut session = ClientSession::new(transport).with_validation_config(ValidationConfig {
        validate_requests: true,
        validate_responses: true,
    });

    // Start the session (this connects to the server)
    session.start().await?;
    info!("Client session started");

    // Initialize the connection (this transitions through the protocol initialization phase)
    info!("Initializing connection to server...");
    let init_result = session.initialize(InitializeRequestParams {
        protocol_version: "2024-11-05".to_string(),
        client_info: Some(Implementation {
            name: "MCP Lifecycle Example Client".to_string(),
            version: Some(env!("CARGO_PKG_VERSION").to_string()),
        }),
        capabilities: ClientCapabilities {
            roots: None,
            sampling: None,
            experimental: None,
        },
    }).await?;

    // Log initialization result
    info!(
        "Connected to server: {}",
        init_result.server_info
            .map(|info| info.name)
            .unwrap_or_else(|| "Unknown Server".to_string())
    );
    if let Some(instructions) = init_result.instructions {
        info!("Server instructions: {}", instructions);
    }
    info!("Server capabilities: {:?}", init_result.capabilities);

    // Simulate some client activity
    info!("Client is now in the operational phase");
    for i in 1..=3 {
        info!("Simulating client activity {}/3", i);
        sleep(Duration::from_secs(1)).await;
    }

    // Close the client session (this transitions to the shutdown phase)
    info!("Closing client session...");
    session.close().await?;
    info!("Client session closed");

    Ok(())
}


<file_info>
path: src/server.rs
name: server.rs
</file_info>
//! MCP Server
//!
//! This module implements the MCP server, managing state, handler registration, and
//! request processing. It provides a flexible and type-safe way to define and register
//! handlers for different MCP methods, ensuring that requests are processed correctly.

use async_trait::async_trait;
use futures::future::BoxFuture;
use serde_json::json;
use std::collections::HashMap;
use std::sync::Arc;

use crate::errors::Error;
use crate::lifecycle::LifecycleManager;
use crate::lifecycle_context::ServerContext;
use crate::messages::{ GenericRequest, Message, Notification, Response, ResponseOutcome };
use crate::tools::process_manager::ToolOutputType;
use crate::tools::progress::ToolProgressTracker;
use crate::tools::tool_registry::ToolRegistry;
use crate::transport::Transport;
use crate::types::initialize::{
    Implementation,
    InitializeRequestParams,
    InitializeResult,
    ServerCapabilities,
};
use crate::types::tools::CallToolResult;
use crate::types::CallToolParams;
use crate::utils::validation::{ ValidationConfig, validate_request };
use serde::{ Serialize, de::DeserializeOwned };
use serde_json::Value;

/// Handler trait for MCP method requests
#[async_trait]
pub trait MethodHandler<State>: Send + Sync {
    /// Handle a method request with the given state and parameters
    async fn handle(&self, state: &State, params: &Value) -> Result<Value, Error>;
}

/// Handler trait for MCP notifications
#[async_trait]
pub trait NotificationHandler<State>: Send + Sync {
    /// Handle a notification with the given state and parameters
    async fn handle(&self, state: &State, params: &Value) -> Result<(), Error>;
}

/// Type-safe wrapper for method handlers
struct TypedHandler<F, P, R> {
    handler: F,
    _marker: std::marker::PhantomData<(P, R)>,
}

impl<F, P, R> TypedHandler<F, P, R> {
    fn new(handler: F) -> Self {
        Self {
            handler,
            _marker: std::marker::PhantomData,
        }
    }
}

#[async_trait]
impl<State, F, P, R> MethodHandler<State>
    for TypedHandler<F, P, R>
    where
        State: Send + Sync,
        F: Fn(&State, P) -> BoxFuture<'static, Result<R, Error>> + Send + Sync,
        P: DeserializeOwned + Send + Sync + 'static,
        R: Serialize + Send + Sync + 'static
{
    async fn handle(&self, state: &State, params: &Value) -> Result<Value, Error> {
        let params: P = serde_json
            ::from_value(params.clone())
            .map_err(|e| Error::InvalidParams(e.to_string()))?;
        let result = (self.handler)(state, params).await?;
        serde_json::to_value(result).map_err(Error::Json)
    }
}

// /// Type-safe wrapper for notification handlers
// struct TypedNotificationHandler<F, P> {
//     handler: F,
//     _marker: std::marker::PhantomData<P>,
// }

// impl<F, P> TypedNotificationHandler<F, P> {
//     fn new(handler: F) -> Self {
//         Self {
//             handler,
//             _marker: std::marker::PhantomData,
//         }
//     }
// }

// #[async_trait]
// impl<State, F, P> NotificationHandler<State> for TypedNotificationHandler<F, P>
// where
//     State: Send + Sync,
//     F: Fn(&State, P) -> BoxFuture<'static, Result<(), Error>> + Send + Sync,
//     P: DeserializeOwned + Send + Sync + 'static,
// {
//     async fn handle(&self, state: &State, params: &Value) -> Result<(), Error> {
//         let params: P = serde_json::from_value(params.clone())
//             .map_err(|e| Error::InvalidParams(e.to_string()))?;
//         (self.handler)(state, params).await
//     }
// }

/// Server for the Model Context Protocol
pub struct Server<S> {
    /// Application state
    state: S,

    /// Method handlers
    handlers: HashMap<String, Box<dyn MethodHandler<S>>>,

    /// Server capabilities
    capabilities: ServerCapabilities,

    /// Server implementation info
    server_info: Implementation,

    /// Validation configuration
    validation_config: ValidationConfig,

    /// Tool registry for managing and executing tools
    pub tool_registry: Arc<ToolRegistry>,

    /// Progress tracker for tools
    progress_tracker: Arc<ToolProgressTracker>,

    /// Lifecycle manager for managing server state
    lifecycle_manager: LifecycleManager<ServerContext>,
}

impl<S> Server<S> where S: Clone + Send + Sync + 'static {
    /// Create a new server
    pub fn new(state: S) -> Self {
        // Create lifecycle manager with server context
        let lifecycle_manager = LifecycleManager::new(ServerContext::new());

        Self {
            state,
            handlers: HashMap::new(),
            capabilities: ServerCapabilities::default(),
            server_info: Implementation {
                name: "MCP-rs Server".to_string(),
                version: Some(env!("CARGO_PKG_VERSION").to_string()),
            },
            validation_config: ValidationConfig::default(),
            tool_registry: Arc::new(ToolRegistry::new()),
            progress_tracker: Arc::new(ToolProgressTracker::new()),
            lifecycle_manager,
        }
    }

    /// Configure validation settings
    pub fn with_validation_config(mut self, config: ValidationConfig) -> Self {
        self.validation_config = config;
        self
    }

    /// Enable/disable request validation
    pub fn validate_requests(mut self, validate: bool) -> Self {
        self.validation_config.validate_requests = validate;
        self
    }

    /// Enable/disable response validation
    pub fn validate_responses(mut self, validate: bool) -> Self {
        self.validation_config.validate_responses = validate;
        self
    }

    /// Register a method handler
    pub fn register_handler<P, R, F>(&mut self, method: &str, handler: F) -> &mut Self
        where
            P: DeserializeOwned + Send + Sync + 'static,
            R: Serialize + Send + Sync + 'static,
            F: Fn(&S, P) -> BoxFuture<'static, Result<R, Error>> + Send + Sync + 'static
    {
        let handler = Box::new(TypedHandler::new(handler));
        self.handlers.insert(method.to_string(), handler);
        self
    }

    /// Register initialize handler
    pub fn register_initialize_handler<F>(&mut self, handler: F) -> &mut Self
        where
            F: Fn(
                &S,
                InitializeRequestParams
            ) -> BoxFuture<'static, Result<InitializeResult, Error>> +
                Send +
                Sync +
                'static
    {
        self.register_handler("initialize", handler)
    }

    /// Run the server with a transport
    pub async fn run<T>(&self, mut transport: T) -> Result<(), Error>
        where T: Transport, S: Send + Sync + 'static
    {
        // Start the lifecycle manager
        self.lifecycle_manager.start().await?;
        tracing::info!("Server lifecycle started");

        // Server main loop
        loop {
            match transport.receive().await {
                Ok((client_id_opt, message)) => {
                    match message {
                        Message::Request(request) => {
                            // Use the client ID from transport if available, otherwise use "default"
                            let client_id = client_id_opt.unwrap_or_else(|| "default".to_string());

                            // Handle the request with the client ID
                            let result = self.handle_request_with_client_id(
                                &mut transport,
                                request,
                                client_id
                            ).await;
                            if let Err(e) = result {
                                tracing::error!("Error handling request: {}", e);
                            }
                        }
                        Message::Notification(notification) => {
                            // Handle notification
                            if let Err(e) = self.handle_notification(notification).await {
                                tracing::error!("Error handling notification: {}", e);
                            }
                        }
                        _ => {
                            tracing::warn!("Unexpected message type received");
                        }
                    }
                }
                Err(e) => {
                    tracing::error!("Transport error: {}", e);
                    break;
                }
            }
        }

        // Shutdown the lifecycle manager
        self.lifecycle_manager.shutdown().await?;

        Ok(())
    }

    /// Handle a request with client ID
    async fn handle_request_with_client_id<T>(
        &self,
        transport: &mut T,
        request: GenericRequest,
        client_id: String
    )
        -> Result<(), Error>
        where T: Transport, S: Send + Sync + 'static
    {
        // Check if the method can be handled in current state
        if !self.lifecycle_manager.can_handle_method(&request.method) {
            let response = Error::InvalidState(
                format!("Cannot handle method '{}' in current state", request.method)
            ).to_response_payload(request.id.unwrap_or(0));
            return transport.send_to(&client_id, &Message::Response(response)).await;
        }

        // Handle initialization specially
        if request.method == "initialize" {
            // Parse the initialize parameters
            let params = match &request.params {
                Some(params) => params.clone(),
                None => {
                    let response = Error::InvalidParams(
                        "Missing parameters for initialize".to_string()
                    ).to_response_payload(request.id.unwrap_or(0));
                    return transport.send_to(&client_id, &Message::Response(response)).await;
                }
            };

            // Use lifecycle manager to handle initialization
            match self.lifecycle_manager.handle_initialize(&request).await {
                Ok(result) => {
                    let response = Response {
                        jsonrpc: "2.0".to_string(),
                        id: request.id.unwrap_or(0),
                        outcome: ResponseOutcome::Success {
                            result: serde_json::to_value(result)?,
                        },
                    };
                    return transport.send_to(&client_id, &Message::Response(response)).await;
                }
                Err(e) => {
                    let response = e.to_response_payload(request.id.unwrap_or(0));
                    return transport.send_to(&client_id, &Message::Response(response)).await;
                }
            }
        }

        // For regular requests, create context and execute
        if let Some(handler) = self.handlers.get(&request.method) {
            // Extract parameters and handle null properly
            let params = match &request.params {
                Some(p) => p.clone(),
                None => serde_json::json!({}), // Use empty object instead of null for methods like list_tools
            };

            // Validate request if enabled
            if self.validation_config.validate_requests {
                if let Err(e) = validate_request(&request, &self.validation_config) {
                    let response = e.to_response_payload(request.id.unwrap_or(0));
                    return transport.send_to(&client_id, &Message::Response(response)).await;
                }
            }

            // Create request context
            let req_ctx = self.lifecycle_manager.create_request_context(
                request.id.unwrap_or(0),
                &request.method,
                Some(&client_id)
            )?;

            // Call the handler with proper lifecycle context
            let result = handler.handle(&self.state, &params).await;

            match result {
                Ok(result) => {
                    let response = Response {
                        jsonrpc: "2.0".to_string(),
                        id: request.id.unwrap_or(0),
                        outcome: ResponseOutcome::Success { result },
                    };
                    return transport.send_to(&client_id, &Message::Response(response)).await;
                }
                Err(e) => {
                    let response = e.to_response_payload(request.id.unwrap_or(0));
                    return transport.send_to(&client_id, &Message::Response(response)).await;
                }
            }
        } else {
            // Method not found
            let response = Error::MethodNotFound(
                format!("Method not found: {}", request.method)
            ).to_response_payload(request.id.unwrap_or(0));
            return transport.send_to(&client_id, &Message::Response(response)).await;
        }
    }

    /// Handle a notification
    async fn handle_notification(&self, notification: Notification) -> Result<(), Error>
        where S: Send + Sync + 'static
    {
        // Handle notifications
        match notification.method.as_str() {
            "notifications/initialized" => {
                // Use lifecycle manager to handle initialized notification
                self.lifecycle_manager.handle_initialized().await?;
                tracing::info!("Received initialized notification, server is now ready");
                Ok(())
            }
            _ => {
                // Other notifications
                tracing::debug!("Received notification: {}", notification.method);
                Ok(())
            }
        }
    }

    /// Handle a request without client ID
    async fn handle_request<T>(
        &self,
        transport: &mut T,
        request: GenericRequest
    )
        -> Result<(), Error>
        where T: Transport, S: Send + Sync + 'static
    {
        // For non-client specific requests, use a default client ID
        self.handle_request_with_client_id(transport, request, "default".to_string()).await
    }

    /// Gracefully shutdown the server
    pub async fn shutdown(&self) -> Result<(), Error> {
        tracing::info!("Initiating server shutdown");
        self.lifecycle_manager.shutdown().await?;
        tracing::info!("Server shutdown complete");
        Ok(())
    }
}

// Helper function to parse progress updates from tool output
fn parse_progress_update(output: &str) -> Option<f64> {
    // Look for lines like "PROGRESS: 0.5" or "PROGRESS 50%"
    if let Some(progress_str) = output.strip_prefix("PROGRESS:") {
        let progress_str = progress_str.trim();
        if let Ok(progress) = progress_str.parse::<f64>() {
            return Some(progress.clamp(0.0, 1.0));
        }

        if let Some(percent_str) = progress_str.strip_suffix('%') {
            if let Ok(percent) = percent_str.trim().parse::<f64>() {
                return Some((percent / 100.0).clamp(0.0, 1.0));
            }
        }
    }
    None
}

/// Utility function to create a BoxFuture from a Result
pub fn box_future<T, E>(result: Result<T, E>) -> BoxFuture<'static, Result<T, E>>
    where T: Send + 'static, E: Send + 'static
{
    Box::pin(async move { result })
}


<file_info>
path: src/tools/message_parser.rs
name: message_parser.rs
</file_info>
// src/tools/message_parser.rs
//! Message Parser for Tool Communication
//!
//! This module provides a buffered message parser for reading structured messages
//! from tool processes, handling partial reads and message boundaries correctly.

use std::io::Error as IoError;
use tokio::io::{ AsyncBufReadExt, BufReader };

/// A parser for reading line-delimited messages from an async reader
pub struct MessageParser<R> {
    /// The buffered reader
    reader: BufReader<R>,
    /// Internal buffer for partial messages
    buffer: String,
}

impl<R: tokio::io::AsyncRead + Unpin> MessageParser<R> {
    /// Create a new message parser for the given reader
    pub fn new(reader: R) -> Self {
        Self {
            reader: BufReader::new(reader),
            buffer: String::new(),
        }
    }

    /// Read the next complete message, waiting for a newline delimiter
    pub async fn next_message(&mut self) -> Result<Option<String>, IoError> {
        loop {
            // Check if we have a complete message in the buffer
            if let Some(pos) = self.buffer.find('\n') {
                let message = self.buffer[..pos].to_string();
                self.buffer = self.buffer[pos + 1..].to_string();
                return Ok(Some(message));
            }

            // Read more data
            let bytes_read = self.reader.read_line(&mut self.buffer).await?;
            if bytes_read == 0 {
                // EOF
                if self.buffer.is_empty() {
                    return Ok(None);
                } else {
                    // Return remaining data as a message
                    let message = std::mem::take(&mut self.buffer);
                    return Ok(Some(message));
                }
            }
        }
    }

    /// Read multiple messages until EOF or the provided limit is reached
    pub async fn read_messages(&mut self, limit: Option<usize>) -> Result<Vec<String>, IoError> {
        let mut messages = Vec::new();
        let limit = limit.unwrap_or(usize::MAX);

        while messages.len() < limit {
            match self.next_message().await? {
                Some(message) => messages.push(message),
                None => {
                    break;
                }
            }
        }

        Ok(messages)
    }

    /// Read all available messages without waiting
    pub async fn read_available(&mut self) -> Result<Vec<String>, IoError> {
        let mut messages = Vec::new();

        // First check the buffer for any complete messages
        while let Some(pos) = self.buffer.find('\n') {
            let message = self.buffer[..pos].to_string();
            self.buffer = self.buffer[pos + 1..].to_string();
            messages.push(message);
        }

        // Then try to read more without blocking
        match
            tokio::time::timeout(std::time::Duration::from_millis(1), self.reader.fill_buf()).await
        {
            Ok(Ok(buf)) => {
                if !buf.is_empty() {
                    // More data available, process it
                    let mut read_messages = self.read_messages(None).await?;
                    messages.append(&mut read_messages);
                }
            }
            _ => (), // Timeout or error, just return what we have
        }

        Ok(messages)
    }
}


<file_info>
path: src/lifecycle_context.rs
name: lifecycle_context.rs
</file_info>
use crate::errors::Error;
use crate::lifecycle::{LifecycleContext, NegotiatedCapabilities, ProtocolVersion, RequestContext};
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use std::time::Instant;

/// Server-specific lifecycle context
#[derive(Clone)]
pub struct ServerContext {
    /// Server start time
    start_time: Instant,
    /// Request count
    request_count: Arc<Mutex<u64>>,
    /// Connected clients
    connected_clients: Arc<Mutex<HashMap<String, String>>>,
    /// Whether the server is initialized
    initialized: Arc<Mutex<bool>>,
}

impl ServerContext {
    /// Create a new server context
    pub fn new() -> Self {
        Self {
            start_time: Instant::now(),
            request_count: Arc::new(Mutex::new(0)),
            connected_clients: Arc::new(Mutex::new(HashMap::new())),
            initialized: Arc::new(Mutex::new(false)),
        }
    }

    /// Get the uptime of the server
    pub fn uptime(&self) -> std::time::Duration {
        self.start_time.elapsed()
    }

    /// Get the number of requests processed
    pub fn request_count(&self) -> u64 {
        *self.request_count.lock().unwrap()
    }

    /// Register a connected client
    pub fn register_client(&self, client_id: &str, info: &str) {
        let mut clients = self.connected_clients.lock().unwrap();
        clients.insert(client_id.to_string(), info.to_string());
    }

    /// Unregister a client
    pub fn unregister_client(&self, client_id: &str) {
        let mut clients = self.connected_clients.lock().unwrap();
        clients.remove(client_id);
    }

    /// Get connected client count
    pub fn connected_client_count(&self) -> usize {
        self.connected_clients.lock().unwrap().len()
    }
}

impl LifecycleContext for ServerContext {
    fn on_startup(&mut self) -> Result<(), Error> {
        tracing::info!("Server starting up");
        Ok(())
    }

    fn on_initialized(
        &mut self,
        protocol_version: ProtocolVersion,
        capabilities: &NegotiatedCapabilities,
    ) -> Result<(), Error> {
        tracing::info!(
            "Server initialized with protocol version {} and capabilities: {:?}",
            protocol_version,
            capabilities
        );

        let mut initialized = self.initialized.lock().unwrap();
        *initialized = true;

        Ok(())
    }

    fn before_request(&mut self, context: &RequestContext) -> Result<(), Error> {
        let mut count = self.request_count.lock().unwrap();
        *count += 1;

        tracing::debug!(
            "Processing request {} - method: {}",
            context.request_id,
            context.method
        );
        Ok(())
    }

    fn after_request<T>(
        &mut self,
        context: &RequestContext,
        result: &Result<T, Error>,
    ) -> Result<(), Error> {
        match result {
            Ok(_) => {
                tracing::debug!(
                    "Successfully processed request {} - method: {}",
                    context.request_id,
                    context.method
                );
            }
            Err(e) => {
                tracing::error!(
                    "Error processing request {} - method: {}, error: {}",
                    context.request_id,
                    context.method,
                    e
                );
            }
        }
        Ok(())
    }

    fn on_shutdown(&mut self) -> Result<(), Error> {
        tracing::info!(
            "Server shutting down after {} requests",
            self.request_count()
        );
        Ok(())
    }
}

/// Client-specific lifecycle context
#[derive(Clone)]
pub struct ClientContext {
    /// Client start time
    start_time: Instant,
    /// Whether the client is connected
    connected: Arc<Mutex<bool>>,
    /// Whether the client is initialized
    initialized: Arc<Mutex<bool>>,
    /// Server info received during initialization
    server_info: Arc<Mutex<Option<String>>>,
}

impl ClientContext {
    /// Create a new client context
    pub fn new() -> Self {
        Self {
            start_time: Instant::now(),
            connected: Arc::new(Mutex::new(false)),
            initialized: Arc::new(Mutex::new(false)),
            server_info: Arc::new(Mutex::new(None)),
        }
    }

    /// Get the uptime of the client
    pub fn uptime(&self) -> std::time::Duration {
        self.start_time.elapsed()
    }

    /// Check if the client is connected
    pub fn is_connected(&self) -> bool {
        *self.connected.lock().unwrap()
    }

    /// Set the connected state
    pub fn set_connected(&self, connected: bool) {
        let mut state = self.connected.lock().unwrap();
        *state = connected;
    }

    /// Set the server info
    pub fn set_server_info(&self, info: String) {
        let mut server_info = self.server_info.lock().unwrap();
        *server_info = Some(info);
    }
}

impl LifecycleContext for ClientContext {
    fn on_startup(&mut self) -> Result<(), Error> {
        tracing::info!("Client starting up");
        Ok(())
    }

    fn on_initialized(
        &mut self,
        protocol_version: ProtocolVersion,
        capabilities: &NegotiatedCapabilities,
    ) -> Result<(), Error> {
        tracing::info!(
            "Client initialized with protocol version {} and capabilities: {:?}",
            protocol_version,
            capabilities
        );

        let mut initialized = self.initialized.lock().unwrap();
        *initialized = true;

        Ok(())
    }

    fn before_request(&mut self, context: &RequestContext) -> Result<(), Error> {
        tracing::debug!(
            "Sending request {} - method: {}",
            context.request_id,
            context.method
        );
        Ok(())
    }

    fn after_request<T>(
        &mut self,
        context: &RequestContext,
        result: &Result<T, Error>,
    ) -> Result<(), Error> {
        match result {
            Ok(_) => {
                tracing::debug!(
                    "Successfully received response for request {} - method: {}",
                    context.request_id,
                    context.method
                );
            }
            Err(e) => {
                tracing::error!(
                    "Error in response for request {} - method: {}, error: {}",
                    context.request_id,
                    context.method,
                    e
                );
            }
        }
        Ok(())
    }

    fn on_shutdown(&mut self) -> Result<(), Error> {
        tracing::info!("Client shutting down");
        Ok(())
    }
}


<file_info>
path: src/messages.rs
name: messages.rs
</file_info>
//! MCP Message Types
//!
//! This module defines the core message structures for the MCP protocol, including
//! requests, responses, and notifications. It leverages Serde for JSON serialization
//! and Schemars for JSON schema generation to ensure compliance with the MCP specification.

use crate::errors::Error;
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

// Import the types we need from our types module

/// The top-level Message enum for handling JSON-RPC 2.0 messages
#[derive(Serialize, Debug, Clone)]
#[serde(untagged)]
pub enum Message {
    Request(GenericRequest),
    Response(Response),
    Notification(Notification),
}

/// Generic request type for initial deserialization of requests
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct GenericRequest {
    /// JSON-RPC version, always "2.0"
    pub jsonrpc: String,
    /// Request ID, optional for notifications
    pub id: Option<i32>,
    /// Method name (e.g., "initialize")
    pub method: String,
    /// Generic parameters, to be parsed into specific types based on method
    pub params: Option<serde_json::Value>,
}

/// Typed request with specific parameter type
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Request<T> {
    /// JSON-RPC version, always "2.0"
    pub jsonrpc: String,
    /// Request ID, optional for notifications
    pub id: Option<i32>,
    /// Method name (e.g., "initialize")
    pub method: String,
    /// Typed parameters for the method
    pub params: T,
}

/// Response for a JSON-RPC request
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct Response {
    /// JSON-RPC version, always "2.0"
    pub jsonrpc: String,
    /// ID from the request
    pub id: i32,
    /// Either a result or an error
    #[serde(flatten)]
    pub outcome: ResponseOutcome,
}

/// Represents either a successful result or an error
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
#[serde(untagged)]
pub enum ResponseOutcome {
    /// Success case with a result
    Success { result: serde_json::Value },
    /// Error case with error details
    Error { error: ErrorData },
}

/// Error information for failed requests
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct ErrorData {
    /// Error code (e.g., -32600 for Invalid Request)
    pub code: i32,
    /// Human-readable error message
    pub message: String,
    /// Optional additional data
    pub data: Option<serde_json::Value>,
}

/// Notification is a request without an expected response
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct Notification {
    /// JSON-RPC version, always "2.0"
    pub jsonrpc: String,
    /// Method name (e.g., "textDocument/didOpen")
    pub method: String,
    /// Optional parameters for the notification
    pub params: Option<serde_json::Value>,
}

/// Enum for type-safe handling of client requests
#[derive(Debug, Clone)]
pub enum ClientRequest {
    /// Initialize request
    Initialize(Request<crate::types::initialize::InitializeRequestParams>),
    /// List resources request
    ListResources(Request<crate::types::resources::ListResourcesParams>),
    // Additional methods will be added as needed
}

impl ClientRequest {
    /// Convert a GenericRequest to a typed ClientRequest based on the method
    pub fn from_generic(req: GenericRequest) -> Result<Self, Box<dyn std::error::Error>> {
        match req.method.as_str() {
            "initialize" => {
                let params = serde_json::from_value(req.params.unwrap_or_default())?;
                Ok(ClientRequest::Initialize(Request {
                    jsonrpc: req.jsonrpc,
                    id: req.id,
                    method: req.method,
                    params,
                }))
            }
            "resources/list" => {
                let params = serde_json::from_value(req.params.unwrap_or_default())?;
                Ok(ClientRequest::ListResources(Request {
                    jsonrpc: req.jsonrpc,
                    id: req.id,
                    method: req.method,
                    params,
                }))
            }
            _ => Err(format!("Unknown method: {}", req.method).into()),
        }
    }
}

/// Enum for type-safe handling of server responses
#[derive(Debug, Clone)]
pub enum ClientResponse {
    /// Initialize response
    Initialize(crate::types::initialize::InitializeResult),
    /// List resources response
    ListResources(crate::types::resources::ListResourcesResult),
    // Additional responses will be added as needed
}

impl ClientResponse {
    /// Convert a ClientResponse to a JSON-RPC Response
    pub fn to_response(&self, id: i32) -> Response {
        let result = match self {
            ClientResponse::Initialize(init_result) => serde_json::to_value(init_result).unwrap(),
            ClientResponse::ListResources(list_result) => {
                serde_json::to_value(list_result).unwrap()
            }
        };

        Response {
            jsonrpc: "2.0".to_string(),
            id,
            outcome: ResponseOutcome::Success { result },
        }
    }
}

/// Create an error response with the given code, message, and optional data
pub fn error_response(
    id: i32,
    code: i32,
    message: &str,
    data: Option<serde_json::Value>,
) -> Response {
    Response {
        jsonrpc: "2.0".to_string(),
        id,
        outcome: ResponseOutcome::Error {
            error: ErrorData {
                code,
                message: message.to_string(),
                data,
            },
        },
    }
}

impl Message {
    /// Try to split a message that might contain client ID information
    ///
    /// This is intended for use with server-side transports (WebSocketServerTransport, SseServerTransport)
    /// where the transport might include the client ID with the message.
    ///
    /// Returns None if the message doesn't have client ID information
    pub fn try_split_with_client_id(&self) -> Option<(String, Result<Message, Error>)> {
        // This is a placeholder for transport-specific implementations
        // In a real implementation, transports would wrap their messages
        // with client ID information
        None
    }
}

// Add custom deserialization to correctly distinguish between requests and notifications
impl<'de> serde::de::Deserialize<'de> for Message {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        use serde::de::Error;

        // First deserialize to a generic Value
        let value = serde_json::Value::deserialize(deserializer)?;

        // Check for jsonrpc field - all messages must have this
        if !value.get("jsonrpc").is_some() {
            return Err(D::Error::custom("Missing jsonrpc field"));
        }

        // Check message type based on fields
        if value.get("result").is_some() || value.get("error").is_some() {
            // Has result or error - it's a response
            let response: Response = serde_json::from_value(value.clone())
                .map_err(|e| D::Error::custom(e.to_string()))?;
            return Ok(Message::Response(response));
        } else if value.get("id").is_some() {
            // Has ID - it's a request
            let request: GenericRequest = serde_json::from_value(value.clone())
                .map_err(|e| D::Error::custom(e.to_string()))?;
            return Ok(Message::Request(request));
        } else if value.get("method").is_some() {
            // Has method but no ID - it's a notification
            let notification: Notification = serde_json::from_value(value.clone())
                .map_err(|e| D::Error::custom(e.to_string()))?;
            return Ok(Message::Notification(notification));
        }

        Err(D::Error::custom("Invalid JSON-RPC message format"))
    }
}


<file_info>
path: src/transport/sse.rs
name: sse.rs
</file_info>
//! SSE Client Transport
//!
//! This module implements the client-side transport for the SSE (Server-Sent Events)
//! protocol. It allows an MCP client to connect to an SSE server and receive real-time
//! updates via a persistent HTTP connection.

use async_trait::async_trait;
use futures_util::stream::StreamExt;
use reqwest::{Client as HttpClient, ClientBuilder, header};
use std::collections::HashMap;
use std::sync::Arc;
use std::sync::atomic::AtomicBool;
use std::time::Duration;
use tokio::sync::{Mutex, mpsc, oneshot};
use url::Url;

use crate::errors::Error;
use crate::messages::Message;
use crate::transport::{Transport, TransportLifecycleEvent};

/// Default timeout for HTTP requests
const DEFAULT_TIMEOUT: Duration = Duration::from_secs(30);
/// Default retry delay for reconnecting
const DEFAULT_RETRY_DELAY: Duration = Duration::from_secs(2);
/// Maximum number of reconnect attempts
const MAX_RECONNECT_ATTEMPTS: usize = 5;
/// Buffer size for message channel
const CHANNEL_BUFFER_SIZE: usize = 100;

/// Options for the SSE client transport
#[derive(Clone, Debug)]
pub struct SseOptions {
    /// Authentication token
    pub auth_token: Option<String>,
    /// Request timeout
    pub timeout: Duration,
    /// Retry delay for reconnection
    pub retry_delay: Duration,
    /// Custom headers
    pub custom_headers: Option<header::HeaderMap>,
    /// Client ID (auto-generated if None)
    pub client_id: Option<String>,
}

impl Default for SseOptions {
    fn default() -> Self {
        Self {
            auth_token: None,
            timeout: DEFAULT_TIMEOUT,
            retry_delay: DEFAULT_RETRY_DELAY,
            custom_headers: None,
            client_id: None,
        }
    }
}

/// Client-side implementation of the SSE transport
pub struct SseTransport {
    /// Base URL for the SSE server
    base_url: String,
    /// URL for the SSE events endpoint
    events_url: String,
    /// URL for the messages endpoint
    messages_url: String,
    /// HTTP client
    http_client: HttpClient,
    /// Channel for incoming messages
    rx: mpsc::Receiver<Message>,
    /// Options for the transport
    options: SseOptions,
    /// Session ID (if assigned by server)
    session_id: Arc<Mutex<String>>,
    /// Whether the transport is connected
    connected: Arc<Mutex<bool>>,
    /// Whether the transport is ready to send/receive messages
    is_ready: Arc<AtomicBool>,
    /// Handle to the background task
    _task_handle: tokio::task::JoinHandle<()>,
    /// Lifecycle event handlers
    lifecycle_handlers: Arc<Mutex<Vec<Box<dyn Fn(TransportLifecycleEvent) + Send + Sync>>>>,
    /// Shutdown signal sender
    shutdown_tx: Option<oneshot::Sender<()>>,
}

impl SseTransport {
    /// Create a new SSE transport
    pub async fn new(base_url: &str) -> Result<Self, Error> {
        Self::with_options(base_url, SseOptions::default()).await
    }

    /// Create a new SSE transport with custom options
    pub async fn with_options(base_url: &str, options: SseOptions) -> Result<Self, Error> {
        // Verify the base URL is valid
        let base_url = match Url::parse(base_url) {
            Ok(url) => url,
            Err(e) => {
                return Err(Error::Transport(format!("Invalid base URL: {}", e)));
            }
        };

        // Create the endpoints
        let events_url = base_url
            .join("sse")
            .map_err(|e| Error::Transport(format!("Failed to create events URL: {}", e)))?
            .to_string();

        let messages_url = base_url
            .join("message")
            .map_err(|e| Error::Transport(format!("Failed to create messages URL: {}", e)))?
            .to_string();

        // Create the HTTP client with specified timeout
        let http_client = ClientBuilder::new()
            .timeout(options.timeout)
            .build()
            .map_err(|e| Error::Transport(format!("Failed to create HTTP client: {}", e)))?;

        // Create a channel for incoming messages
        let (tx, rx) = mpsc::channel(100);

        // Create the session ID
        let session_id = Arc::new(Mutex::new(String::new()));

        // Create the connected flag
        let connected = Arc::new(Mutex::new(false));

        // Create the is_ready flag
        let is_ready = Arc::new(AtomicBool::new(false));

        // Create the lifecycle handlers
        let lifecycle_handlers = Arc::new(Mutex::new(Vec::new()));

        // Create a shutdown signal
        let (shutdown_tx, shutdown_rx) = oneshot::channel::<()>();

        // Clone values for the task
        let events_url_clone = events_url.clone();
        let tx_clone = tx.clone();
        let session_id_clone = session_id.clone();
        let connected_clone = connected.clone();
        let is_ready_clone = is_ready.clone();
        let http_client_clone = http_client.clone();
        let lifecycle_handlers_clone = lifecycle_handlers.clone();
        let messages_url_clone = messages_url.clone();

        // Spawn a task to handle the SSE connection
        let task_handle = tokio::spawn(async move {
            // Create a task-local shutdown signal
            let mut shutdown_rx = shutdown_rx;

            // Enter the connection loop
            loop {
                // Check if we should shut down
                if shutdown_rx.try_recv().is_ok() {
                    tracing::info!("Received shutdown signal, closing SSE connection");
                    break;
                }

                // Try to connect to the SSE endpoint
                match Self::connect_to_sse(
                    http_client_clone.clone(),
                    events_url_clone.clone(),
                    tx_clone.clone(),
                    session_id_clone.clone(),
                    connected_clone.clone(),
                    is_ready_clone.clone(),
                    messages_url_clone.clone(),
                    lifecycle_handlers_clone.clone(),
                )
                .await
                {
                    Ok(_) => {
                        tracing::info!("SSE connection ended normally");
                        break;
                    }
                    Err(e) => {
                        tracing::error!("SSE connection error: {}", e);
                        // Short delay before retry
                        tokio::time::sleep(std::time::Duration::from_secs(2)).await;
                    }
                }
            }

            // Ensure we mark as disconnected
            {
                let mut connected_guard = connected_clone.lock().await;
                *connected_guard = false;
            }

            // Mark is_ready as false since we're no longer connected
            is_ready_clone.store(false, std::sync::atomic::Ordering::Release);
            tracing::info!("SSE connection task ending");

            // Notify final closed state
            Self::notify_lifecycle_event(
                &lifecycle_handlers_clone,
                TransportLifecycleEvent::Closed,
            )
            .await;
        });

        Ok(Self {
            base_url: base_url.to_string(),
            events_url,
            messages_url,
            http_client,
            rx,
            options,
            session_id,
            connected,
            is_ready,
            _task_handle: task_handle,
            lifecycle_handlers,
            shutdown_tx: Some(shutdown_tx),
        })
    }

    /// Helper function to notify all lifecycle handlers of an event
    async fn notify_lifecycle_event(
        handlers: &Arc<Mutex<Vec<Box<dyn Fn(TransportLifecycleEvent) + Send + Sync>>>>,
        event: TransportLifecycleEvent,
    ) {
        let handlers_guard = handlers.lock().await;
        for handler in handlers_guard.iter() {
            handler(event.clone());
        }
    }

    /// Connect to the SSE endpoint and process messages
    async fn connect_to_sse(
        http_client: HttpClient,
        events_url: String,
        sender: mpsc::Sender<Message>,
        session_id: Arc<Mutex<String>>,
        connected: Arc<Mutex<bool>>,
        is_ready: Arc<AtomicBool>,
        messages_url: String,
        lifecycle_handlers: Arc<Mutex<Vec<Box<dyn Fn(TransportLifecycleEvent) + Send + Sync>>>>,
    ) -> Result<(), Error> {
        let mut retries = 0;
        let max_retries = 5;
        let mut retry_delay = std::time::Duration::from_millis(1000);

        // Store a clone of messages_url for later use
        let messages_url_clone = messages_url.clone();

        loop {
            tracing::info!("Connecting to SSE endpoint: {}", events_url);

            // Reset ready state on new connection attempt
            is_ready.store(false, std::sync::atomic::Ordering::Release);

            // Create a request with headers (no client ID - the server will assign one)
            let req = http_client
                .get(&events_url)
                .header("Accept", "text/event-stream")
                .header("Cache-Control", "no-cache")
                .header("Connection", "keep-alive")
                .build()
                .map_err(|e| Error::Transport(format!("Failed to build SSE request: {}", e)))?;

            // Send the request and check the response
            let response = match http_client.execute(req).await {
                Ok(resp) => {
                    if !resp.status().is_success() {
                        let status = resp.status();
                        let text = resp.text().await.unwrap_or_default();
                        let error =
                            format!("SSE connection failed with status {}: {}", status, text);
                        tracing::error!("{}", error);

                        // Increase retries and delay before next attempt
                        retries += 1;
                        if retries >= max_retries {
                            return Err(Error::Transport(error));
                        }

                        tracing::info!(
                            "Retrying SSE connection in {:?} (attempt {}/{})",
                            retry_delay,
                            retries,
                            max_retries
                        );
                        tokio::time::sleep(retry_delay).await;
                        retry_delay =
                            std::cmp::min(retry_delay * 2, std::time::Duration::from_secs(30));
                        continue;
                    }
                    resp
                }
                Err(e) => {
                    let error = format!("Failed to connect to SSE endpoint: {}", e);
                    tracing::error!("{}", error);

                    // Increase retries and delay before next attempt
                    retries += 1;
                    if retries >= max_retries {
                        return Err(Error::Transport(error));
                    }

                    tracing::info!(
                        "Retrying SSE connection in {:?} (attempt {}/{})",
                        retry_delay,
                        retries,
                        max_retries
                    );
                    tokio::time::sleep(retry_delay).await;
                    retry_delay =
                        std::cmp::min(retry_delay * 2, std::time::Duration::from_secs(30));
                    continue;
                }
            };

            // Update connected status
            *connected.lock().await = true;
            tracing::info!("Successfully connected to SSE endpoint!");

            // Set the transport as ready immediately - we no longer wait for endpoint event
            is_ready.store(true, std::sync::atomic::Ordering::Release);

            // Notify Started lifecycle event
            Self::notify_lifecycle_event(&lifecycle_handlers, TransportLifecycleEvent::Started)
                .await;

            // Process the response stream
            match Self::process_sse_stream(
                response,
                sender.clone(),
                session_id.clone(),
                is_ready.clone(),
            )
            .await
            {
                Ok(_) => {
                    tracing::info!("SSE stream processed successfully");
                    break; // Exit loop if stream ended gracefully
                }
                Err(e) => {
                    tracing::error!("Error processing SSE stream: {}", e);

                    // Update connected status
                    *connected.lock().await = false;

                    // Notify error
                    Self::notify_lifecycle_event(
                        &lifecycle_handlers,
                        TransportLifecycleEvent::Error,
                    )
                    .await;

                    // Increase retries and delay before next attempt
                    retries += 1;
                    if retries >= max_retries {
                        return Err(e);
                    }

                    tracing::info!(
                        "Retrying SSE connection in {:?} (attempt {}/{})",
                        retry_delay,
                        retries,
                        max_retries
                    );
                    tokio::time::sleep(retry_delay).await;
                    retry_delay =
                        std::cmp::min(retry_delay * 2, std::time::Duration::from_secs(30));
                }
            }
        }

        Ok(())
    }

    async fn process_sse_stream(
        response: reqwest::Response,
        sender: mpsc::Sender<Message>,
        session_id: Arc<Mutex<String>>,
        is_ready: Arc<AtomicBool>,
    ) -> Result<(), Error> {
        let mut stream = response.bytes_stream();
        let mut buffer = String::new();
        let mut event_type = String::new();
        let mut event_data = String::new();

        tracing::debug!("Starting to process SSE stream");

        while let Some(chunk_result) = stream.next().await {
            match chunk_result {
                Ok(chunk) => {
                    // Convert bytes to string and append to buffer
                    let chunk_str = std::str::from_utf8(&chunk).map_err(|e| {
                        Error::Transport(format!("Invalid UTF-8 in SSE stream: {}", e))
                    })?;

                    buffer.push_str(chunk_str);

                    // Process complete lines in the buffer
                    let mut pos = 0;
                    while let Some(next_newline) = buffer[pos..].find('\n') {
                        let line_end = pos + next_newline;
                        let line = buffer[pos..line_end].trim();
                        pos = line_end + 1;

                        tracing::debug!("Received SSE line: {}", line);

                        if line.is_empty() {
                            // Empty line marks the end of an event
                            if !event_type.is_empty() && !event_data.is_empty() {
                                // Process the complete event - only for message events
                                if event_type == "message" {
                                    Self::process_message_event(&event_data, &sender).await?;
                                } else if event_type == "error" {
                                    tracing::error!("Received error event: {}", event_data);
                                }

                                // Reset event state
                                event_type.clear();
                                event_data.clear();
                            }
                        } else if let Some(data) = line.strip_prefix("data:") {
                            // Append to event data
                            if !event_data.is_empty() {
                                event_data.push('\n');
                            }
                            event_data.push_str(data.trim());
                        } else if let Some(event) = line.strip_prefix("event:") {
                            // Set event type
                            event_type = event.trim().to_string();
                        }
                    }

                    // Remove processed content from buffer
                    if pos < buffer.len() {
                        buffer = buffer[pos..].to_string();
                    } else {
                        buffer.clear();
                    }
                }
                Err(e) => {
                    return Err(Error::Transport(format!("Error reading SSE stream: {}", e)));
                }
            }
        }

        tracing::info!("SSE stream ended");
        Ok(())
    }

    async fn process_message_event(
        event_data: &str,
        sender: &mpsc::Sender<Message>,
    ) -> Result<(), Error> {
        tracing::debug!("Processing message event: {}", event_data);

        // Try to parse the message from JSON
        match serde_json::from_str::<Message>(event_data) {
            Ok(message) => {
                // Send the message to the receiver
                if let Err(e) = sender.send(message).await {
                    tracing::error!("Failed to send message to channel: {}", e);
                    return Err(Error::Transport("Failed to process message".to_string()));
                }
                Ok(())
            }
            Err(e) => {
                tracing::error!("Failed to parse message from event data: {}", e);
                Err(Error::Transport(format!("Invalid message format: {}", e)))
            }
        }
    }

    // Message filtering based on ID
    async fn handle_sse_event(
        event_type: &str,
        event_data: &str,
        sender: &mpsc::Sender<Message>,
        pending_requests: &Arc<Mutex<HashMap<u64, oneshot::Sender<Result<Message, Error>>>>>,
    ) -> Result<(), Error> {
        if event_type != "message" {
            return Ok(());
        }

        // Parse message
        let message: Message = serde_json::from_str(event_data)?;

        // If message is a response, check if we have a pending request for it
        if let Message::Response(response) = &message {
            // Convert i32 ID to u64 for HashMap lookup
            let id = response.id as u64;

            // Check if we have a pending request for this ID
            let mut pending = pending_requests.lock().await;
            if let Some(sender) = pending.remove(&id) {
                // Send response to the waiting call
                let _ = sender.send(Ok(message.clone()));
                return Ok(());
            }
        }

        // Otherwise, forward the message
        sender
            .send(message)
            .await
            .map_err(|e| Error::Transport(format!("Failed to forward message: {}", e)))?;

        Ok(())
    }
}

#[async_trait]
impl Transport for SseTransport {
    async fn receive(&mut self) -> Result<(Option<String>, Message), Error> {
        // Wait for the transport to be ready
        if !self.is_ready.load(std::sync::atomic::Ordering::Acquire) {
            return Err(Error::Transport("Transport not ready".to_string()));
        }

        // Receive a message from the channel
        match self.rx.recv().await {
            Some(msg) => Ok((None, msg)),
            None => Err(Error::Transport("Channel closed".to_string())),
        }
    }

    async fn send(&mut self, message: &Message) -> Result<(), Error> {
        self.send_to("", message).await
    }

    async fn send_to(&mut self, _client_id: &str, message: &Message) -> Result<(), Error> {
        // Wait for the transport to be ready
        if !self.is_ready.load(std::sync::atomic::Ordering::Acquire) {
            return Err(Error::Transport("Transport not ready".to_string()));
        }

        // Serialize the message to JSON
        let message_json = serde_json::to_string(message)
            .map_err(|e| Error::Transport(format!("Failed to serialize message: {}", e)))?;

        // Send the message to the server via HTTP POST
        let response = self
            .http_client
            .post(&self.messages_url)
            .header("Content-Type", "application/json")
            .body(message_json)
            .send()
            .await
            .map_err(|e| Error::Transport(format!("Failed to send message: {}", e)))?;

        // Check if the response is successful
        if !response.status().is_success() {
            let status = response.status();
            let text = response.text().await.unwrap_or_default();
            return Err(Error::Transport(format!(
                "Failed to send message, received status {}: {}",
                status, text
            )));
        }

        Ok(())
    }

    async fn is_connected(&self) -> bool {
        let connected = self.connected.lock().await;
        *connected
    }

    async fn close(&mut self) -> Result<(), Error> {
        // Check if already closed
        if !self.is_connected().await {
            return Ok(());
        }

        // Send the shutdown signal
        if let Some(tx) = self.shutdown_tx.take() {
            let _ = tx.send(());
        }

        // Wait for the task to finish
        tokio::time::sleep(std::time::Duration::from_millis(100)).await;

        Ok(())
    }

    fn register_lifecycle_handler(
        &mut self,
        handler: Box<dyn Fn(TransportLifecycleEvent) + Send + Sync>,
    ) {
        let mut handlers = self.lifecycle_handlers.blocking_lock();
        handlers.push(handler);
    }
}


<file_info>
path: src/transport/stdio.rs
name: stdio.rs
</file_info>
//! STDIO Transport
//!
//! This module implements the STDIO transport for the MCP library, enabling
//! communication via standard input and output streams. It is particularly useful
//! for local subprocess communication in CLI-based MCP servers.

use crate::errors::Error;
use crate::messages::Message;
use crate::transport::Transport;
use crate::transport::TransportLifecycleEvent;
use async_trait::async_trait;
use std::collections::HashMap;
use std::process::Stdio;
use std::time::Duration;
use tokio::io::{self, AsyncBufReadExt, AsyncWriteExt, BufReader, Stdin, Stdout};
use tokio::process;
use tokio::sync::mpsc;
use tracing;

/// Channels used for process communication
struct StdioChannels {
    /// Receiver for incoming messages
    message_rx: mpsc::Receiver<Result<Message, Error>>,
    /// Sender for outgoing messages
    outgoing_tx: mpsc::Sender<Message>,
    /// Task handle for reader
    reader_task: tokio::task::JoinHandle<()>,
    /// Task handle for writer
    writer_task: tokio::task::JoinHandle<()>,
}

/// A transport implementation that uses standard input and output
pub struct StdioTransport {
    /// Child process
    process: Option<process::Child>,

    /// Process command
    command: String,

    /// Process arguments
    args: Vec<String>,

    /// Process environment variables
    env: Option<HashMap<String, String>>,

    /// Process communication channels
    channels: Option<StdioChannels>,

    /// Is the transport connected
    connected: bool,

    /// Lifecycle event handlers
    lifecycle_handlers: Vec<Box<dyn Fn(TransportLifecycleEvent) + Send + Sync>>,

    /// Process exit timeout
    exit_timeout: Duration,

    /// Standard input for direct I/O mode
    stdin: Option<Stdin>,

    /// Standard output for direct I/O mode
    stdout: Option<Stdout>,

    /// Buffered reader for stdin
    reader: Option<BufReader<Stdin>>,
}

impl StdioTransport {
    /// Create a new STDIO transport
    pub fn new() -> Self {
        let stdin = io::stdin();
        let stdout = io::stdout();

        Self {
            process: None,
            command: String::new(),
            args: Vec::new(),
            env: None,
            channels: None,
            connected: true,
            lifecycle_handlers: Vec::new(),
            exit_timeout: Duration::from_secs(5),
            stdin: Some(stdin),
            stdout: Some(stdout),
            reader: Some(BufReader::new(io::stdin())),
        }
    }

    /// Start the process and establish communication channels
    async fn start_process(&mut self) -> Result<(), Error> {
        // Notify starting
        self.notify_lifecycle(TransportLifecycleEvent::Starting);

        let mut command = tokio::process::Command::new(&self.command);
        command.args(&self.args);

        // Set environment
        if let Some(env) = &self.env {
            for (key, value) in env {
                command.env(key, value);
            }
        }

        // Configure stdio
        command.stdin(Stdio::piped());
        command.stdout(Stdio::piped());
        command.stderr(Stdio::inherit());

        // Spawn process
        let mut child = command
            .spawn()
            .map_err(|e| Error::Transport(format!("Failed to spawn process: {}", e)))?;

        // Get stdio handles
        let stdin = child
            .stdin
            .take()
            .ok_or_else(|| Error::Transport("Failed to get stdin handle".to_string()))?;
        let stdout = child
            .stdout
            .take()
            .ok_or_else(|| Error::Transport("Failed to get stdout handle".to_string()))?;

        // Create channels
        let (message_tx, message_rx) = mpsc::channel(100);
        let (outgoing_tx, outgoing_rx) = mpsc::channel(100);

        // Start reader and writer tasks
        let reader_task = tokio::spawn(stdio_reader(stdout, message_tx.clone()));
        let writer_task = tokio::spawn(stdio_writer(stdin, outgoing_rx));

        // Store everything
        self.process = Some(child);
        self.channels = Some(StdioChannels {
            message_rx,
            outgoing_tx,
            reader_task,
            writer_task,
        });

        self.connected = true;

        // Notify started
        self.notify_lifecycle(TransportLifecycleEvent::Started);

        Ok(())
    }

    /// Send a lifecycle event notification
    fn notify_lifecycle(&self, event: TransportLifecycleEvent) {
        for handler in &self.lifecycle_handlers {
            handler(event.clone());
        }
    }
}

/// Process stdout from a child process and forward messages
async fn stdio_reader(
    stdout: process::ChildStdout,
    tx: mpsc::Sender<Result<Message, Error>>,
) -> () {
    let mut reader = BufReader::new(stdout);
    let mut line = String::new();

    loop {
        line.clear();
        match reader.read_line(&mut line).await {
            Ok(0) => {
                // EOF
                break;
            }
            Ok(_) => {
                // Parse the JSON message
                match serde_json::from_str::<Message>(&line) {
                    Ok(message) => {
                        if tx.send(Ok(message)).await.is_err() {
                            break;
                        }
                    }
                    Err(e) => {
                        if tx.send(Err(Error::Json(e))).await.is_err() {
                            break;
                        }
                    }
                }
            }
            Err(e) => {
                let _ = tx.send(Err(Error::Io(e))).await;
                break;
            }
        }
    }
}

/// Process outgoing messages and write to stdin
async fn stdio_writer(mut stdin: process::ChildStdin, mut rx: mpsc::Receiver<Message>) -> () {
    while let Some(message) = rx.recv().await {
        match serde_json::to_string(&message) {
            Ok(json) => {
                // Write the JSON followed by a newline
                if stdin.write_all(json.as_bytes()).await.is_err() {
                    break;
                }
                if stdin.write_all(b"\n").await.is_err() {
                    break;
                }
                if stdin.flush().await.is_err() {
                    break;
                }
            }
            Err(_) => {
                // Ignore serialization errors
                continue;
            }
        }
    }
}

#[async_trait]
impl Transport for StdioTransport {
    async fn receive(&mut self) -> Result<(Option<String>, Message), Error> {
        if !self.connected {
            return Err(Error::Transport("Transport is not connected".to_string()));
        }

        let mut line = String::new();

        if let Some(reader) = &mut self.reader {
            match reader.read_line(&mut line).await {
                Ok(0) => {
                    // EOF
                    self.connected = false;
                    Err(Error::Transport("EOF reached".to_string()))
                }
                Ok(_) => {
                    // Parse the JSON message
                    serde_json::from_str(&line)
                        .map_err(Error::Json)
                        .map(|msg| (None, msg)) // StdioTransport has no client ID concept
                }
                Err(e) => {
                    self.connected = false;
                    Err(Error::Io(e))
                }
            }
        } else if let Some(channels) = &mut self.channels {
            match channels.message_rx.recv().await {
                Some(result) => result.map(|msg| (None, msg)), // StdioTransport has no client ID concept
                None => {
                    self.connected = false;
                    Err(Error::Transport("Channel closed".to_string()))
                }
            }
        } else {
            Err(Error::Transport(
                "Transport is not properly initialized".to_string(),
            ))
        }
    }

    async fn send(&mut self, message: &Message) -> Result<(), Error> {
        if !self.connected {
            return Err(Error::Transport("Transport is not connected".to_string()));
        }

        // Serialize the message to JSON
        let json = serde_json::to_string(message).map_err(Error::Json)?;

        if let Some(channels) = &mut self.channels {
            // Send through process channels
            channels
                .outgoing_tx
                .send(message.clone())
                .await
                .map_err(|_| Error::Transport("Failed to send message".to_string()))?;
        } else if let Some(stdout) = &mut self.stdout {
            // Write directly to stdout
            stdout.write_all(json.as_bytes()).await.map_err(Error::Io)?;
            stdout.write_all(b"\n").await.map_err(Error::Io)?;
            stdout.flush().await.map_err(Error::Io)?;
        } else {
            return Err(Error::Transport(
                "Transport is not properly initialized".to_string(),
            ));
        }

        Ok(())
    }

    async fn send_to(&mut self, _client_id: &str, message: &Message) -> Result<(), Error> {
        // For STDIO transport, there's only one client, so send_to behaves the same as send
        self.send(message).await
    }

    async fn is_connected(&self) -> bool {
        self.connected
    }

    async fn close(&mut self) -> Result<(), Error> {
        if !self.connected {
            return Ok(());
        }

        // Notify closing
        self.notify_lifecycle(TransportLifecycleEvent::Closing);

        // Take channels
        let channels = self.channels.take();

        // Close channels if they exist
        if let Some(channels) = channels {
            // Close outgoing channel
            drop(channels.outgoing_tx);

            // Wait for writer task to complete
            if let Err(e) = channels.writer_task.await {
                tracing::error!("Error joining writer task: {}", e);
            }
        }

        // Take the process
        let mut process = self.process.take();

        // Try graceful shutdown first
        if let Some(ref mut child) = process {
            // Terminate process
            tracing::debug!("Terminating child process");

            #[cfg(unix)]
            {
                if let Err(e) = child.kill().await {
                    tracing::error!("Error killing process: {}", e);
                }
            }

            #[cfg(windows)]
            {
                if let Err(e) = child.kill().await {
                    tracing::error!("Error killing process: {}", e);
                }
            }

            // Wait for process to exit
            match tokio::time::timeout(self.exit_timeout, child.wait()).await {
                Ok(Ok(_)) => {
                    tracing::debug!("Child process exited successfully");
                }
                Ok(Err(e)) => {
                    tracing::error!("Error waiting for child process: {}", e);
                }
                Err(_) => {
                    tracing::error!("Timeout waiting for child process to exit");

                    // Force kill
                    #[cfg(unix)]
                    {
                        if let Err(e) = child.kill().await {
                            tracing::error!("Error force killing process: {}", e);
                        }
                    }

                    #[cfg(windows)]
                    {
                        if let Err(e) = child.kill().await {
                            tracing::error!("Error force killing process: {}", e);
                        }
                    }
                }
            }
        }

        self.connected = false;

        // Notify closed
        self.notify_lifecycle(TransportLifecycleEvent::Closed);

        Ok(())
    }

    /// Register a lifecycle event handler
    fn register_lifecycle_handler(
        &mut self,
        handler: Box<dyn Fn(TransportLifecycleEvent) + Send + Sync>,
    ) {
        self.lifecycle_handlers.push(handler);
    }
}

impl Default for StdioTransport {
    fn default() -> Self {
        Self::new()
    }
}


<file_info>
path: src/tools/process_manager.rs
name: process_manager.rs
</file_info>
//! Process Manager for Tool Execution
//!
//! This module implements the process management functionality for executing tools
//! as external processes, capturing their output, and managing their lifecycle.

use crate::errors::Error;
use std::collections::HashMap;
use std::process::Stdio;
use std::sync::Arc;
use tokio::io::{AsyncBufReadExt, AsyncWriteExt, BufReader};
use tokio::process::{Child, Command as TokioCommand};
use tokio::sync::{Mutex, mpsc, oneshot};

/// Type of tool output (stdout or stderr)
#[derive(Debug, Clone)]
pub enum ToolOutputType {
    /// Standard output
    Stdout,
    /// Standard error
    Stderr,
}

/// Output from a tool process
#[derive(Debug, Clone)]
pub struct ToolOutput {
    /// Type of output (stdout or stderr)
    pub output_type: ToolOutputType,
    /// Content of the output
    pub content: String,
}

/// A running tool process
struct ToolProcess {
    /// The child process
    child: Child,
    /// The stdin handle for writing to the process
    stdin: Option<tokio::process::ChildStdin>,
    /// Channel for cancelling the process
    cancellation_tx: Option<oneshot::Sender<()>>,
}

/// Manager for spawning and interacting with tool processes
pub struct ToolProcessManager {
    /// Map of running processes by ID
    processes: Arc<Mutex<HashMap<String, ToolProcess>>>,
}

impl ToolProcessManager {
    /// Create a new tool process manager
    pub fn new() -> Self {
        Self {
            processes: Arc::new(Mutex::new(HashMap::new())),
        }
    }

    /// Spawn a new process for a tool
    pub async fn spawn_process(
        &self,
        tool_id: &str,
        command: &str,
        args: &[&str],
        env: HashMap<String, String>,
    ) -> Result<mpsc::Receiver<ToolOutput>, Error> {
        let mut command = TokioCommand::new(command);
        command
            .args(args)
            .stdin(Stdio::piped())
            .stdout(Stdio::piped())
            .stderr(Stdio::piped());

        // Add environment variables
        for (key, value) in env {
            command.env(key, value);
        }

        // Spawn the process
        let mut child = command
            .spawn()
            .map_err(|e| Error::Tool(format!("Failed to spawn process: {}", e)))?;

        let stdin = child.stdin.take();
        let stdout = child
            .stdout
            .take()
            .ok_or_else(|| Error::Tool("Failed to capture stdout".to_string()))?;
        let stderr = child
            .stderr
            .take()
            .ok_or_else(|| Error::Tool("Failed to capture stderr".to_string()))?;

        // Create communication channels
        let (output_tx, output_rx) = mpsc::channel(100);
        let (cancel_tx, cancel_rx) = oneshot::channel();

        // Store the process
        let mut processes = self.processes.lock().await;
        processes.insert(
            tool_id.to_string(),
            ToolProcess {
                child,
                stdin,
                cancellation_tx: Some(cancel_tx),
            },
        );

        // Process stdout/stderr in background tasks
        self.process_output(stdout, output_tx.clone(), ToolOutputType::Stdout);
        self.process_output(stderr, output_tx.clone(), ToolOutputType::Stderr);

        // Handle cancellation
        let processes_ref = self.processes.clone();
        let tool_id = tool_id.to_string();
        tokio::spawn(async move {
            let _ = cancel_rx.await;
            let mut processes = processes_ref.lock().await;
            if let Some(process) = processes.get_mut(&tool_id) {
                let _ = process.child.kill().await;
            }
            processes.remove(&tool_id);
        });

        Ok(output_rx)
    }

    /// Process output from a subprocess
    fn process_output<R: tokio::io::AsyncRead + Unpin + Send + 'static>(
        &self,
        reader: R,
        tx: mpsc::Sender<ToolOutput>,
        output_type: ToolOutputType,
    ) {
        let mut buf_reader = BufReader::new(reader);
        let mut line = String::new();

        tokio::spawn(async move {
            loop {
                line.clear();
                match buf_reader.read_line(&mut line).await {
                    Ok(0) => {
                        break;
                    } // EOF
                    Ok(_) => {
                        let output = ToolOutput {
                            output_type: output_type.clone(),
                            content: line.clone(),
                        };

                        if tx.send(output).await.is_err() {
                            break;
                        }
                    }
                    Err(_) => {
                        break;
                    }
                }
            }
        });
    }

    /// Send input to a running process
    pub async fn send_input(&self, tool_id: &str, input: &str) -> Result<(), Error> {
        let mut processes = self.processes.lock().await;
        let process = processes
            .get_mut(tool_id)
            .ok_or_else(|| Error::Tool(format!("Process not found: {}", tool_id)))?;

        if let Some(stdin) = &mut process.stdin {
            stdin
                .write_all(input.as_bytes())
                .await
                .map_err(|e| Error::Tool(format!("Failed to write to process: {}", e)))?;
            stdin
                .flush()
                .await
                .map_err(|e| Error::Tool(format!("Failed to flush stdin: {}", e)))?;
            Ok(())
        } else {
            Err(Error::Tool("Process stdin not available".to_string()))
        }
    }

    /// Cancel a running process
    pub async fn cancel_process(&self, tool_id: &str) -> Result<(), Error> {
        let mut processes = self.processes.lock().await;
        if let Some(process) = processes.get_mut(tool_id) {
            if let Some(tx) = process.cancellation_tx.take() {
                let _ = tx.send(());
            }
            processes.remove(tool_id);
            Ok(())
        } else {
            Err(Error::Tool(format!("Process not found: {}", tool_id)))
        }
    }
}


<file_info>
path: src/transport/mod.rs
name: mod.rs
</file_info>
//! MCP Transport Layer
//!
//! This module defines the transport abstraction for the MCP library, allowing
//! different communication channels (e.g., STDIO, SSE) to be used interchangeably.
//! It includes the `Transport` trait and utilities for managing message transmission.

use crate::errors::Error;
use crate::messages::Message;
use async_trait::async_trait;

pub mod sse;
pub mod sse_server;
pub mod stdio;
pub mod websocket;
pub mod websocket_server;

/// Transport lifecycle events
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum TransportLifecycleEvent {
    /// Transport is starting
    Starting,

    /// Transport has started
    Started,

    /// Transport is closing
    Closing,

    /// Transport has closed
    Closed,

    /// Transport has encountered an error
    Error,

    /// Client connected (server only)
    ClientConnected(String),

    /// Client disconnected (server only)
    ClientDisconnected(String),
}

/// The Transport trait defines the interface for sending and receiving MCP messages
#[async_trait]
pub trait Transport: Send + Sync {
    /// Receive a message from the transport
    ///
    /// Returns a tuple containing:
    /// - Option<String>: The client ID (if applicable)
    /// - Message: The received message
    ///
    /// For client-side transports, the client ID will typically be None.
    /// For server-side transports, the client ID identifies which client sent the message.
    async fn receive(&mut self) -> Result<(Option<String>, Message), Error>;

    /// Send a message via the transport
    /// Note: For server implementations, this acts as a broadcast to all clients
    async fn send(&mut self, message: &Message) -> Result<(), Error>;

    /// Send a message to a specific client
    /// This is used by server implementations to respond to a specific client
    /// For client implementations, this is equivalent to `send`
    async fn send_to(&mut self, client_id: &str, message: &Message) -> Result<(), Error>;

    /// Check if the transport is connected
    async fn is_connected(&self) -> bool;

    /// Close the transport
    async fn close(&mut self) -> Result<(), Error>;

    /// Register a lifecycle event handler
    fn register_lifecycle_handler(
        &mut self,
        handler: Box<dyn Fn(TransportLifecycleEvent) + Send + Sync>,
    );
}


<file_info>
path: src/errors.rs
name: errors.rs
</file_info>
//! MCP Error Types
//!
//! This module defines custom error types for the MCP library, providing detailed
//! and type-safe error handling for various failure scenarios, such as protocol
//! errors, transport issues, and message parsing failures.

use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use thiserror::Error;

/// Error data for JSON-RPC responses
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct ErrorData {
    /// Error code
    pub code: i32,
    /// Error message
    pub message: String,
    /// Optional additional data
    #[serde(skip_serializing_if = "Option::is_none")]
    pub data: Option<serde_json::Value>,
}

/// The main Error type for the MCP library
#[derive(Error, Debug)]
pub enum Error {
    /// JSON serialization/deserialization errors
    #[error("JSON error: {0}")]
    Json(#[from] serde_json::Error),

    /// I/O errors
    #[error("I/O error: {0}")]
    Io(#[from] std::io::Error),

    /// Transport-related errors
    #[error("Transport error: {0}")]
    Transport(String),

    /// Protocol errors (e.g., invalid message format)
    #[error("Protocol error: {0}")]
    Protocol(String),

    /// Method not found
    #[error("Method not found: {0}")]
    MethodNotFound(String),

    /// Invalid parameters
    #[error("Invalid parameters: {0}")]
    InvalidParams(String),

    /// Resource errors
    #[error("Resource error: {0}")]
    Resource(String),

    /// Tool errors
    #[error("Tool error: {0}")]
    Tool(String),

    /// Prompt errors
    #[error("Prompt error: {0}")]
    Prompt(String),

    /// Request validation error
    #[error("Validation error: {0}")]
    Validation(String),

    /// Schema validation error
    #[error("Schema validation error: {0}")]
    SchemaValidation(String),

    /// Version incompatibility error
    #[error("Version incompatibility: {0}")]
    VersionIncompatibility(String),

    /// Authentication error
    #[error("Authentication error: {0}")]
    Authentication(String),

    /// Authorization error
    #[error("Authorization error: {0}")]
    Authorization(String),

    /// Rate limit exceeded
    #[error("Rate limit exceeded: {0}")]
    RateLimit(String),

    /// Request timeout
    #[error("Request timeout: {0}")]
    Timeout(String),

    /// Initialization error
    #[error("Initialization error: {0}")]
    Initialization(String),

    /// Server busy or unavailable
    #[error("Server unavailable: {0}")]
    ServerUnavailable(String),

    /// Invalid state for requested operation
    #[error("Invalid state: {0}")]
    InvalidState(String),

    /// Other errors
    #[error("{0}")]
    Other(String),
}

/// Standard JSON-RPC 2.0 error codes
pub mod error_codes {
    /// Parse error
    pub const PARSE_ERROR: i32 = -32700;
    /// Invalid request
    pub const INVALID_REQUEST: i32 = -32600;
    /// Method not found
    pub const METHOD_NOT_FOUND: i32 = -32601;
    /// Invalid params
    pub const INVALID_PARAMS: i32 = -32602;
    /// Internal error
    pub const INTERNAL_ERROR: i32 = -32603;
    /// Server error range start
    pub const SERVER_ERROR_START: i32 = -32099;
    /// Server error range end
    pub const SERVER_ERROR_END: i32 = -32000;
    /// MCP-specific error codes can be defined in the range below -32000
    pub const RESOURCE_NOT_FOUND: i32 = -33000;
    /// Tool not found
    pub const TOOL_NOT_FOUND: i32 = -33001;
    /// Tool execution error
    pub const TOOL_EXECUTION_ERROR: i32 = -33002;
    /// Prompt not found
    pub const PROMPT_NOT_FOUND: i32 = -33003;
    /// Prompt validation error
    pub const PROMPT_VALIDATION_ERROR: i32 = -33004;
    /// Server is not initialized
    pub const SERVER_NOT_INITIALIZED: i32 = -33005;
    /// Client is not initialized
    pub const CLIENT_NOT_INITIALIZED: i32 = -33006;
    /// Incompatible protocol version
    pub const INCOMPATIBLE_VERSION: i32 = -33007;
    /// Authentication error
    pub const AUTHENTICATION_ERROR: i32 = -33008;
    /// Authorization error
    pub const AUTHORIZATION_ERROR: i32 = -33009;
    /// Rate limit exceeded
    pub const RATE_LIMIT_EXCEEDED: i32 = -33010;
    /// Request timeout
    pub const REQUEST_TIMEOUT: i32 = -33011;
    /// Resource content error
    pub const RESOURCE_CONTENT_ERROR: i32 = -33012;
    /// Tool parameter error
    pub const TOOL_PARAMETER_ERROR: i32 = -33013;
    /// Server busy or unavailable
    pub const SERVER_UNAVAILABLE: i32 = -33014;
    /// Schema validation error
    pub const SCHEMA_VALIDATION_ERROR: i32 = -33015;
}

impl Error {
    /// Convert an error to a JSON-RPC error code
    pub fn to_code(&self) -> i32 {
        use error_codes::*;
        match self {
            Error::Json(_) => PARSE_ERROR,
            Error::Protocol(_) => INVALID_REQUEST,
            Error::MethodNotFound(_) => METHOD_NOT_FOUND,
            Error::InvalidParams(_) => INVALID_PARAMS,
            Error::Resource(_) => RESOURCE_NOT_FOUND,
            Error::Tool(_) => TOOL_NOT_FOUND,
            Error::Prompt(_) => PROMPT_NOT_FOUND,
            Error::Validation(_) => INVALID_PARAMS,
            Error::SchemaValidation(_) => SCHEMA_VALIDATION_ERROR,
            Error::VersionIncompatibility(_) => INCOMPATIBLE_VERSION,
            Error::Authentication(_) => AUTHENTICATION_ERROR,
            Error::Authorization(_) => AUTHORIZATION_ERROR,
            Error::RateLimit(_) => RATE_LIMIT_EXCEEDED,
            Error::Timeout(_) => REQUEST_TIMEOUT,
            Error::Initialization(_) => SERVER_NOT_INITIALIZED,
            Error::InvalidState(_) => SERVER_NOT_INITIALIZED,
            Error::ServerUnavailable(_) => SERVER_UNAVAILABLE,
            Error::Io(_) => INTERNAL_ERROR,
            Error::Transport(_) => INTERNAL_ERROR,
            Error::Other(_) => INTERNAL_ERROR,
        }
    }

    /// Create an error response payload from this error
    pub fn to_response_payload(&self, id: i32) -> crate::messages::Response {
        let code = self.to_code();
        let message = self.to_string();

        crate::messages::error_response(id, code, &message, None)
    }
}


<file_info>
path: src/utils.rs
name: utils.rs
</file_info>
//! MCP Utilities
//!
//! This module provides utility functions and helpers for the MCP library, such as
//! schema generation, message validation, or other common operations used across
//! the crate.

use crate::errors::Error;
use crate::messages::{ErrorData, Message, Response, ResponseOutcome};
use serde::{Deserialize, Serialize, de::DeserializeOwned};
use serde_json::Value;
use std::future::Future;
use std::str::FromStr;
use std::time::Duration;
use tokio::time::timeout as tokio_timeout;
use tracing::{debug, trace, warn};
use url::Url;

//=============================================================================
// 1. JSON Utilities
//=============================================================================

/// JSON utility functions for working with MCP data
pub mod json {
    use super::*;

    /// Serialize a value to a JSON string with pretty formatting
    pub fn to_pretty_string<T: Serialize>(value: &T) -> Result<String, Error> {
        serde_json::to_string_pretty(value).map_err(Error::Json)
    }

    /// Serialize a value to a compact JSON string
    pub fn to_string<T: Serialize>(value: &T) -> Result<String, Error> {
        serde_json::to_string(value).map_err(Error::Json)
    }

    /// Deserialize a JSON string to a value of type T
    pub fn from_str<T: DeserializeOwned>(s: &str) -> Result<T, Error> {
        serde_json::from_str(s).map_err(Error::Json)
    }

    /// Extract a field from a JSON Value as a specific type
    pub fn extract_field<T: DeserializeOwned>(value: &Value, field: &str) -> Result<T, Error> {
        let field_value = value.get(field).ok_or_else(|| {
            Error::Protocol(format!("Field '{}' not found in JSON object", field))
        })?;

        serde_json::from_value(field_value.clone()).map_err(Error::Json)
    }

    /// Merge two JSON objects, with values from the second overriding the first
    pub fn merge_objects(base: &mut Value, overlay: &Value) -> Result<(), Error> {
        if !base.is_object() || !overlay.is_object() {
            return Err(Error::Protocol("Can only merge JSON objects".to_string()));
        }

        let base_map = base.as_object_mut().unwrap();
        let overlay_map = overlay.as_object().unwrap();

        for (key, value) in overlay_map {
            if let Some(existing) = base_map.get_mut(key) {
                if existing.is_object() && value.is_object() {
                    merge_objects(existing, value)?;
                } else {
                    *existing = value.clone();
                }
            } else {
                base_map.insert(key.clone(), value.clone());
            }
        }

        Ok(())
    }
}

//=============================================================================
// 2. URI Handling
//=============================================================================

/// URI utility functions for working with MCP resources
pub mod uri {
    use super::*;

    /// The scheme for MCP resource URIs
    pub const MCP_SCHEME: &str = "mcp";

    /// A typed representation of an MCP URI
    #[derive(Debug, Clone, PartialEq, Eq)]
    pub struct McpUri {
        url: Url,
    }

    impl McpUri {
        /// Create a new MCP URI from the given path components
        pub fn new(components: &[&str]) -> Result<Self, Error> {
            let path = components.join("/");
            let uri_str = format!("{}://{}", MCP_SCHEME, path);
            Self::from_str(&uri_str)
        }

        /// Return the scheme of the URI
        pub fn scheme(&self) -> &str {
            self.url.scheme()
        }

        /// Return the path of the URI
        pub fn path(&self) -> &str {
            self.url.path()
        }

        /// Return the resource type from the URI
        pub fn resource_type(&self) -> Option<&str> {
            self.url.path_segments()?.next()
        }

        /// Return the resource ID from the URI
        pub fn resource_id(&self) -> Option<&str> {
            let mut segments = self.url.path_segments()?;
            segments.next()?; // Skip the type
            segments.next() // Get the ID
        }

        /// Check if this is a valid MCP URI
        pub fn is_valid(&self) -> bool {
            self.scheme() == MCP_SCHEME && self.resource_type().is_some()
        }
    }

    impl FromStr for McpUri {
        type Err = Error;

        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match Url::parse(s) {
                Ok(url) => Ok(McpUri { url }),
                Err(e) => Err(Error::Resource(format!("Invalid URI: {}", e))),
            }
        }
    }

    impl ToString for McpUri {
        fn to_string(&self) -> String {
            self.url.to_string()
        }
    }

    /// Validate that a URI string is a valid MCP URI
    pub fn validate_uri(uri: &str) -> Result<(), Error> {
        let mcp_uri = McpUri::from_str(uri)?;
        if !mcp_uri.is_valid() {
            return Err(Error::Resource(format!("Invalid MCP URI format: {}", uri)));
        }
        Ok(())
    }
}

//=============================================================================
// 3. Error Utilities
//=============================================================================

/// Error utility functions for MCP error handling
pub mod errors {
    use super::*;
    use crate::errors::error_codes;

    /// Create an error response with the given code, message, and optional data
    pub fn create_error_response(
        id: i32,
        code: i32,
        message: &str,
        data: Option<Value>,
    ) -> Response {
        Response {
            jsonrpc: "2.0".to_string(),
            id,
            outcome: ResponseOutcome::Error {
                error: ErrorData {
                    code,
                    message: message.to_string(),
                    data,
                },
            },
        }
    }

    /// Create a standard protocol error response
    pub fn protocol_error(id: i32, message: &str) -> Response {
        create_error_response(id, error_codes::INVALID_REQUEST, message, None)
    }

    /// Create a method not found error response
    pub fn method_not_found(id: i32, method: &str) -> Response {
        create_error_response(
            id,
            error_codes::METHOD_NOT_FOUND,
            &format!("Method not found: {}", method),
            None,
        )
    }

    /// Create an invalid params error response
    pub fn invalid_params(id: i32, message: &str) -> Response {
        create_error_response(id, error_codes::INVALID_PARAMS, message, None)
    }

    /// Create an internal error response
    pub fn internal_error(id: i32, message: &str) -> Response {
        create_error_response(id, error_codes::INTERNAL_ERROR, message, None)
    }

    /// Create a resource not found error response
    pub fn resource_not_found(id: i32, uri: &str) -> Response {
        create_error_response(
            id,
            error_codes::RESOURCE_NOT_FOUND,
            &format!("Resource not found: {}", uri),
            None,
        )
    }

    /// Create a tool not found error response
    pub fn tool_not_found(id: i32, tool_name: &str) -> Response {
        create_error_response(
            id,
            error_codes::TOOL_NOT_FOUND,
            &format!("Tool not found: {}", tool_name),
            None,
        )
    }

    /// Create a tool execution error response
    pub fn tool_execution_error(id: i32, tool_name: &str, error_msg: &str) -> Response {
        create_error_response(
            id,
            error_codes::TOOL_EXECUTION_ERROR,
            &format!("Error executing tool {}: {}", tool_name, error_msg),
            None,
        )
    }
}

//=============================================================================
// 4. Async Utilities
//=============================================================================

/// Async utility functions for working with futures in MCP
pub mod async_utils {
    use super::*;

    /// Run a future with a timeout
    pub async fn timeout<F, T>(duration: Duration, future: F) -> Result<T, Error>
    where
        F: Future<Output = Result<T, Error>>,
    {
        match tokio_timeout(duration, future).await {
            Ok(result) => result,
            Err(_) => Err(Error::Other(format!(
                "Operation timed out after {:?}",
                duration
            ))),
        }
    }

    /// Retry an async operation with exponential backoff
    pub async fn retry<F, Fut, T>(
        operation: F,
        max_attempts: usize,
        initial_backoff: Duration,
    ) -> Result<T, Error>
    where
        F: Fn() -> Fut,
        Fut: Future<Output = Result<T, Error>>,
    {
        let mut attempts = 0;
        let mut backoff = initial_backoff;

        loop {
            attempts += 1;
            match operation().await {
                Ok(value) => {
                    return Ok(value);
                }
                Err(error) => {
                    if attempts >= max_attempts {
                        return Err(error);
                    }

                    debug!(
                        "Retry attempt {}/{} failed: {}",
                        attempts, max_attempts, error
                    );
                    tokio::time::sleep(backoff).await;
                    backoff *= 2; // Exponential backoff
                }
            }
        }
    }

    /// Cancel a future after a specified duration
    pub async fn with_timeout<F, T>(future: F, duration: Duration) -> Result<T, Error>
    where
        F: Future<Output = T>,
    {
        tokio_timeout(duration, future)
            .await
            .map_err(|_| Error::Other(format!("Operation timed out after {:?}", duration)))
    }
}

//=============================================================================
// 5. Schema Utilities
//=============================================================================

/// Schema utility functions for working with JSON schemas in MCP
pub mod schema {
    use jsonschema::JSONSchema;
    use schemars::JsonSchema;
    use schemars::schema_for;
    use serde_json::Value;
    use std::collections::HashMap;
    use std::sync::OnceLock;

    use crate::errors::Error;
    use crate::messages::{GenericRequest, Message, Response};
    use crate::types::{
        initialize::{InitializeRequestParams, InitializeResult},
        prompts::{
            CreatePromptParams, CreatePromptResult, DeletePromptParams, DeletePromptResult,
            ListPromptsParams, ListPromptsResult, RenderPromptParams, RenderPromptResult,
            UpdatePromptParams, UpdatePromptResult,
        },
        resources::{
            CreateResourceParams, CreateResourceResult, DeleteResourceParams, DeleteResourceResult,
            GetResourceParams, GetResourceResult, ListResourcesParams, ListResourcesResult,
            UpdateResourceParams, UpdateResourceResult,
        },
        tools::{CallToolParams, CallToolResult, ListToolsParams, ListToolsResult},
    };

    // Static reference to compiled full schema
    static FULL_SCHEMA: OnceLock<JSONSchema> = OnceLock::new();

    /// Initialize the full MCP schema from file
    pub fn init_full_schema() -> Result<(), Error> {
        if FULL_SCHEMA.get().is_some() {
            return Ok(());
        }

        // Try to use the embedded schema if available
        let schema_content = include_str!("../src/schema/schema.json");
        let schema_value: Value = serde_json::from_str(schema_content)
            .map_err(|e| Error::SchemaValidation(format!("Failed to parse schema.json: {}", e)))?;

        // Compile the schema
        let compiled = JSONSchema::compile(&schema_value)
            .map_err(|e| Error::SchemaValidation(format!("Failed to compile schema: {}", e)))?;

        // Store the compiled schema
        FULL_SCHEMA
            .set(compiled)
            .map_err(|_| Error::SchemaValidation("Failed to set compiled schema".to_string()))?;

        Ok(())
    }

    /// Validate a message against the full MCP JSON schema
    pub fn validate_against_full_schema(value: &Value) -> Result<(), Error> {
        if let Some(schema) = FULL_SCHEMA.get() {
            let validation = schema.validate(value);
            if let Err(errors) = validation {
                let error_msgs: Vec<String> = errors.map(|e| format!("{}", e)).collect();
                return Err(Error::SchemaValidation(format!(
                    "Schema validation failed: {}",
                    error_msgs.join(", ")
                )));
            }
            Ok(())
        } else {
            // Schema not loaded, can't validate
            Ok(())
        }
    }

    /// Validate a request message against the full MCP schema
    pub fn validate_request_against_full_schema(request: &GenericRequest) -> Result<(), Error> {
        // Schema is expected to be initialized by the caller
        if FULL_SCHEMA.get().is_none() {
            // Schema not available, just succeed
            return Ok(());
        }

        let json_value = serde_json::to_value(request)
            .map_err(|e| Error::SchemaValidation(format!("Failed to serialize request: {}", e)))?;

        validate_against_full_schema(&json_value)
    }

    /// Validate a response message against the full MCP schema
    pub fn validate_response_against_full_schema(response: &Response) -> Result<(), Error> {
        // Schema is expected to be initialized by the caller
        if FULL_SCHEMA.get().is_none() {
            // Schema not available, just succeed
            return Ok(());
        }

        let json_value = serde_json::to_value(response)
            .map_err(|e| Error::SchemaValidation(format!("Failed to serialize response: {}", e)))?;

        validate_against_full_schema(&json_value)
    }

    /// Validate a generic message against the full MCP schema
    pub fn validate_message_against_full_schema(message: &Message) -> Result<(), Error> {
        // Schema is expected to be initialized by the caller
        if FULL_SCHEMA.get().is_none() {
            // Schema not available, just succeed
            return Ok(());
        }

        let json_value = serde_json::to_value(message)
            .map_err(|e| Error::SchemaValidation(format!("Failed to serialize message: {}", e)))?;

        validate_against_full_schema(&json_value)
    }

    /// Get or create the method parameter schema registry
    fn param_schema_registry() -> &'static HashMap<String, Value> {
        static REGISTRY: OnceLock<HashMap<String, Value>> = OnceLock::new();
        REGISTRY.get_or_init(|| {
            let mut registry = HashMap::new();

            // Initialize method
            registry.insert(
                "initialize".to_string(),
                generate_schema::<InitializeRequestParams>(),
            );

            // Resource methods
            registry.insert(
                "resources/list".to_string(),
                generate_schema::<ListResourcesParams>(),
            );
            registry.insert(
                "resources/get".to_string(),
                generate_schema::<GetResourceParams>(),
            );
            registry.insert(
                "resources/create".to_string(),
                generate_schema::<CreateResourceParams>(),
            );
            registry.insert(
                "resources/update".to_string(),
                generate_schema::<UpdateResourceParams>(),
            );
            registry.insert(
                "resources/delete".to_string(),
                generate_schema::<DeleteResourceParams>(),
            );

            // Tool methods
            registry.insert(
                "tools/list".to_string(),
                generate_schema::<ListToolsParams>(),
            );
            registry.insert(
                "tools/call".to_string(),
                generate_schema::<CallToolParams>(),
            );

            // Prompt methods
            registry.insert(
                "prompts/list".to_string(),
                generate_schema::<ListPromptsParams>(),
            );
            registry.insert(
                "prompts/create".to_string(),
                generate_schema::<CreatePromptParams>(),
            );
            registry.insert(
                "prompts/update".to_string(),
                generate_schema::<UpdatePromptParams>(),
            );
            registry.insert(
                "prompts/delete".to_string(),
                generate_schema::<DeletePromptParams>(),
            );
            registry.insert(
                "prompts/render".to_string(),
                generate_schema::<RenderPromptParams>(),
            );

            registry
        })
    }

    /// Get or create the method result schema registry
    fn result_schema_registry() -> &'static HashMap<String, Value> {
        static REGISTRY: OnceLock<HashMap<String, Value>> = OnceLock::new();
        REGISTRY.get_or_init(|| {
            let mut registry = HashMap::new();

            // Initialize method
            registry.insert(
                "initialize".to_string(),
                generate_schema::<InitializeResult>(),
            );

            // Resource methods
            registry.insert(
                "resources/list".to_string(),
                generate_schema::<ListResourcesResult>(),
            );
            registry.insert(
                "resources/get".to_string(),
                generate_schema::<GetResourceResult>(),
            );
            registry.insert(
                "resources/create".to_string(),
                generate_schema::<CreateResourceResult>(),
            );
            registry.insert(
                "resources/update".to_string(),
                generate_schema::<UpdateResourceResult>(),
            );
            registry.insert(
                "resources/delete".to_string(),
                generate_schema::<DeleteResourceResult>(),
            );

            // Tool methods
            registry.insert(
                "tools/list".to_string(),
                generate_schema::<ListToolsResult>(),
            );
            registry.insert(
                "tools/call".to_string(),
                generate_schema::<CallToolResult>(),
            );

            // Prompt methods
            registry.insert(
                "prompts/list".to_string(),
                generate_schema::<ListPromptsResult>(),
            );
            registry.insert(
                "prompts/create".to_string(),
                generate_schema::<CreatePromptResult>(),
            );
            registry.insert(
                "prompts/update".to_string(),
                generate_schema::<UpdatePromptResult>(),
            );
            registry.insert(
                "prompts/delete".to_string(),
                generate_schema::<DeletePromptResult>(),
            );
            registry.insert(
                "prompts/render".to_string(),
                generate_schema::<RenderPromptResult>(),
            );

            registry
        })
    }

    /// Generate a JSON schema for the given type
    pub fn generate_schema<T: JsonSchema>() -> Value {
        serde_json::to_value(schema_for!(T)).unwrap_or_else(|_| Value::Null)
    }

    /// Validate the given value against the JSON schema for the type
    pub fn validate<T: JsonSchema>(value: &Value) -> Result<(), Error> {
        let schema = generate_schema::<T>();
        validate_against_schema(value, &schema)
    }

    /// Validate the given value against a specific JSON schema
    pub fn validate_against_schema(value: &Value, schema: &Value) -> Result<(), Error> {
        let compiled = JSONSchema::compile(schema)
            .map_err(|e| Error::Protocol(format!("Invalid schema: {}", e)))?;

        let validation = compiled.validate(value);
        if let Err(errors) = validation {
            let error_msgs: Vec<String> = errors.map(|e| format!("{}", e)).collect();

            return Err(Error::InvalidParams(format!(
                "Schema validation failed: {}",
                error_msgs.join(", ")
            )));
        }

        Ok(())
    }

    /// Get the parameter schema for a specific method
    pub fn get_param_schema(method: &str) -> Option<Value> {
        param_schema_registry().get(method).cloned()
    }

    /// Get the result schema for a specific method
    pub fn get_result_schema(method: &str) -> Option<Value> {
        result_schema_registry().get(method).cloned()
    }

    /// Validate parameters for a specific method
    pub fn validate_method_params(method: &str, params: &Value) -> Result<(), Error> {
        if let Some(schema) = get_param_schema(method) {
            validate_against_schema(params, &schema)
        } else {
            // No schema found for this method - can't validate
            Ok(())
        }
    }

    /// Validate result for a specific method
    pub fn validate_method_result(method: &str, result: &Value) -> Result<(), Error> {
        if let Some(schema) = get_result_schema(method) {
            validate_against_schema(result, &schema)
        } else {
            // No schema found for this method - can't validate
            Ok(())
        }
    }

    /// Generate schemas for all supported types
    pub fn generate_all_schemas() -> Result<HashMap<String, Value>, Error> {
        let mut schemas = HashMap::new();

        // Include all parameter schemas
        for (method, schema) in param_schema_registry().iter() {
            schemas.insert(format!("{}_params", method), schema.clone());
        }

        // Include all result schemas
        for (method, schema) in result_schema_registry().iter() {
            schemas.insert(format!("{}_result", method), schema.clone());
        }

        Ok(schemas)
    }
}

//=============================================================================
// 6. Authentication Utilities
//=============================================================================

/// Authentication utility functions for MCP (if required)
pub mod auth {
    use super::*;

    /// A simple API key for basic authentication
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct ApiKey {
        pub key: String,
    }

    impl ApiKey {
        /// Create a new API key
        pub fn new(key: &str) -> Self {
            Self {
                key: key.to_string(),
            }
        }

        /// Validate the API key
        pub fn validate(&self, expected: &str) -> bool {
            self.key == expected
        }
    }

    /// Generate a simple authentication header for HTTP-based transports
    pub fn generate_auth_header(api_key: &ApiKey) -> String {
        format!("Bearer {}", api_key.key)
    }

    /// Parse an authentication header to extract the API key
    pub fn parse_auth_header(header: &str) -> Result<ApiKey, Error> {
        if let Some(key) = header.strip_prefix("Bearer ") {
            Ok(ApiKey::new(key))
        } else {
            Err(Error::Protocol(
                "Invalid authentication header format".to_string(),
            ))
        }
    }
}

//=============================================================================
// 7. Logging and Debugging Utilities
//=============================================================================

/// Logging and debugging utility functions for MCP
pub mod logging {
    use super::*;

    /// Log an MCP message at debug level
    pub fn log_message(msg: &Message) {
        match msg {
            Message::Request(req) => {
                debug!("MCP Request: method={}, id={:?}", req.method, req.id);
                trace!("Request params: {:?}", req.params);
            }
            Message::Response(resp) => match &resp.outcome {
                ResponseOutcome::Success { result: _ } => {
                    debug!("MCP Response: id={}, success=true", resp.id);
                    trace!("Response result: {:?}", resp.outcome);
                }
                ResponseOutcome::Error { error } => {
                    warn!(
                        "MCP Error Response: id={}, code={}, message={}",
                        resp.id, error.code, error.message
                    );
                }
            },
            Message::Notification(notification) => {
                debug!("MCP Notification: method={}", notification.method);
                trace!("Notification params: {:?}", notification.params);
            }
        }
    }

    /// Pretty-print an MCP message as a string
    pub fn format_message(msg: &Message) -> Result<String, Error> {
        json::to_pretty_string(msg)
    }

    /// Create a debug dump of the message exchange for troubleshooting
    pub struct MessageExchangeDebugger {
        request: Option<Message>,
        response: Option<Message>,
        timestamp: std::time::SystemTime,
    }

    impl MessageExchangeDebugger {
        /// Create a new message exchange debugger
        pub fn new() -> Self {
            Self {
                request: None,
                response: None,
                timestamp: std::time::SystemTime::now(),
            }
        }

        /// Record a request
        pub fn record_request(&mut self, request: Message) {
            self.request = Some(request);
        }

        /// Record a response
        pub fn record_response(&mut self, response: Message) {
            self.response = Some(response);
        }

        /// Generate a debug report
        pub fn generate_report(&self) -> Result<String, Error> {
            let mut report = String::new();

            report.push_str(&format!("MCP Message Exchange Debug Report\n"));
            report.push_str(&format!("Timestamp: {:?}\n\n", self.timestamp));

            if let Some(ref req) = self.request {
                report.push_str("REQUEST:\n");
                report.push_str(&json::to_pretty_string(req)?);
                report.push_str("\n\n");
            } else {
                report.push_str("REQUEST: None recorded\n\n");
            }

            if let Some(ref resp) = self.response {
                report.push_str("RESPONSE:\n");
                report.push_str(&json::to_pretty_string(resp)?);
                report.push_str("\n");
            } else {
                report.push_str("RESPONSE: None recorded\n");
            }

            Ok(report)
        }
    }

    impl Default for MessageExchangeDebugger {
        fn default() -> Self {
            Self::new()
        }
    }
}

// Re-export commonly used utilities
pub use async_utils::timeout;
pub use errors::{create_error_response, invalid_params, method_not_found};
pub use json::{from_str, to_string};
pub use logging::log_message;
pub use schema::validate;
pub use uri::{McpUri, validate_uri};

/// Validation module for request and response validation
pub mod validation {
    use super::schema;
    use crate::errors::Error;
    use crate::messages::{GenericRequest, Response, ResponseOutcome};

    /// Configuration for schema validation
    #[derive(Debug, Clone, Copy)]
    pub struct ValidationConfig {
        /// Whether to validate requests
        pub validate_requests: bool,
        /// Whether to validate responses
        pub validate_responses: bool,
    }

    impl Default for ValidationConfig {
        fn default() -> Self {
            Self {
                validate_requests: true,
                validate_responses: true,
            }
        }
    }

    /// Validate an incoming request against its method schema
    pub fn validate_request(
        request: &GenericRequest,
        config: &ValidationConfig,
    ) -> Result<(), Error> {
        // Skip validation if disabled
        if !config.validate_requests {
            return Ok(());
        }

        // Get method and params
        let method = &request.method;

        // Validate params if they exist
        if let Some(params) = &request.params {
            schema::validate_method_params(method, params)?;
        }

        // Conditionally initialize and use full schema validation
        // We use a soft validation that won't fail if the schema isn't available
        if config.validate_requests {
            // Try to initialize the schema only when needed
            if schema::init_full_schema().is_ok() {
                schema::validate_request_against_full_schema(request).ok();
            }
        }

        Ok(())
    }

    /// Validate an outgoing response against its method schema
    pub fn validate_response(
        response: &Response,
        method: &str,
        config: &ValidationConfig,
    ) -> Result<(), Error> {
        // Skip validation if disabled
        if !config.validate_responses {
            return Ok(());
        }

        // Validate result if it's a success response
        if let ResponseOutcome::Success { result } = &response.outcome {
            schema::validate_method_result(method, result)?;
        }

        // Conditionally initialize and use full schema validation
        // We use a soft validation that won't fail if the schema isn't available
        if config.validate_responses {
            // Try to initialize the schema only when needed
            if schema::init_full_schema().is_ok() {
                schema::validate_response_against_full_schema(response).ok();
            }
        }

        Ok(())
    }
}


<file_info>
path: src/types/tools.rs
name: tools.rs
</file_info>
//! MCP Tool Types
//!
//! This module defines types related to tools in the MCP protocol, including
//! `Tool` and `CallToolParams`, which allow the AI application to perform actions
//! or computations via the server.

use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Represents a parameter for a tool
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ToolParameterType {
    #[serde(rename = "string")]
    String,
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "boolean")]
    Boolean,
    #[serde(rename = "object")]
    Object,
    #[serde(rename = "array")]
    Array,
}

/// Represents a parameter for a tool
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToolParameter {
    /// Name of the parameter
    pub name: String,
    /// Type of the parameter
    #[serde(rename = "type")]
    pub type_name: ToolParameterType,
    /// Description of the parameter
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// Whether the parameter is required
    #[serde(skip_serializing_if = "Option::is_none")]
    pub required: Option<bool>,
    /// Schema for the parameter (for complex types)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema: Option<serde_json::Value>,
    /// Default value
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default: Option<serde_json::Value>,
    /// Enum values (for string parameters)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enum_values: Option<Vec<String>>,
}

/// Represents a tool in the MCP protocol
#[derive(Debug, Clone)]
pub struct Tool {
    /// Unique name of the tool
    pub name: String,
    /// Description of what the tool does
    pub description: String,
    /// Parameters that the tool accepts
    pub parameters: Option<Vec<ToolParameter>>,
    /// Type of the return value
    pub return_type: Option<String>,
    /// Schema for the return value
    pub return_schema: Option<serde_json::Value>,
    /// Whether the tool execution is streaming
    pub is_streaming: Option<bool>,
    /// Whether the tool can be cancelled
    pub is_cancellable: Option<bool>,
    /// Maximum execution time in seconds
    pub timeout_seconds: Option<u64>,
}

/// Parameters for listing tools
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct ListToolsParams {
    /// Optional pagination token
    #[serde(skip_serializing_if = "Option::is_none")]
    pub page_token: Option<String>,
    /// Optional limit on the number of tools to return
    #[serde(skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i32>,
}

/// Result of listing tools
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct ListToolsResult {
    /// List of tools
    pub tools: Vec<Tool>,
    /// Token for the next page (if there are more tools)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_page_token: Option<String>,
}

/// Parameters for calling a tool
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct CallToolParams {
    /// Name of the tool to call (field used by Python/JS clients)
    #[serde(default)]
    pub name: String,
    /// Arguments to pass to the tool (field used by Python/JS clients)
    #[serde(default)]
    pub arguments: HashMap<String, serde_json::Value>,
}

/// Text content for a message or tool result
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct TextContent {
    /// The type of content (always "text" for TextContent)
    #[serde(rename = "type")]
    pub content_type: String,

    /// The text content
    pub text: String,

    /// Optional annotations (not used in this implementation)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub annotations: Option<serde_json::Value>,
}

/// Result of calling a tool
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct CallToolResult {
    /// Content of the tool call result
    pub content: Vec<serde_json::Value>,

    /// Flag indicating whether this is an error (using camelCase for Python compatibility)
    #[serde(rename = "isError")]
    pub is_error: bool,
}

// Instead of directly implementing JsonSchema for Tool, create a helper struct
// that can be used for JsonSchema derivation
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct ToolSchema {
    /// Unique name of the tool
    pub name: String,
    /// Description of what the tool does
    pub description: String,
    /// Input schema for the tool
    #[serde(rename = "inputSchema")]
    pub input_schema: serde_json::Value,
    /// Type of the return value
    #[serde(rename = "returnType", skip_serializing_if = "Option::is_none")]
    pub return_type: Option<String>,
    /// Schema for the return value
    #[serde(rename = "returnSchema", skip_serializing_if = "Option::is_none")]
    pub return_schema: Option<serde_json::Value>,
    /// Whether the tool execution is streaming
    #[serde(rename = "isStreaming", skip_serializing_if = "Option::is_none")]
    pub is_streaming: Option<bool>,
    /// Whether the tool can be cancelled
    #[serde(rename = "isCancellable", skip_serializing_if = "Option::is_none")]
    pub is_cancellable: Option<bool>,
    /// Maximum execution time in seconds
    #[serde(rename = "timeoutSeconds", skip_serializing_if = "Option::is_none")]
    pub timeout_seconds: Option<u64>,
}

// Add a conversion from Tool to ToolSchema
impl From<&Tool> for ToolSchema {
    fn from(tool: &Tool) -> Self {
        // Build inputSchema from parameters
        let input_schema = if let Some(params) = &tool.parameters {
            let mut properties = serde_json::Map::new();
            let mut required = Vec::new();

            for param in params {
                // Create schema for this parameter
                let mut schema = match &param.schema {
                    Some(schema) => schema.clone(),
                    None => {
                        // Create default schema based on type_name
                        let type_str = match param.type_name {
                            ToolParameterType::String => "string",
                            ToolParameterType::Number => "number",
                            ToolParameterType::Boolean => "boolean",
                            ToolParameterType::Object => "object",
                            ToolParameterType::Array => "array",
                        };
                        serde_json::json!({ "type": type_str })
                    }
                };

                // Add enum values if present
                if let Some(enum_values) = &param.enum_values {
                    if !enum_values.is_empty() {
                        if let Some(obj) = schema.as_object_mut() {
                            obj.insert(
                                "enum".to_string(),
                                serde_json::Value::Array(
                                    enum_values
                                        .iter()
                                        .map(|v| serde_json::Value::String(v.clone()))
                                        .collect(),
                                ),
                            );
                        }
                    }
                }

                // Add default value if present
                if let Some(default_value) = &param.default {
                    if let Some(obj) = schema.as_object_mut() {
                        obj.insert("default".to_string(), default_value.clone());
                    }
                }

                // Add to properties map
                properties.insert(param.name.clone(), schema);

                // Add to required array if parameter is required
                if param.required.unwrap_or(false) {
                    required.push(param.name.clone());
                }
            }

            // Create the inputSchema object
            serde_json::json!({
                "type": "object",
                "properties": properties,
                "required": required
            })
        } else {
            // Add minimal inputSchema if no parameters
            serde_json::json!({
                "type": "object",
                "properties": {}
            })
        };

        ToolSchema {
            name: tool.name.clone(),
            description: tool.description.clone(),
            input_schema,
            return_type: tool.return_type.clone(),
            return_schema: tool.return_schema.clone(),
            is_streaming: tool.is_streaming,
            is_cancellable: tool.is_cancellable,
            timeout_seconds: tool.timeout_seconds,
        }
    }
}

// Implement Serialize for Tool to properly handle the inputSchema field
impl Serialize for Tool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        ToolSchema::from(self).serialize(serializer)
    }
}

// Implement Deserialize for Tool
impl<'de> Deserialize<'de> for Tool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(Deserialize)]
        struct ToolHelper {
            name: String,
            description: String,
            #[serde(rename = "inputSchema")]
            input_schema: Option<serde_json::Value>,
            #[serde(rename = "returnType")]
            return_type: Option<String>,
            #[serde(rename = "returnSchema")]
            return_schema: Option<serde_json::Value>,
            #[serde(rename = "isStreaming")]
            is_streaming: Option<bool>,
            #[serde(rename = "isCancellable")]
            is_cancellable: Option<bool>,
            #[serde(rename = "timeoutSeconds")]
            timeout_seconds: Option<u64>,
        }

        let helper = ToolHelper::deserialize(deserializer)?;

        // Convert inputSchema back to parameters
        let parameters = if let Some(input_schema) = helper.input_schema {
            if let Some(properties) = input_schema.get("properties").and_then(|p| p.as_object()) {
                let required: Vec<String> = input_schema
                    .get("required")
                    .and_then(|r| r.as_array())
                    .map(|arr| {
                        arr.iter()
                            .filter_map(|v| v.as_str().map(|s| s.to_string()))
                            .collect()
                    })
                    .unwrap_or_default();

                let mut params = Vec::new();
                for (name, schema) in properties {
                    let type_name = schema
                        .get("type")
                        .and_then(|t| t.as_str())
                        .map(|t| {
                            match t {
                                "string" => ToolParameterType::String,
                                "number" => ToolParameterType::Number,
                                "boolean" => ToolParameterType::Boolean,
                                "object" => ToolParameterType::Object,
                                "array" => ToolParameterType::Array,
                                _ => ToolParameterType::String, // Default to string for unknown types
                            }
                        })
                        .unwrap_or(ToolParameterType::String);

                    let enum_values = schema.get("enum").and_then(|e| e.as_array()).map(|arr| {
                        arr.iter()
                            .filter_map(|v| v.as_str().map(|s| s.to_string()))
                            .collect()
                    });

                    let default = schema.get("default").cloned();

                    params.push(ToolParameter {
                        name: name.clone(),
                        type_name,
                        description: None, // Description is not stored in JSON Schema
                        required: Some(required.contains(name)),
                        schema: Some(schema.clone()),
                        default,
                        enum_values,
                    });
                }

                Some(params)
            } else {
                None
            }
        } else {
            None
        };

        Ok(Tool {
            name: helper.name,
            description: helper.description,
            parameters,
            return_type: helper.return_type,
            return_schema: helper.return_schema,
            is_streaming: helper.is_streaming,
            is_cancellable: helper.is_cancellable,
            timeout_seconds: helper.timeout_seconds,
        })
    }
}

// Fix the JsonSchema implementation to avoid using 'gen' as parameter name
impl JsonSchema for Tool {
    fn schema_name() -> String {
        "Tool".to_string()
    }

    fn json_schema(
        schema_generator: &mut schemars::r#gen::SchemaGenerator,
    ) -> schemars::schema::Schema {
        <ToolSchema as JsonSchema>::json_schema(schema_generator)
    }
}

/// Builder for tool parameter
pub struct ToolParameterBuilder {
    name: String,
    type_name: ToolParameterType,
    description: Option<String>,
    required: Option<bool>,
    schema: Option<serde_json::Value>,
    default: Option<serde_json::Value>,
    enum_values: Option<Vec<String>>,
}

impl ToolParameterBuilder {
    /// Create a new parameter builder with the given name and type
    pub fn new(name: impl Into<String>, type_name: ToolParameterType) -> Self {
        Self {
            name: name.into(),
            type_name,
            description: None,
            required: None,
            schema: None,
            default: None,
            enum_values: None,
        }
    }

    /// Set the description for this parameter
    pub fn description(mut self, description: impl Into<String>) -> Self {
        self.description = Some(description.into());
        self
    }

    /// Mark this parameter as required or optional
    pub fn required(mut self, required: bool) -> Self {
        self.required = Some(required);
        self
    }

    /// Set a custom JSON schema for this parameter
    pub fn schema(mut self, schema: serde_json::Value) -> Self {
        self.schema = Some(schema);
        self
    }

    /// Set a default value for this parameter
    pub fn default<T: Serialize>(mut self, value: T) -> Result<Self, serde_json::Error> {
        self.default = Some(serde_json::to_value(value)?);
        Ok(self)
    }

    /// Set enum values for string parameters
    pub fn enum_values(mut self, values: Vec<impl Into<String>>) -> Self {
        self.enum_values = Some(values.into_iter().map(|v| v.into()).collect());
        self
    }

    /// Build the parameter
    pub fn build(self) -> ToolParameter {
        ToolParameter {
            name: self.name,
            type_name: self.type_name,
            description: self.description,
            required: self.required,
            schema: self.schema,
            default: self.default,
            enum_values: self.enum_values,
        }
    }
}

/// Builder for creating tools
pub struct ToolBuilder {
    name: String,
    description: String,
    parameters: Vec<ToolParameter>,
    return_type: Option<String>,
    return_schema: Option<serde_json::Value>,
    is_streaming: Option<bool>,
    is_cancellable: Option<bool>,
    timeout_seconds: Option<u64>,
}

impl ToolBuilder {
    /// Create a new tool builder with the given name and description
    pub fn new(name: impl Into<String>, description: impl Into<String>) -> Self {
        Self {
            name: name.into(),
            description: description.into(),
            parameters: Vec::new(),
            return_type: None,
            return_schema: None,
            is_streaming: None,
            is_cancellable: None,
            timeout_seconds: None,
        }
    }

    /// Add a parameter to this tool
    pub fn add_parameter(mut self, parameter: ToolParameter) -> Self {
        self.parameters.push(parameter);
        self
    }

    /// Starts building a parameter with the given name and type.
    /// This returns a tuple of (ToolBuilder, ToolParameterBuilder) to allow for fluent parameter definition
    /// while preserving the tool builder context.
    pub fn parameter(
        self,
        name: impl Into<String>,
        type_name: ToolParameterType,
    ) -> (Self, ToolParameterBuilder) {
        (self, ToolParameterBuilder::new(name, type_name))
    }

    /// Add the parameter built by the parameter builder
    pub fn with_parameter(mut self, parameter_builder: ToolParameterBuilder) -> Self {
        self.parameters.push(parameter_builder.build());
        self
    }

    /// Set the return type for this tool
    pub fn return_type(mut self, return_type: impl Into<String>) -> Self {
        self.return_type = Some(return_type.into());
        self
    }

    /// Set the return schema for this tool
    pub fn return_schema(mut self, schema: serde_json::Value) -> Self {
        self.return_schema = Some(schema);
        self
    }

    /// Set whether the tool streams results
    pub fn streaming(mut self, is_streaming: bool) -> Self {
        self.is_streaming = Some(is_streaming);
        self
    }

    /// Set whether the tool can be cancelled
    pub fn cancellable(mut self, is_cancellable: bool) -> Self {
        self.is_cancellable = Some(is_cancellable);
        self
    }

    /// Set the timeout in seconds
    pub fn timeout(mut self, seconds: u64) -> Self {
        self.timeout_seconds = Some(seconds);
        self
    }

    /// Build the tool
    pub fn build(self) -> Tool {
        Tool {
            name: self.name,
            description: self.description,
            parameters: if self.parameters.is_empty() {
                None
            } else {
                Some(self.parameters)
            },
            return_type: self.return_type,
            return_schema: self.return_schema,
            is_streaming: self.is_streaming,
            is_cancellable: self.is_cancellable,
            timeout_seconds: self.timeout_seconds,
        }
    }
}

// Helper traits and implementations to make the builder pattern more ergonomic

/// Helper trait for creating tool parameters with a specific type
pub trait IntoToolParameter {
    fn string_param(self, name: impl Into<String>) -> ToolParameterBuilder;
    fn number_param(self, name: impl Into<String>) -> ToolParameterBuilder;
    fn boolean_param(self, name: impl Into<String>) -> ToolParameterBuilder;
    fn object_param(self, name: impl Into<String>) -> ToolParameterBuilder;
    fn array_param(self, name: impl Into<String>) -> ToolParameterBuilder;
}

impl IntoToolParameter for &ToolBuilder {
    fn string_param(self, name: impl Into<String>) -> ToolParameterBuilder {
        ToolParameterBuilder::new(name, ToolParameterType::String)
    }

    fn number_param(self, name: impl Into<String>) -> ToolParameterBuilder {
        ToolParameterBuilder::new(name, ToolParameterType::Number)
    }

    fn boolean_param(self, name: impl Into<String>) -> ToolParameterBuilder {
        ToolParameterBuilder::new(name, ToolParameterType::Boolean)
    }

    fn object_param(self, name: impl Into<String>) -> ToolParameterBuilder {
        ToolParameterBuilder::new(name, ToolParameterType::Object)
    }

    fn array_param(self, name: impl Into<String>) -> ToolParameterBuilder {
        ToolParameterBuilder::new(name, ToolParameterType::Array)
    }
}

// Extension trait for ToolBuilder
pub trait ToolBuilderExt {
    fn add_string_parameter(self, name: impl Into<String>) -> (Box<Self>, ToolParameterBuilder);
    fn add_number_parameter(self, name: impl Into<String>) -> (Box<Self>, ToolParameterBuilder);
    fn add_boolean_parameter(self, name: impl Into<String>) -> (Box<Self>, ToolParameterBuilder);
    fn add_object_parameter(self, name: impl Into<String>) -> (Box<Self>, ToolParameterBuilder);
    fn add_array_parameter(self, name: impl Into<String>) -> (Box<Self>, ToolParameterBuilder);
}

impl ToolBuilderExt for ToolBuilder {
    fn add_string_parameter(self, name: impl Into<String>) -> (Box<Self>, ToolParameterBuilder) {
        let param_builder = ToolParameterBuilder::new(name, ToolParameterType::String);
        (Box::new(self), param_builder)
    }

    fn add_number_parameter(self, name: impl Into<String>) -> (Box<Self>, ToolParameterBuilder) {
        let param_builder = ToolParameterBuilder::new(name, ToolParameterType::Number);
        (Box::new(self), param_builder)
    }

    fn add_boolean_parameter(self, name: impl Into<String>) -> (Box<Self>, ToolParameterBuilder) {
        let param_builder = ToolParameterBuilder::new(name, ToolParameterType::Boolean);
        (Box::new(self), param_builder)
    }

    fn add_object_parameter(self, name: impl Into<String>) -> (Box<Self>, ToolParameterBuilder) {
        let param_builder = ToolParameterBuilder::new(name, ToolParameterType::Object);
        (Box::new(self), param_builder)
    }

    fn add_array_parameter(self, name: impl Into<String>) -> (Box<Self>, ToolParameterBuilder) {
        let param_builder = ToolParameterBuilder::new(name, ToolParameterType::Array);
        (Box::new(self), param_builder)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;

    #[test]
    fn test_tool_builder() {
        let tool = ToolBuilder::new("calculator", "Performs basic calculations")
            .add_parameter(
                ToolParameterBuilder::new("operation", ToolParameterType::String)
                    .description("Operation to perform")
                    .required(true)
                    .enum_values(vec!["add", "subtract", "multiply", "divide"])
                    .default("add")
                    .unwrap()
                    .build(),
            )
            .add_parameter(
                ToolParameterBuilder::new("a", ToolParameterType::Number)
                    .description("First operand")
                    .required(true)
                    .build(),
            )
            .add_parameter(
                ToolParameterBuilder::new("b", ToolParameterType::Number)
                    .description("Second operand")
                    .required(true)
                    .build(),
            )
            .return_type("object")
            .return_schema(json!({
                "type": "object",
                "properties": {
                    "result": { "type": "number" }
                },
                "required": ["result"]
            }))
            .streaming(false)
            .cancellable(false)
            .timeout(30)
            .build();

        assert_eq!(tool.name, "calculator");
        assert_eq!(tool.description, "Performs basic calculations");
        assert_eq!(tool.parameters.as_ref().unwrap().len(), 3);
        assert_eq!(tool.is_streaming, Some(false));
        assert_eq!(tool.is_cancellable, Some(false));
        assert_eq!(tool.timeout_seconds, Some(30));
    }

    #[test]
    fn test_tool_builder_with_extension_trait() {
        let (builder_box, param_builder) =
            ToolBuilder::new("calculator", "Performs basic calculations")
                .add_string_parameter("operation");

        let tool = (*builder_box)
            .with_parameter(
                param_builder
                    .description("Operation to perform")
                    .required(true)
                    .enum_values(vec!["add", "subtract", "multiply", "divide"])
                    .default("add")
                    .unwrap(),
            )
            .build();

        assert_eq!(tool.name, "calculator");
        assert_eq!(tool.parameters.as_ref().unwrap().len(), 1);
        assert_eq!(tool.parameters.as_ref().unwrap()[0].name, "operation");
    }
}


<file_info>
path: src/transport/websocket_server.rs
name: websocket_server.rs
</file_info>
//! Server-side WebSocket transport implementation using Axum
//!
//! This module provides a WebSocket server implementation built on Axum that:
//! - Accepts WebSocket connections from clients at the configured endpoint
//! - Routes messages between clients and the MCP server
//! - Supports bidirectional real-time communication
//! - Provides client tracking and management

use crate::errors::Error;
use crate::messages::Message;
use crate::transport::{ Transport, TransportLifecycleEvent };
use async_trait::async_trait;
use axum::{
    Extension,
    Router,
    extract::ws::{ Message as AxumWsMessage, WebSocket, WebSocketUpgrade },
    response::IntoResponse,
    routing::get,
};
use futures_util::{ SinkExt, StreamExt };
use http::HeaderValue;
use scopeguard;
use serde_json::{ self };
use std::collections::HashMap;
use std::net::SocketAddr;
use std::sync::{ Arc, Mutex };
use std::time::{ Duration, SystemTime };
use tokio::sync::{ broadcast, mpsc, oneshot };
use tower_http::cors::{ Any, CorsLayer };
use uuid::Uuid;

/// Maximum number of concurrent clients
const MAX_CLIENTS: usize = 100;

/// Default connection timeout
const DEFAULT_CONNECTION_TIMEOUT: Duration = Duration::from_secs(30);
/// Default heartbeat interval
const DEFAULT_HEARTBEAT_INTERVAL: Duration = Duration::from_secs(30);
/// Default reconnection delay
const DEFAULT_RECONNECT_DELAY: Duration = Duration::from_secs(2);

/// Configuration options for the WebSocket server
#[derive(Debug, Clone)]
pub struct WebSocketServerOptions {
    /// Address to bind the server to
    pub bind_address: SocketAddr,
    /// Path for the WebSocket endpoint
    pub websocket_path: String,
    /// Optional authentication token to validate requests
    pub auth_token: Option<String>,
    /// Connection timeout
    pub connection_timeout: Duration,
    /// Heartbeat interval
    pub heartbeat_interval: Duration,
    /// Whether to require authentication
    pub require_auth: bool,
    /// CORS allowed origins
    pub allowed_origins: Option<Vec<String>>,
}

impl Default for WebSocketServerOptions {
    fn default() -> Self {
        Self {
            bind_address: "127.0.0.1:9000".parse().unwrap(),
            websocket_path: "/ws".to_string(),
            auth_token: None,
            connection_timeout: DEFAULT_CONNECTION_TIMEOUT,
            heartbeat_interval: DEFAULT_HEARTBEAT_INTERVAL,
            require_auth: false,
            allowed_origins: None,
        }
    }
}

/// A client connection
#[derive(Debug)]
struct ClientConnection {
    id: String,
    connected_at: SystemTime,
    last_activity: SystemTime,
    sender: broadcast::Sender<String>, // Using String to avoid Clone bound issues
}

/// Shared application state for WebSocket server
#[derive(Clone)]
struct AppState {
    clients: Arc<Mutex<HashMap<String, ClientConnection>>>,
    message_tx: mpsc::Sender<(String, Result<Message, Error>)>,
    transport_lifecycle: Arc<Mutex<Vec<Box<dyn Fn(TransportLifecycleEvent) + Send + Sync>>>>,
}

/// Server-side implementation of the WebSocket transport using Axum
pub struct WebSocketServerTransport {
    /// Map of client IDs to connection info
    clients: Arc<Mutex<HashMap<String, ClientConnection>>>,
    /// Channel for incoming messages from clients
    message_rx: mpsc::Receiver<(String, Result<Message, Error>)>,
    /// Channel for sending messages to specific clients
    message_tx: mpsc::Sender<(String, Result<Message, Error>)>,
    /// Channel to notify when the server should shut down
    shutdown_tx: Option<oneshot::Sender<()>>,
    /// Server options
    options: WebSocketServerOptions,
    /// Server handle
    server_handle: Option<tokio::task::JoinHandle<()>>,
    /// Is the transport connected
    connected: bool,
    /// Lifecycle event handlers
    lifecycle_handlers: Arc<Mutex<Vec<Box<dyn Fn(TransportLifecycleEvent) + Send + Sync>>>>,
}

impl WebSocketServerTransport {
    /// Create a new WebSocket server transport with default options
    pub fn new() -> Self {
        Self::with_options(WebSocketServerOptions::default())
    }

    /// Create a new WebSocket server transport with the specified options
    pub fn with_options(options: WebSocketServerOptions) -> Self {
        let (message_tx, message_rx) = mpsc::channel(100);

        Self {
            clients: Arc::new(Mutex::new(HashMap::new())),
            message_rx,
            message_tx,
            shutdown_tx: None,
            options,
            server_handle: None,
            connected: false,
            lifecycle_handlers: Arc::new(Mutex::new(Vec::new())),
        }
    }

    /// Notify lifecycle event handlers
    fn notify_lifecycle(&self, event: TransportLifecycleEvent) {
        let handlers = self.lifecycle_handlers.lock().unwrap();
        for handler in handlers.iter() {
            handler(event.clone());
        }
    }

    /// Start the WebSocket server
    pub async fn start(&mut self) -> Result<(), Error> {
        if self.connected {
            return Err(Error::Transport("WebSocket server already running".to_string()));
        }

        // Notify Starting lifecycle event
        self.notify_lifecycle(TransportLifecycleEvent::Starting);

        // Create the app state
        let app_state = AppState {
            clients: self.clients.clone(),
            message_tx: self.message_tx.clone(),
            transport_lifecycle: self.lifecycle_handlers.clone(),
        };

        // Create a CORS layer
        let cors = match &self.options.allowed_origins {
            Some(origins) => {
                let mut layer = CorsLayer::new();
                for origin in origins {
                    layer = layer.allow_origin(origin.parse::<HeaderValue>().unwrap());
                }
                layer.allow_methods(Any).allow_headers(Any).max_age(Duration::from_secs(86400))
            }
            None => CorsLayer::permissive(),
        };

        // Build the router
        let app = Router::new()
            .route(&self.options.websocket_path, get(ws_handler))
            .layer(Extension(app_state))
            .layer(cors);

        // Create a shutdown channel
        let (shutdown_tx, shutdown_rx) = oneshot::channel::<()>();
        self.shutdown_tx = Some(shutdown_tx);

        // Start the server
        let bind_address = self.options.bind_address;
        let server_handle = tokio::spawn(async move {
            tracing::info!("Starting WebSocket server on {}", bind_address);

            // Build our application with the specified routes
            let listener = tokio::net::TcpListener::bind(&bind_address).await.unwrap();
            tracing::info!("Listening on {}", bind_address);

            // Start the Axum server
            axum::serve(listener, app)
                .with_graceful_shutdown(async {
                    let _ = shutdown_rx.await;
                    tracing::info!("WebSocket server shutting down");
                }).await
                .unwrap_or_else(|e| {
                    tracing::error!("Server error: {}", e);
                })
        });

        self.server_handle = Some(server_handle);
        self.connected = true;
        tracing::info!(
            "WebSocket server started at ws://{}{}",
            self.options.bind_address,
            self.options.websocket_path
        );

        // Notify Started lifecycle event
        self.notify_lifecycle(TransportLifecycleEvent::Started);

        Ok(())
    }

    /// Get the number of connected clients
    pub fn connected_clients(&self) -> usize {
        self.clients.lock().unwrap().len()
    }
}

/// WebSocket connection handler
async fn ws_handler(
    ws: WebSocketUpgrade,
    Extension(state): Extension<AppState>
) -> impl IntoResponse {
    // Upgrade the connection to WebSocket
    ws.on_upgrade(move |socket| handle_socket(socket, state))
}

/// Handle WebSocket connection
async fn handle_socket(socket: WebSocket, state: AppState) {
    let clients = state.clients.clone();
    let message_tx = state.message_tx.clone();
    let lifecycle_handlers = state.transport_lifecycle.clone();

    // Check if we've reached maximum clients
    {
        let clients_map = clients.lock().unwrap();
        if clients_map.len() >= MAX_CLIENTS {
            // Too many clients connected
            tracing::warn!("Maximum client connections reached");
            return;
        }
    }

    // Generate a client ID
    let client_id = Uuid::new_v4().to_string();

    // Create broadcast channel for this client
    let (sender, _) = broadcast::channel(100);

    // Register the client
    {
        let mut clients_map = clients.lock().unwrap();
        clients_map.insert(client_id.clone(), ClientConnection {
            id: client_id.clone(),
            connected_at: SystemTime::now(),
            last_activity: SystemTime::now(),
            sender: sender.clone(),
        });
    }

    tracing::info!("New WebSocket client connected: {}", client_id);

    // Notify client connected lifecycle event
    {
        let handlers = lifecycle_handlers.lock().unwrap();
        for handler in handlers.iter() {
            handler(TransportLifecycleEvent::ClientConnected(client_id.clone()));
        }
    }

    // Split the socket
    let (mut sender_socket, mut receiver_socket) = socket.split();

    // Clone for cleanup
    let clients_for_cleanup = clients.clone();
    let client_id_for_cleanup = client_id.clone();
    let lifecycle_for_cleanup = lifecycle_handlers.clone();

    // Ensure client is removed when connection is closed
    let _cleanup = scopeguard::guard((), move |_| {
        let mut clients_map = clients_for_cleanup.lock().unwrap();
        if clients_map.remove(&client_id_for_cleanup).is_some() {
            tracing::info!("WebSocket client disconnected: {}", client_id_for_cleanup);

            // Notify client disconnected lifecycle event
            let handlers = lifecycle_for_cleanup.lock().unwrap();
            for handler in handlers.iter() {
                handler(TransportLifecycleEvent::ClientDisconnected(client_id_for_cleanup.clone()));
            }
        }
    });

    // Create receiver for messages to send to this client
    let mut client_receiver = {
        let clients_map = clients.lock().unwrap();
        if let Some(client) = clients_map.get(&client_id) {
            client.sender.subscribe()
        } else {
            return; // Client already disconnected
        }
    };

    // Process incoming messages from the client
    let client_id_clone = client_id.clone();
    let message_tx_clone = message_tx.clone();
    let receive_task = tokio::spawn(async move {
        while let Some(result) = receiver_socket.next().await {
            match result {
                Ok(msg) => {
                    // Handle message from client
                    match msg {
                        AxumWsMessage::Text(text) => {
                            match serde_json::from_str::<Message>(&text) {
                                Ok(message) => {
                                    // Forward message to MCP server
                                    if
                                        message_tx_clone
                                            .send((client_id_clone.clone(), Ok(message))).await
                                            .is_err()
                                    {
                                        break;
                                    }
                                }
                                Err(e) => {
                                    tracing::error!("Failed to parse message: {}", e);
                                    // Send error to MCP server
                                    if
                                        message_tx_clone
                                            .send((
                                                client_id_clone.clone(),
                                                Err(Error::Json(e)),
                                            )).await
                                            .is_err()
                                    {
                                        break;
                                    }
                                }
                            }
                        }
                        AxumWsMessage::Binary(data) => {
                            // Try to parse binary data as JSON message
                            if let Ok(text) = std::str::from_utf8(&data) {
                                match serde_json::from_str::<Message>(text) {
                                    Ok(message) => {
                                        if
                                            message_tx_clone
                                                .send((client_id_clone.clone(), Ok(message))).await
                                                .is_err()
                                        {
                                            break;
                                        }
                                    }
                                    Err(e) => {
                                        tracing::error!("Failed to parse binary message: {}", e);
                                        if
                                            message_tx_clone
                                                .send((
                                                    client_id_clone.clone(),
                                                    Err(Error::Json(e)),
                                                )).await
                                                .is_err()
                                        {
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                        AxumWsMessage::Close(_) => {
                            break;
                        }
                        // Ignore other message types like Ping/Pong
                        _ => {}
                    }
                }
                Err(e) => {
                    tracing::error!("WebSocket error: {}", e);
                    break;
                }
            }
        }
    });

    // Forward messages from server to client
    let send_task = tokio::spawn(async move {
        while let Ok(json) = client_receiver.recv().await {
            if sender_socket.send(AxumWsMessage::Text(json.into())).await.is_err() {
                break;
            }
        }
    });

    // Wait for either task to complete
    tokio::select! {
        _ = receive_task => {}
        _ = send_task => {}
    }
}

// Implement the Transport trait for WebSocketServerTransport
#[async_trait]
impl Transport for WebSocketServerTransport {
    async fn receive(&mut self) -> Result<(Option<String>, Message), Error> {
        // Start the server if it's not already running
        if !self.connected {
            self.start().await?;
        }

        match self.message_rx.recv().await {
            Some((client_id, result)) => {
                // Update client last activity time
                {
                    let mut clients_map = self.clients.lock().unwrap();
                    if let Some(client) = clients_map.get_mut(&client_id) {
                        client.last_activity = SystemTime::now();
                    }
                }

                // Return the message or error, along with client ID
                result.map(|msg| (Some(client_id), msg))
            }
            None => Err(Error::Transport("WebSocket server channel closed".to_string())),
        }
    }

    async fn send_to(&mut self, client_id: &str, message: &Message) -> Result<(), Error> {
        if !self.connected {
            return Err(Error::Transport("WebSocket server not running".to_string()));
        }

        // Serialize the message
        let json = serde_json::to_string(message).map_err(Error::Json)?;

        // Find the specific client
        let clients_map = self.clients.lock().unwrap();
        if let Some(client) = clients_map.get(client_id) {
            // Send the message to only this client
            if client.sender.send(json).is_err() {
                return Err(
                    Error::Transport(format!("Failed to send message to client: {}", client_id))
                );
            }
            Ok(())
        } else {
            Err(Error::Transport(format!("Client not found: {}", client_id)))
        }
    }

    async fn send(&mut self, message: &Message) -> Result<(), Error> {
        if !self.connected {
            return Err(Error::Transport("WebSocket server not running".to_string()));
        }

        // Serialize the message
        let json = serde_json::to_string(message).map_err(Error::Json)?;

        // Send to all clients
        {
            let clients_map = self.clients.lock().unwrap();
            if clients_map.is_empty() {
                return Err(Error::Transport("No connected clients".to_string()));
            }

            // Broadcast to all clients
            for (_, client) in clients_map.iter() {
                let _ = client.sender.send(json.clone());
            }
        }

        Ok(())
    }

    async fn is_connected(&self) -> bool {
        self.connected
    }

    async fn close(&mut self) -> Result<(), Error> {
        if !self.connected {
            return Ok(());
        }

        // Notify Closing lifecycle event
        self.notify_lifecycle(TransportLifecycleEvent::Closing);

        // Trigger server shutdown
        if let Some(tx) = self.shutdown_tx.take() {
            let _ = tx.send(());
        }

        // Wait for server to shut down
        if let Some(handle) = self.server_handle.take() {
            let _ = handle.await;
        }

        // Clear all clients
        {
            let mut clients_map = self.clients.lock().unwrap();
            clients_map.clear();
        }

        self.connected = false;
        tracing::info!("WebSocket server stopped");

        // Notify Closed lifecycle event
        self.notify_lifecycle(TransportLifecycleEvent::Closed);

        Ok(())
    }

    /// Register a lifecycle event handler
    fn register_lifecycle_handler(
        &mut self,
        handler: Box<dyn Fn(TransportLifecycleEvent) + Send + Sync>
    ) {
        let mut handlers = self.lifecycle_handlers.lock().unwrap();
        handlers.push(handler);
    }
}


<file_info>
path: src/types/initialize.rs
name: initialize.rs
</file_info>
//! MCP Initialization Types
//!
//! This module defines types related to the initialization phase of the MCP protocol,
//! such as `InitializeRequestParams` and `InitializeResult`, ensuring proper setup and capability
//! negotiation between client and server.

use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

/// Parameters for the initialize request
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct InitializeRequestParams {
    /// The version of the MCP protocol, e.g., "2024-11-05"
    #[serde(rename = "protocolVersion")]
    pub protocol_version: String,
    /// Client capabilities for feature negotiation
    pub capabilities: ClientCapabilities,
    /// Information about the client implementation
    #[serde(rename = "clientInfo")]
    pub client_info: Option<Implementation>,
}

/// Result of the initialize request
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct InitializeResult {
    /// The negotiated protocol version
    #[serde(rename = "protocolVersion")]
    pub protocol_version: String,
    /// Server capabilities for feature negotiation
    pub capabilities: ServerCapabilities,
    /// Information about the server implementation
    #[serde(rename = "serverInfo")]
    pub server_info: Option<Implementation>,
    /// Optional instructions for the client
    #[serde(skip_serializing_if = "Option::is_none")]
    pub instructions: Option<String>,
}

/// Information about an implementation (client or server)
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct Implementation {
    /// Name of the implementation
    pub name: String,
    /// Version of the implementation
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// Client capabilities
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct ClientCapabilities {
    /// Root capabilities
    #[serde(skip_serializing_if = "Option::is_none")]
    pub roots: Option<RootCapabilities>,
    /// Sampling capabilities
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sampling: Option<SamplingCapabilities>,
    /// Experimental capabilities
    #[serde(skip_serializing_if = "Option::is_none")]
    pub experimental: Option<serde_json::Value>,
}

/// Server capabilities
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema, Default)]
pub struct ServerCapabilities {
    /// Resource capabilities
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resources: Option<ResourceCapabilities>,
    /// Tool capabilities
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tools: Option<ToolCapabilities>,
    /// Prompt capabilities
    #[serde(skip_serializing_if = "Option::is_none")]
    pub prompts: Option<PromptCapabilities>,
    /// Logging capabilities
    #[serde(skip_serializing_if = "Option::is_none")]
    pub logging: Option<LoggingCapabilities>,
    /// Experimental capabilities
    #[serde(skip_serializing_if = "Option::is_none")]
    pub experimental: Option<serde_json::Value>,
}

/// Root capabilities
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub struct RootCapabilities {
    /// Support for list changes
    #[serde(rename = "listChanged")]
    pub list_changed: bool,
}

/// Sampling capabilities
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub struct SamplingCapabilities {}

/// Resource capabilities
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub struct ResourceCapabilities {
    /// Support for resource subscription
    pub subscribe: bool,
    /// Support for list changes
    #[serde(rename = "listChanged")]
    pub list_changed: bool,
}

/// Prompt capabilities
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub struct PromptCapabilities {
    /// Support for list changes
    #[serde(rename = "listChanged")]
    pub list_changed: bool,
}

/// Tool capabilities
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub struct ToolCapabilities {
    /// Support for list changes
    #[serde(rename = "listChanged")]
    pub list_changed: bool,
}

/// Logging capabilities
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub struct LoggingCapabilities {
    // Custom logging fields can be added here as needed
}


<file_info>
path: src/lifecycle.rs
name: lifecycle.rs
</file_info>
//! MCP Lifecycle Management
//!
//! This module implements lifecycle management for the Model Context Protocol (MCP),
//! handling initialization, operation, and shutdown phases with strict state transitions
//! and capability negotiation.

use std::any::Any;
use std::fmt;
use std::sync::{Arc, RwLock};
use std::time::Duration;

use futures::future::BoxFuture;
use tokio::time::timeout;
use tracing::{debug, error, info};

use crate::errors::Error;
use crate::messages::GenericRequest;
use crate::types::initialize::{
    ClientCapabilities, Implementation, InitializeRequestParams, InitializeResult,
    LoggingCapabilities, PromptCapabilities, ResourceCapabilities, ServerCapabilities,
    ToolCapabilities,
};

/// Default timeout for initialization phase in seconds
const DEFAULT_INIT_TIMEOUT_SECS: u64 = 30;

/// Default timeout for shutdown phase in seconds
const DEFAULT_SHUTDOWN_TIMEOUT_SECS: u64 = 10;

/// Supported protocol versions
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ProtocolVersion {
    /// Protocol version 2024-11-05
    V20241105,
    // Future versions will be added here
}

impl ProtocolVersion {
    /// Convert from string representation
    pub fn from_str(version: &str) -> Result<Self, Error> {
        match version {
            "2024-11-05" => Ok(ProtocolVersion::V20241105),
            _ => Err(Error::VersionIncompatibility(format!(
                "Unsupported protocol version: {}. Supported versions: {}",
                version,
                Self::supported_versions().join(", ")
            ))),
        }
    }

    /// Convert to string representation
    pub fn to_str(&self) -> &'static str {
        match self {
            ProtocolVersion::V20241105 => "2024-11-05",
        }
    }

    /// Get all supported versions
    pub fn supported_versions() -> Vec<&'static str> {
        vec!["2024-11-05"]
    }

    /// Get the latest supported version
    pub fn latest() -> Self {
        ProtocolVersion::V20241105
    }
}

impl fmt::Display for ProtocolVersion {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.to_str())
    }
}

/// Server lifecycle states
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ServerLifecycleState {
    /// Server is created but not initialized
    Created,

    /// Server has received an initialize request and is processing it
    Initializing,

    /// Server has responded to initialize but hasn't received initialized notification
    Initialized,

    /// Server has received initialized notification and is fully operational
    Running,

    /// Server is shutting down
    ShuttingDown,

    /// Server has shut down
    Terminated,
}

impl ServerLifecycleState {
    /// Check if a method is allowed in the current state
    pub fn can_handle_method(&self, method: &str) -> bool {
        match self {
            ServerLifecycleState::Created => {
                // Only initialize and ping methods are allowed before initialization
                method == "initialize" || method == "ping"
            }
            ServerLifecycleState::Initializing => {
                // Only ping is allowed during initialization
                method == "ping"
            }
            ServerLifecycleState::Initialized => {
                // Only initialized notification, ping, and logging are allowed before running
                method == "notifications/initialized"
                    || method == "initialized"
                    || method == "ping"
                    || method.starts_with("logging/")
            }
            ServerLifecycleState::Running => {
                // All methods are allowed in running state, except initialize
                method != "initialize" && method != "notifications/initialized"
            }
            ServerLifecycleState::ShuttingDown | ServerLifecycleState::Terminated => {
                // Only ping allowed during shutdown or after termination
                method == "ping"
            }
        }
    }

    /// Get valid next states from current state
    pub fn valid_next_states(&self) -> Vec<ServerLifecycleState> {
        match self {
            ServerLifecycleState::Created => vec![ServerLifecycleState::Initializing],
            ServerLifecycleState::Initializing => vec![
                ServerLifecycleState::Initialized,
                ServerLifecycleState::ShuttingDown,
            ],
            ServerLifecycleState::Initialized => vec![
                ServerLifecycleState::Running,
                ServerLifecycleState::ShuttingDown,
            ],
            ServerLifecycleState::Running => vec![ServerLifecycleState::ShuttingDown],
            ServerLifecycleState::ShuttingDown => vec![ServerLifecycleState::Terminated],
            ServerLifecycleState::Terminated => vec![],
        }
    }

    /// Check if transition to next state is valid
    pub fn can_transition_to(&self, next_state: ServerLifecycleState) -> bool {
        self.valid_next_states().contains(&next_state)
    }
}

impl fmt::Display for ServerLifecycleState {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ServerLifecycleState::Created => write!(f, "Created"),
            ServerLifecycleState::Initializing => write!(f, "Initializing"),
            ServerLifecycleState::Initialized => write!(f, "Initialized"),
            ServerLifecycleState::Running => write!(f, "Running"),
            ServerLifecycleState::ShuttingDown => write!(f, "ShuttingDown"),
            ServerLifecycleState::Terminated => write!(f, "Terminated"),
        }
    }
}

/// Client lifecycle states
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ClientLifecycleState {
    /// Client is created but not connected
    Created,

    /// Client has connected and is sending initialize request
    Connecting,

    /// Client has sent initialize request and is waiting for response
    Initializing,

    /// Client has received initialize response but hasn't sent initialized notification
    Initialized,

    /// Client has sent initialized notification and is fully operational
    Running,

    /// Client is shutting down
    ShuttingDown,

    /// Client has shut down
    Terminated,
}

impl ClientLifecycleState {
    /// Check if a method can be called in the current state
    pub fn can_call_method(&self, method: &str) -> bool {
        match self {
            ClientLifecycleState::Created => false, // Not connected yet
            ClientLifecycleState::Connecting => {
                // Only ping is allowed during connection
                method == "ping"
            }
            ClientLifecycleState::Initializing => {
                // Only ping is allowed during initialization
                method == "ping"
            }
            ClientLifecycleState::Initialized => {
                // Only initialized notification and ping are allowed
                method == "notifications/initialized" || method == "ping"
            }
            ClientLifecycleState::Running => {
                // All methods are allowed in running state, except initialize and initialized
                method != "initialize" && method != "notifications/initialized"
            }
            ClientLifecycleState::ShuttingDown | ClientLifecycleState::Terminated => {
                // Only ping is allowed during shutdown
                method == "ping"
            }
        }
    }

    /// Get valid next states from current state
    pub fn valid_next_states(&self) -> Vec<ClientLifecycleState> {
        match self {
            ClientLifecycleState::Created => vec![ClientLifecycleState::Connecting],
            ClientLifecycleState::Connecting => vec![
                ClientLifecycleState::Initializing,
                ClientLifecycleState::ShuttingDown,
            ],
            ClientLifecycleState::Initializing => vec![
                ClientLifecycleState::Initialized,
                ClientLifecycleState::ShuttingDown,
            ],
            ClientLifecycleState::Initialized => vec![
                ClientLifecycleState::Running,
                ClientLifecycleState::ShuttingDown,
            ],
            ClientLifecycleState::Running => vec![ClientLifecycleState::ShuttingDown],
            ClientLifecycleState::ShuttingDown => vec![ClientLifecycleState::Terminated],
            ClientLifecycleState::Terminated => vec![],
        }
    }

    /// Check if transition to next state is valid
    pub fn can_transition_to(&self, next_state: ClientLifecycleState) -> bool {
        self.valid_next_states().contains(&next_state)
    }
}

impl fmt::Display for ClientLifecycleState {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ClientLifecycleState::Created => write!(f, "Created"),
            ClientLifecycleState::Connecting => write!(f, "Connecting"),
            ClientLifecycleState::Initializing => write!(f, "Initializing"),
            ClientLifecycleState::Initialized => write!(f, "Initialized"),
            ClientLifecycleState::Running => write!(f, "Running"),
            ClientLifecycleState::ShuttingDown => write!(f, "ShuttingDown"),
            ClientLifecycleState::Terminated => write!(f, "Terminated"),
        }
    }
}

/// Request context for lifecycle-aware request processing
#[derive(Clone)]
pub struct RequestContext {
    /// Unique request identifier
    pub request_id: i32,

    /// Client identifier (for server-side use)
    pub client_id: Option<String>,

    /// Method being called
    pub method: String,

    /// Lifecycle context data storage
    lifecycle_context: Arc<RwLock<Box<dyn Any + Send + Sync>>>,

    /// Negotiated protocol version
    protocol_version: ProtocolVersion,

    /// Negotiated capabilities
    capabilities: Arc<NegotiatedCapabilities>,
}

impl RequestContext {
    /// Create a new request context
    pub fn new(
        request_id: i32,
        method: String,
        client_id: Option<String>,
        lifecycle_context: Arc<RwLock<Box<dyn Any + Send + Sync>>>,
        protocol_version: ProtocolVersion,
        capabilities: Arc<NegotiatedCapabilities>,
    ) -> Self {
        Self {
            request_id,
            client_id,
            method,
            lifecycle_context,
            protocol_version,
            capabilities,
        }
    }

    /// Get the negotiated protocol version
    pub fn protocol_version(&self) -> ProtocolVersion {
        self.protocol_version
    }

    /// Get the negotiated capabilities
    pub fn capabilities(&self) -> &NegotiatedCapabilities {
        &self.capabilities
    }

    /// Get typed access to the lifecycle context
    pub fn get_context<T: 'static>(&self) -> Option<T>
    where
        T: Clone,
    {
        let context = self.lifecycle_context.read().unwrap();
        context.downcast_ref::<T>().cloned()
    }

    /// Validate that a capability is supported
    pub fn validate_capability(&self, capability_type: &str) -> Result<(), Error> {
        let supported = match capability_type {
            "resources" => self.capabilities.supports_resources,
            "prompts" => self.capabilities.supports_prompts,
            "tools" => self.capabilities.supports_tools,
            "logging" => self.capabilities.supports_logging,
            _ => false,
        };

        if !supported {
            Err(Error::Validation(format!(
                "The '{}' capability is not supported in this session",
                capability_type
            )))
        } else {
            Ok(())
        }
    }
}

/// Negotiated capabilities after initialization
#[derive(Debug, Clone)]
pub struct NegotiatedCapabilities {
    /// Whether resources are supported
    pub supports_resources: bool,

    /// Whether resource subscription is supported
    pub supports_resource_subscription: bool,

    /// Whether resource list change notifications are supported
    pub supports_resource_list_changed: bool,

    /// Whether prompts are supported
    pub supports_prompts: bool,

    /// Whether prompt list change notifications are supported
    pub supports_prompt_list_changed: bool,

    /// Whether tools are supported
    pub supports_tools: bool,

    /// Whether tool list change notifications are supported
    pub supports_tool_list_changed: bool,

    /// Whether logging is supported
    pub supports_logging: bool,

    /// Whether root capabilities are supported by the client
    pub supports_roots: bool,

    /// Whether root list change notifications are supported by the client
    pub supports_root_list_changed: bool,

    /// Whether sampling capabilities are supported by the client
    pub supports_sampling: bool,
}

impl NegotiatedCapabilities {
    /// Create capabilities from server and client capabilities
    pub fn from_capabilities(
        server_capabilities: &ServerCapabilities,
        client_capabilities: &ClientCapabilities,
    ) -> Self {
        // Extract capabilities from server capabilities
        let supports_resources = server_capabilities.resources.is_some();
        let supports_resource_subscription = server_capabilities
            .resources
            .as_ref()
            .map(|r| r.subscribe)
            .unwrap_or(false);
        let supports_resource_list_changed = server_capabilities
            .resources
            .as_ref()
            .map(|r| r.list_changed)
            .unwrap_or(false);

        let supports_prompts = server_capabilities.prompts.is_some();
        let supports_prompt_list_changed = server_capabilities
            .prompts
            .as_ref()
            .map(|p| p.list_changed)
            .unwrap_or(false);

        let supports_tools = server_capabilities.tools.is_some();
        let supports_tool_list_changed = server_capabilities
            .tools
            .as_ref()
            .map(|t| t.list_changed)
            .unwrap_or(false);

        let supports_logging = server_capabilities.logging.is_some();

        // Extract capabilities from client capabilities
        let supports_roots = client_capabilities.roots.is_some();
        let supports_root_list_changed = client_capabilities
            .roots
            .as_ref()
            .map(|r| r.list_changed)
            .unwrap_or(false);

        let supports_sampling = client_capabilities.sampling.is_some();

        Self {
            supports_resources,
            supports_resource_subscription,
            supports_resource_list_changed,
            supports_prompts,
            supports_prompt_list_changed,
            supports_tools,
            supports_tool_list_changed,
            supports_logging,
            supports_roots,
            supports_root_list_changed,
            supports_sampling,
        }
    }
}

/// Trait for lifecycle context implementations
pub trait LifecycleContext: Send + Sync + Clone {
    /// Called when the server/client is starting up
    fn on_startup(&mut self) -> Result<(), Error> {
        Ok(())
    }

    /// Called after successful initialization
    fn on_initialized(
        &mut self,
        protocol_version: ProtocolVersion,
        capabilities: &NegotiatedCapabilities,
    ) -> Result<(), Error> {
        Ok(())
    }

    /// Called before processing a request
    fn before_request(&mut self, context: &RequestContext) -> Result<(), Error> {
        Ok(())
    }

    /// Called after processing a request
    fn after_request<T>(
        &mut self,
        context: &RequestContext,
        result: &Result<T, Error>,
    ) -> Result<(), Error> {
        Ok(())
    }

    /// Called when starting the shutdown process
    fn on_shutdown(&mut self) -> Result<(), Error> {
        Ok(())
    }
}

/// Lifecycle manager for MCP protocol
pub struct LifecycleManager<C: LifecycleContext> {
    /// Current lifecycle state
    state: RwLock<ServerLifecycleState>,

    /// Context data for the lifecycle
    context: Arc<RwLock<Box<dyn Any + Send + Sync>>>,

    /// Strongly typed context
    typed_context: RwLock<C>,

    /// Negotiated protocol version
    protocol_version: RwLock<Option<ProtocolVersion>>,

    /// Negotiated capabilities
    capabilities: Arc<RwLock<Option<NegotiatedCapabilities>>>,

    /// Initialization timeout
    init_timeout: Duration,

    /// Shutdown timeout
    shutdown_timeout: Duration,
}

impl<C: LifecycleContext + 'static> LifecycleManager<C> {
    /// Create a new lifecycle manager
    pub fn new(context: C) -> Self {
        let context_box: Box<dyn Any + Send + Sync> = Box::new(context.clone());

        Self {
            state: RwLock::new(ServerLifecycleState::Created),
            context: Arc::new(RwLock::new(context_box)),
            typed_context: RwLock::new(context),
            protocol_version: RwLock::new(None),
            capabilities: Arc::new(RwLock::new(None)),
            init_timeout: Duration::from_secs(DEFAULT_INIT_TIMEOUT_SECS),
            shutdown_timeout: Duration::from_secs(DEFAULT_SHUTDOWN_TIMEOUT_SECS),
        }
    }

    /// Set the initialization timeout
    pub fn with_init_timeout(mut self, timeout: Duration) -> Self {
        self.init_timeout = timeout;
        self
    }

    /// Set the shutdown timeout
    pub fn with_shutdown_timeout(mut self, timeout: Duration) -> Self {
        self.shutdown_timeout = timeout;
        self
    }

    /// Start the lifecycle (calls on_startup)
    pub async fn start(&self) -> Result<(), Error> {
        // Call on_startup on the context
        let mut context = self.typed_context.write().unwrap();
        context.on_startup()?;

        debug!("Lifecycle startup complete - waiting for initialization");
        Ok(())
    }

    /// Get the current state
    pub fn current_state(&self) -> ServerLifecycleState {
        *self.state.read().unwrap()
    }

    /// Check if the server can handle a method in the current state
    pub fn can_handle_method(&self, method: &str) -> bool {
        let state = *self.state.read().unwrap();
        state.can_handle_method(method)
    }

    /// Get the negotiated protocol version
    pub fn protocol_version(&self) -> Option<ProtocolVersion> {
        *self.protocol_version.read().unwrap()
    }

    /// Get the negotiated capabilities
    pub fn capabilities(&self) -> Option<NegotiatedCapabilities> {
        self.capabilities.read().unwrap().clone()
    }

    /// Create a request context for a request
    pub fn create_request_context(
        &self,
        request_id: i32,
        method: &str,
        client_id: Option<&str>,
    ) -> Result<RequestContext, Error> {
        let protocol_version = self
            .protocol_version()
            .ok_or_else(|| Error::Initialization("Server not initialized".to_string()))?;

        let capabilities = self
            .capabilities()
            .ok_or_else(|| Error::Initialization("Server not initialized".to_string()))?;

        let capabilities_arc = Arc::new(capabilities);

        Ok(RequestContext::new(
            request_id,
            method.to_string(),
            client_id.map(|s| s.to_string()),
            self.context.clone(),
            protocol_version,
            capabilities_arc,
        ))
    }

    /// Transition to a new state if valid
    fn transition_to(&self, new_state: ServerLifecycleState) -> Result<(), Error> {
        let mut state = self.state.write().unwrap();
        if !state.can_transition_to(new_state) {
            return Err(Error::Initialization(format!(
                "Invalid state transition from {} to {}",
                state, new_state
            )));
        }

        debug!("Lifecycle state transition: {} -> {}", *state, new_state);
        *state = new_state;
        Ok(())
    }

    /// Handle the initialization request
    pub async fn handle_initialize(
        &self,
        request: &GenericRequest,
    ) -> Result<InitializeResult, Error> {
        // Verify we're in the right state
        {
            let state = *self.state.read().unwrap();
            if state != ServerLifecycleState::Created {
                return Err(Error::Initialization(
                    "Server already initialized".to_string(),
                ));
            }
        }

        // Transition to initializing state
        self.transition_to(ServerLifecycleState::Initializing)?;

        // Parse the initialize parameters
        let params: InitializeRequestParams = match &request.params {
            Some(params) => serde_json::from_value(params.clone())
                .map_err(|e| Error::InvalidParams(format!("Invalid initialize params: {}", e)))?,
            None => {
                return Err(Error::InvalidParams(
                    "Missing initialize params".to_string(),
                ));
            }
        };

        // Process protocol version
        let protocol_version = match ProtocolVersion::from_str(&params.protocol_version) {
            Ok(version) => version,
            Err(_) => {
                // We don't support the requested version, use our latest
                let our_version = ProtocolVersion::latest();
                info!(
                    "Client requested unsupported protocol version: {}, using {}",
                    params.protocol_version, our_version
                );
                our_version
            }
        };

        // Store the negotiated protocol version
        {
            let mut version = self.protocol_version.write().unwrap();
            *version = Some(protocol_version);
        }

        // Generate server capabilities
        // In a real implementation, this would be provided by the server
        let server_capabilities = ServerCapabilities {
            resources: Some(ResourceCapabilities {
                subscribe: true,
                list_changed: true,
            }),
            tools: Some(ToolCapabilities { list_changed: true }),
            prompts: Some(PromptCapabilities { list_changed: true }),
            logging: Some(LoggingCapabilities {}),
            experimental: None,
        };

        // Calculate negotiated capabilities
        let negotiated_capabilities =
            NegotiatedCapabilities::from_capabilities(&server_capabilities, &params.capabilities);

        // Store negotiated capabilities
        {
            let mut caps = self.capabilities.write().unwrap();
            *caps = Some(negotiated_capabilities.clone());
        }

        // Transition to initialized state
        self.transition_to(ServerLifecycleState::Initialized)?;

        // Notify the context that we've been initialized
        {
            let mut context = self.typed_context.write().unwrap();
            context.on_initialized(protocol_version, &negotiated_capabilities)?;
        }

        // Create initialize result
        let result = InitializeResult {
            protocol_version: protocol_version.to_str().to_string(),
            capabilities: server_capabilities,
            server_info: Some(Implementation {
                name: "MCP-rs Server".to_string(),
                version: Some(env!("CARGO_PKG_VERSION").to_string()),
            }),
            instructions: Some("MCP-rs Server is now ready to use".to_string()),
        };

        debug!(
            "Server initialized with protocol version {}",
            protocol_version
        );

        Ok(result)
    }

    /// Handle the initialized notification
    pub async fn handle_initialized(&self) -> Result<(), Error> {
        // Verify we're in the right state
        {
            let state = *self.state.read().unwrap();
            if state != ServerLifecycleState::Initialized {
                return Err(Error::Initialization(
                    "Cannot handle initialized notification in current state".to_string(),
                ));
            }
        }

        // Transition to running state
        self.transition_to(ServerLifecycleState::Running)?;

        debug!("Server is now in running state");

        Ok(())
    }

    /// Start the shutdown process
    pub async fn shutdown(&self) -> Result<(), Error> {
        // Transition to shutting down state
        let current_state = self.current_state();
        if current_state != ServerLifecycleState::ShuttingDown
            && current_state != ServerLifecycleState::Terminated
        {
            self.transition_to(ServerLifecycleState::ShuttingDown)?;

            // Notify the context that we're shutting down
            {
                let mut context = self.typed_context.write().unwrap();
                context.on_shutdown()?;
            }

            // Wait for shutdown to complete or timeout
            let shutdown_task = async {
                // Add any shutdown logic here
                tokio::time::sleep(Duration::from_millis(100)).await;

                // Transition to terminated state
                self.transition_to(ServerLifecycleState::Terminated)?;
                debug!("Server has terminated");

                Ok::<(), Error>(())
            };

            match timeout(self.shutdown_timeout, shutdown_task).await {
                Ok(result) => result,
                Err(_) => {
                    error!(
                        "Server shutdown timed out after {:?}",
                        self.shutdown_timeout
                    );

                    // Force transition to terminated
                    let mut state = self.state.write().unwrap();
                    *state = ServerLifecycleState::Terminated;

                    Err(Error::Timeout("Server shutdown timed out".to_string()))
                }
            }
        } else {
            // Already shutting down or terminated
            debug!("Server is already in {} state", current_state);
            Ok(())
        }
    }

    /// Execute a request within the lifecycle context
    pub async fn execute_request<F, R>(
        &self,
        request: &GenericRequest,
        client_id: Option<&str>,
        handler: F,
    ) -> Result<R, Error>
    where
        F: FnOnce(RequestContext) -> BoxFuture<'static, Result<R, Error>>,
        R: Send + 'static,
    {
        // Check if we can handle this method in the current state
        if !self.can_handle_method(&request.method) {
            return Err(Error::Initialization(format!(
                "Cannot handle method '{}' in current state",
                request.method
            )));
        }

        // For methods other than initialize, make sure we're initialized
        if request.method != "notifications/initialized" && self.protocol_version().is_none() {
            return Err(Error::Initialization("Server not initialized".to_string()));
        }

        // Create the request context
        let request_id = request.id.unwrap_or(0);
        let context = self.create_request_context(request_id, &request.method, client_id)?;

        // Call before_request on the context
        {
            let mut context_guard = self.typed_context.write().unwrap();
            context_guard.before_request(&context)?;
        }

        // Execute the handler
        let result = handler(context.clone()).await;

        // Call after_request on the context with cloned errors
        {
            let mut context_guard = self.typed_context.write().unwrap();
            match &result {
                Ok(_) => {
                    let ok_result: Result<(), Error> = Ok(());
                    context_guard.after_request(&context, &ok_result)?;
                }
                Err(e) => {
                    let err_result: Result<(), Error> = Err(Error::Other(e.to_string()));
                    context_guard.after_request(&context, &err_result)?;
                }
            }
        }

        result
    }

    /// Negotiate capabilities based on server and client capabilities
    pub fn negotiate_capabilities(
        &self,
        server_caps: &ServerCapabilities,
        client_caps: &ClientCapabilities,
    ) -> NegotiatedCapabilities {
        NegotiatedCapabilities::from_capabilities(server_caps, client_caps)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[derive(Clone)]
    struct TestContext;

    impl LifecycleContext for TestContext {
        fn on_startup(&mut self) -> Result<(), Error> {
            Ok(())
        }

        fn on_initialized(
            &mut self,
            _protocol_version: ProtocolVersion,
            _capabilities: &NegotiatedCapabilities,
        ) -> Result<(), Error> {
            Ok(())
        }

        fn after_request<T>(
            &mut self,
            _context: &RequestContext,
            _result: &Result<T, Error>,
        ) -> Result<(), Error> {
            Ok(())
        }

        fn on_shutdown(&mut self) -> Result<(), Error> {
            Ok(())
        }
    }

    #[test]
    fn protocol_version_conversions() {
        let version = ProtocolVersion::from_str("2024-11-05").unwrap();
        assert_eq!(version.to_str(), "2024-11-05");
        assert_eq!(version, ProtocolVersion::V20241105);

        let unsupported = ProtocolVersion::from_str("invalid");
        assert!(unsupported.is_err());
    }

    #[test]
    fn server_lifecycle_state_transitions() {
        let created = ServerLifecycleState::Created;
        assert!(created.can_transition_to(ServerLifecycleState::Initializing));
        assert!(!created.can_transition_to(ServerLifecycleState::Running));

        let initializing = ServerLifecycleState::Initializing;
        assert!(initializing.can_transition_to(ServerLifecycleState::Initialized));
        assert!(!initializing.can_transition_to(ServerLifecycleState::Created));

        let initialized = ServerLifecycleState::Initialized;
        assert!(initialized.can_transition_to(ServerLifecycleState::Running));
        assert!(!initialized.can_transition_to(ServerLifecycleState::Created));

        let running = ServerLifecycleState::Running;
        assert!(running.can_transition_to(ServerLifecycleState::ShuttingDown));
        assert!(!running.can_transition_to(ServerLifecycleState::Initialized));

        let shutting_down = ServerLifecycleState::ShuttingDown;
        assert!(shutting_down.can_transition_to(ServerLifecycleState::Terminated));
        assert!(!shutting_down.can_transition_to(ServerLifecycleState::Running));

        let terminated = ServerLifecycleState::Terminated;
        assert!(terminated.valid_next_states().is_empty());
    }

    #[test]
    fn client_lifecycle_state_transitions() {
        let created = ClientLifecycleState::Created;
        assert!(created.can_transition_to(ClientLifecycleState::Connecting));
        assert!(!created.can_transition_to(ClientLifecycleState::Running));

        let connecting = ClientLifecycleState::Connecting;
        assert!(connecting.can_transition_to(ClientLifecycleState::Initializing));
        assert!(!connecting.can_transition_to(ClientLifecycleState::Created));

        let initializing = ClientLifecycleState::Initializing;
        assert!(initializing.can_transition_to(ClientLifecycleState::Initialized));
        assert!(!initializing.can_transition_to(ClientLifecycleState::Created));

        let initialized = ClientLifecycleState::Initialized;
        assert!(initialized.can_transition_to(ClientLifecycleState::Running));
        assert!(!initialized.can_transition_to(ClientLifecycleState::Created));

        let running = ClientLifecycleState::Running;
        assert!(running.can_transition_to(ClientLifecycleState::ShuttingDown));
        assert!(!running.can_transition_to(ClientLifecycleState::Initialized));

        let shutting_down = ClientLifecycleState::ShuttingDown;
        assert!(shutting_down.can_transition_to(ClientLifecycleState::Terminated));
        assert!(!shutting_down.can_transition_to(ClientLifecycleState::Running));

        let terminated = ClientLifecycleState::Terminated;
        assert!(terminated.valid_next_states().is_empty());
    }

    #[test]
    fn method_allowed_in_state() {
        // Server states
        let created = ServerLifecycleState::Created;
        assert!(created.can_handle_method("initialize"));
        assert!(created.can_handle_method("ping"));
        assert!(!created.can_handle_method("resources/list"));

        let running = ServerLifecycleState::Running;
        assert!(!running.can_handle_method("initialize"));
        assert!(running.can_handle_method("resources/list"));
        assert!(running.can_handle_method("tools/call"));

        // Client states
        let client_created = ClientLifecycleState::Created;
        assert!(!client_created.can_call_method("initialize"));

        let client_running = ClientLifecycleState::Running;
        assert!(!client_running.can_call_method("initialize"));
        assert!(client_running.can_call_method("resources/list"));
    }

    #[tokio::test]
    async fn lifecycle_manager_initial_state() {
        let context = TestContext;
        let manager = LifecycleManager::new(context);

        assert_eq!(manager.current_state(), ServerLifecycleState::Created);
        assert!(manager.protocol_version().is_none());
        assert!(manager.capabilities().is_none());

        // Should be able to handle initialize
        assert!(manager.can_handle_method("initialize"));

        // But not other methods
        assert!(!manager.can_handle_method("resources/list"));
    }
}


<file_info>
path: src/types/resources.rs
name: resources.rs
</file_info>
//! MCP Resource Types
//!
//! This module defines types related to resources in the MCP protocol, such as
//! `Resource` and `ResourceTemplate`, which represent data sources or files that
//! can be accessed or manipulated by the AI application.

use base64::prelude::BASE64_STANDARD;
use base64::Engine;
use schemars::JsonSchema;
use serde::{ Deserialize, Serialize };
use std::fs;
use std::io;
use std::path::{ Path, PathBuf };

/// Represents a resource in the MCP protocol
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct Resource {
    /// Unique identifier for the resource
    pub uri: String,
    /// Human-readable name for the resource
    pub name: String,
    /// Optional description of the resource
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// MIME type of the resource content (e.g., "text/plain")
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mime_type: Option<String>,
}

/// Parameters for listing resources
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct ListResourcesParams {
    /// Optional filter for resource types
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mime_type: Option<String>,
    /// Optional pagination token
    #[serde(skip_serializing_if = "Option::is_none")]
    pub page_token: Option<String>,
    /// Optional limit on the number of resources to return
    #[serde(skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i32>,
}

/// Result of listing resources
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct ListResourcesResult {
    /// List of resources
    pub resources: Vec<Resource>,
    /// Token for the next page (if there are more resources)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_page_token: Option<String>,
}

/// Parameters for getting a resource's content
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct GetResourceParams {
    /// URI of the resource to get
    pub uri: String,
}

/// Result of getting a resource
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct GetResourceResult {
    /// The resource metadata
    pub resource: Resource,
    /// The content of the resource
    pub content: String,
}

/// Parameters for creating a resource
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct CreateResourceParams {
    /// Human-readable name for the resource
    pub name: String,
    /// Content of the resource
    pub content: String,
    /// Optional description of the resource
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// MIME type of the resource content
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mime_type: Option<String>,
}

/// Result of creating a resource
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct CreateResourceResult {
    /// The created resource
    pub resource: Resource,
}

/// Parameters for updating a resource
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct UpdateResourceParams {
    /// URI of the resource to update
    pub uri: String,
    /// New content for the resource
    pub content: String,
}

/// Result of updating a resource
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct UpdateResourceResult {
    /// The updated resource
    pub resource: Resource,
}

/// Parameters for deleting a resource
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct DeleteResourceParams {
    /// URI of the resource to delete
    pub uri: String,
}

/// Result of deleting a resource
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct DeleteResourceResult {
    /// Indicates whether the resource was successfully deleted
    pub success: bool,
}

/// A file-based resource that can be created from a local file
pub struct FileResource {
    /// The resource metadata
    pub resource: Resource,
    /// The local file path
    pub path: PathBuf,
    /// Whether the file should be read as binary
    pub is_binary: bool,
}

impl FileResource {
    /// Create a new file resource with the given parameters
    pub fn new<P: AsRef<Path>>(
        uri: Option<String>,
        name: String,
        path: P,
        description: Option<String>,
        mime_type: Option<String>,
        is_binary: bool
    ) -> Result<Self, io::Error> {
        let path = path.as_ref().to_path_buf();

        // Validate the path is absolute
        if !path.is_absolute() {
            return Err(
                io::Error::new(io::ErrorKind::InvalidInput, "FileResource path must be absolute")
            );
        }

        // Validate the file exists
        if !path.exists() {
            return Err(
                io::Error::new(
                    io::ErrorKind::NotFound,
                    format!("File not found: {}", path.display())
                )
            );
        }

        // Determine mime type if not provided
        let mime_type = mime_type.or_else(||
            mime_guess
                ::from_path(&path)
                .first()
                .map(|m| m.to_string())
        );

        // Generate a URI if not provided
        let uri = uri.unwrap_or_else(|| format!("file://{}", path.display()));

        Ok(Self {
            resource: Resource {
                uri,
                name,
                description,
                mime_type,
            },
            path,
            is_binary,
        })
    }

    /// Read the file content
    pub fn read(&self) -> Result<Vec<u8>, io::Error> {
        fs::read(&self.path)
    }

    /// Read the file as text
    pub fn read_text(&self) -> Result<String, io::Error> {
        fs::read_to_string(&self.path)
    }

    /// Get the resource metadata
    pub fn resource(&self) -> &Resource {
        &self.resource
    }

    /// Convert to a CreateResourceParams for creating on the server
    pub fn to_create_params(&self) -> Result<CreateResourceParams, io::Error> {
        let content = if self.is_binary {
            // For binary files, read as bytes and convert to base64
            let bytes = self.read()?;
            BASE64_STANDARD.encode(&bytes)
        } else {
            // For text files, just read as string
            self.read_text()?
        };

        Ok(CreateResourceParams {
            name: self.resource.name.clone(),
            content,
            description: self.resource.description.clone(),
            mime_type: self.resource.mime_type.clone(),
        })
    }
}


