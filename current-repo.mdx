<directory_structure>
mcp-rs
├── .git
├── examples
│   └── sseserver_with_handlers.rs
├── python_client
│   ├── __pycache__
│   ├── venv
│   ├── client.py
│   ├── requirements.txt
│   └── run_client.sh
├── src
│   ├── schema
│   │   └── schema.json
│   ├── server
│   │   ├── handlers
│   │   │   ├── initialize_handler.rs
│   │   │   ├── mod.rs
│   │   │   ├── notification_handler.rs
│   │   │   ├── request_handler.rs
│   │   │   └── tool_handler.rs
│   │   ├── resources
│   │   │   └── mod.rs
│   │   ├── tools
│   │   │   ├── message_parser.rs
│   │   │   ├── mod.rs
│   │   │   ├── process_manager.rs
│   │   │   ├── progress.rs
│   │   │   └── tool_registry.rs
│   │   ├── mod.rs
│   │   └── server.rs
│   ├── transport
│   │   ├── connection_manager.rs
│   │   ├── message_handler.rs
│   │   ├── mod.rs
│   │   ├── sse.rs
│   │   ├── sse_server.rs
│   │   ├── stdio.rs
│   │   ├── websocket.rs
│   │   └── websocket_server.rs
│   ├── types
│   │   ├── initialize.rs
│   │   ├── mod.rs
│   │   ├── prompts.rs
│   │   ├── protocol.rs
│   │   ├── resources.rs
│   │   └── tools.rs
│   ├── client.rs
│   ├── errors.rs
│   ├── lib.rs
│   └── utils.rs
├── target
├── .gitignore
├── Cargo.toml
├── README.md
├── current-repo.mdx
└── python-sdk.mdx

</directory_structure>

<file_info>
path: README.md
name: README.md
</file_info>
# MCP-rs: Rust Implementation of the Model Context Protocol

MCP-rs is a type-safe, efficient, and ergonomic Rust implementation of the [Model Context Protocol (MCP)](https://github.com/microsoft/mcp), designed to enable seamless integration between AI applications and external data sources or tools.

## Current Status

This repository contains a working implementation of the MCP protocol with the following components:

- **Rust Server**: A fully functional MCP server with support for tools, resources, and lifecycle management
- **Python Client**: A Python client that can connect to the server, list tools, and call them
- **Calculator Tool**: A sample tool that performs arithmetic operations (add, subtract, multiply, divide)
- **Server-Sent Events (SSE) Transport**: Real-time communication between client and server
- **WebSocket Transport**: Alternative transport for bidirectional communication

The `server_test` example is fully functional and works as a Cursor tool, allowing you to run an MCP server and interact with it using the Python client.

## Features

- **Type-Safe**: Leverages Rust's strong type system to ensure protocol correctness at compile time
- **Async-First**: Built on Tokio for high-performance, non-blocking I/O operations
- **Multiple Transports**: Supports STDIO, Server-Sent Events (SSE), and WebSocket transports
- **Schema Validation**: Automatic JSON Schema generation for protocol types
- **Extensible**: Easy to add new message handlers, tools, resources, and prompts
- **Python Compatibility**: Works with the standard MCP Python library

## Quick Start

### Running the Server

```bash
# Run the server_test example
cargo run --example server_test
```

This will start an MCP server on port 8090 with the calculator tool registered.

### Running the Python Client

```bash
# Navigate to the Python client directory
cd python_client

# Run the client script
./run_client.sh
```

The Python client will:
1. Connect to the MCP server
2. Initialize the connection
3. List available tools
4. Test the calculator tool with various operations

### Creating Your Own MCP Server

```rust
use mcp_rs::{ServerSession, Transport, sse_server::SseServerTransport};
use mcp_rs::types::tools::{Tool, ToolBuilder, ToolParameterType};

#[tokio::main]
async fn main() {
    // Create a new server with application state
    let mut server = ServerSession::new(());
    
    // Register a calculator tool
    server.register_tool_builder(
        server
            .build_tool("calculator", "Performs arithmetic operations")
            .add_parameter(/* ... */)
            // ... add more parameters
            .return_type("number")
            .streaming(false)
            .cancellable(false)
            .timeout(30)
    );
    
    // Register handler for the calculator tool
    server.register_handler("tools/call", |state, params| {
        // Handle tool calls
    });
    
    // Start the server with SSE transport
    let transport = SseServerTransport::new();
    server.run(transport).await;
}
```

## Examples

The repository includes several examples to demonstrate different MCP features:

- **server_test**: A complete MCP server with a calculator tool and SSE transport
- **lifecycle_example**: Demonstrates the lifecycle management features
- **websocket_transport_example**: Shows how to use WebSocket transport
- **tool_execution**: Illustrates implementing and registering tools
- **mcp-server-example**: A standalone MCP server implementation

To run an example:

```bash
cargo run --example server_test
```

## Python Client

The repository includes a Python client in the `python_client` directory. This client:

- Uses the standard MCP Python library
- Connects to the MCP server using SSE transport
- Lists available tools
- Calls the calculator tool with different operations

To run the Python client:

```bash
cd python_client
./run_client.sh
```

## Documentation

For detailed documentation, see the `docs` directory or run:

```bash
cargo doc --open
```

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request. 

<file_info>
path: src/types/resources.rs
name: resources.rs
</file_info>
//! MCP Resource Types
//!
//! This module defines types related to resources in the MCP protocol, such as
//! `Resource` and `ResourceTemplate`, which represent data sources or files that
//! can be accessed or manipulated by the AI application.

use base64::prelude::BASE64_STANDARD;
use base64::Engine;
use schemars::JsonSchema;
use serde::{ Deserialize, Serialize };
use std::fs;
use std::io;
use std::path::{ Path, PathBuf };

/// Represents a resource in the MCP protocol
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct Resource {
    /// Unique identifier for the resource
    pub uri: String,
    /// Human-readable name for the resource
    pub name: String,
    /// Optional description of the resource
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// MIME type of the resource content (e.g., "text/plain")
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mime_type: Option<String>,
}

/// Parameters for listing resources
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct ListResourcesParams {
    /// Optional filter for resource types
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mime_type: Option<String>,
    /// Optional pagination token
    #[serde(skip_serializing_if = "Option::is_none")]
    pub page_token: Option<String>,
    /// Optional limit on the number of resources to return
    #[serde(skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i32>,
}

/// Result of listing resources
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct ListResourcesResult {
    /// List of resources
    pub resources: Vec<Resource>,
    /// Token for the next page (if there are more resources)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_page_token: Option<String>,
}

/// Parameters for getting a resource's content
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct GetResourceParams {
    /// URI of the resource to get
    pub uri: String,
}

/// Result of getting a resource
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct GetResourceResult {
    /// The resource metadata
    pub resource: Resource,
    /// The content of the resource
    pub content: String,
}

/// Parameters for creating a resource
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct CreateResourceParams {
    /// Human-readable name for the resource
    pub name: String,
    /// Content of the resource
    pub content: String,
    /// Optional description of the resource
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// MIME type of the resource content
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mime_type: Option<String>,
}

/// Result of creating a resource
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct CreateResourceResult {
    /// The created resource
    pub resource: Resource,
}

/// Parameters for updating a resource
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct UpdateResourceParams {
    /// URI of the resource to update
    pub uri: String,
    /// New content for the resource
    pub content: String,
}

/// Result of updating a resource
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct UpdateResourceResult {
    /// The updated resource
    pub resource: Resource,
}

/// Parameters for deleting a resource
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct DeleteResourceParams {
    /// URI of the resource to delete
    pub uri: String,
}

/// Result of deleting a resource
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct DeleteResourceResult {
    /// Indicates whether the resource was successfully deleted
    pub success: bool,
}

/// A file-based resource that can be created from a local file
pub struct FileResource {
    /// The resource metadata
    pub resource: Resource,
    /// The local file path
    pub path: PathBuf,
    /// Whether the file should be read as binary
    pub is_binary: bool,
}

impl FileResource {
    /// Create a new file resource with the given parameters
    pub fn new<P: AsRef<Path>>(
        uri: Option<String>,
        name: String,
        path: P,
        description: Option<String>,
        mime_type: Option<String>,
        is_binary: bool
    ) -> Result<Self, io::Error> {
        let path = path.as_ref().to_path_buf();

        // Validate the path is absolute
        if !path.is_absolute() {
            return Err(
                io::Error::new(io::ErrorKind::InvalidInput, "FileResource path must be absolute")
            );
        }

        // Validate the file exists
        if !path.exists() {
            return Err(
                io::Error::new(
                    io::ErrorKind::NotFound,
                    format!("File not found: {}", path.display())
                )
            );
        }

        // Determine mime type if not provided
        let mime_type = mime_type.or_else(||
            mime_guess
                ::from_path(&path)
                .first()
                .map(|m| m.to_string())
        );

        // Generate a URI if not provided
        let uri = uri.unwrap_or_else(|| format!("file://{}", path.display()));

        Ok(Self {
            resource: Resource {
                uri,
                name,
                description,
                mime_type,
            },
            path,
            is_binary,
        })
    }

    /// Read the file content
    pub fn read(&self) -> Result<Vec<u8>, io::Error> {
        fs::read(&self.path)
    }

    /// Read the file as text
    pub fn read_text(&self) -> Result<String, io::Error> {
        fs::read_to_string(&self.path)
    }

    /// Get the resource metadata
    pub fn resource(&self) -> &Resource {
        &self.resource
    }

    /// Convert to a CreateResourceParams for creating on the server
    pub fn to_create_params(&self) -> Result<CreateResourceParams, io::Error> {
        let content = if self.is_binary {
            // For binary files, read as bytes and convert to base64
            let bytes = self.read()?;
            BASE64_STANDARD.encode(&bytes)
        } else {
            // For text files, just read as string
            self.read_text()?
        };

        Ok(CreateResourceParams {
            name: self.resource.name.clone(),
            content,
            description: self.resource.description.clone(),
            mime_type: self.resource.mime_type.clone(),
        })
    }
}


<file_info>
path: src/server/mod.rs
name: mod.rs
</file_info>
//! Server module for message handling and business logic
//!
//! This module contains the core server logic, message handlers,
//! and related components.

use async_trait::async_trait;

use crate::errors::Error;
use crate::types::protocol::{ Message, MessageType, RequestType, NotificationType, ResponseType };
pub mod server;
pub mod handlers;

pub mod resources;

pub mod tools;

/// MessageHandler trait defines the interface for handling messages
#[async_trait]
pub trait MessageHandler: Send + Sync {
    /// Handle a message from a client
    ///
    /// # Arguments
    /// * `client_id` - The ID of the client sending the message
    /// * `message` - The message to handle
    ///
    /// # Returns
    /// A `Result` indicating success or failure
    async fn handle(&self, client_id: &str, message: &Message) -> Result<Option<Message>, Error>;
}

/// Re-export the Server
pub use crate::server::server::Server;


<file_info>
path: Cargo.toml
name: Cargo.toml
</file_info>
[package]
name = "mcp-rs"
version = "0.1.0"
edition = "2024"
description = "Rust implementation of the Model Context Protocol (MCP)"
license = "MIT"
repository = "https://github.com/username/mcp-rs"
readme = "README.md"
keywords = ["ai", "protocol", "mcp", "model-context-protocol"]
categories = ["api-bindings", "asynchronous"]

[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
tokio = { version = "1.36", features = ["full"] }
async-trait = "0.1"
thiserror = "2.0.11"
schemars = "0.8"
jsonschema = "0.17"

futures = "0.3"
uuid = { version = "1.7", features = ["v4", "serde"] }
tracing = "0.1"
log = "0.4"
url = "2.4"
reqwest = { version = "0.12.12", features = ["json", "stream"] }
tokio-util = { version = "0.7", features = ["codec"] }
futures-util = "0.3"
bytes = "1.5"
tokio-tungstenite = "0.26.2"
base64 = "0.22.1"
mime_guess = "2.0.4"
axum = { version = "0.8.1", features = ["ws"] }
tower-http = { version = "0.6.2", features = ["cors"] }
tower = "0.5.2"
http = "1.2.0"
scopeguard = "1.2"
async-stream = "0.3.5"
anyhow = "1.0.96"
hyper = "1.6.0"

[dev-dependencies]
tokio-test = "0.4"
async-std = { version = "1.12", features = ["attributes"] }
insta = "1.34"
tracing-subscriber = "0.3"



[lib]
name = "mcp_rs"
path = "src/lib.rs"


<file_info>
path: src/types/protocol.rs
name: protocol.rs
</file_info>
//! Message types definitions for the Model Context Protocol (MCP)
//!
//! This module defines the core JSON-RPC 2.0 message structures and type-safe
//! representations of MCP protocol messages, providing serialization and
//! deserialization between JSON and Rust types.

use serde::{ Serialize, Deserialize };
use schemars::JsonSchema;

use crate::types::initialize::{ InitializeRequestParams, InitializeResult };
use crate::types::prompts::{
    CreatePromptParams,
    CreatePromptResult,
    DeletePromptParams,
    DeletePromptResult,
    ListPromptsParams,
    ListPromptsResult,
    Message as PromptMessage,
    RenderPromptParams,
    RenderPromptResult,
    UpdatePromptParams,
    UpdatePromptResult,
    Role,
};
use crate::types::resources::{
    CreateResourceParams,
    CreateResourceResult,
    DeleteResourceParams,
    DeleteResourceResult,
    GetResourceParams,
    GetResourceResult,
    ListResourcesParams,
    ListResourcesResult,
    UpdateResourceParams,
    UpdateResourceResult,
};
use crate::types::tools::{ CallToolParams, CallToolResult, ListToolsParams, ListToolsResult };

/// The top-level Message enum for handling JSON-RPC 2.0 messages
#[derive(Debug, Clone)]
pub enum Message {
    /// A request message requiring a response
    Request(Request),
    /// A response to a request
    Response(Response),
    /// A notification message (no response expected)
    Notification(Notification),
}

/// A JSON-RPC 2.0 request message
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub struct Request {
    /// JSON-RPC version, always "2.0"
    pub jsonrpc: String,
    /// Request ID for matching responses
    pub id: i32,
    /// Method name (e.g., "initialize")
    pub method: String,
    /// Method-specific parameters
    pub params: Option<serde_json::Value>,
}

/// A JSON-RPC 2.0 response message
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub struct Response {
    /// JSON-RPC version, always "2.0"
    pub jsonrpc: String,
    /// Request ID this response is for
    pub id: i32,
    /// Either a result or an error
    #[serde(flatten)]
    pub outcome: ResponseOutcome,
}

/// Either a successful result or an error
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
#[serde(untagged)]
pub enum ResponseOutcome {
    /// Success case with a result
    Success {
        result: serde_json::Value,
    },
    /// Error case with error details
    Error {
        error: ErrorData,
    },
}

/// Error information for failed requests
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub struct ErrorData {
    /// Error code (e.g., -32600 for Invalid Request)
    pub code: i32,
    /// Human-readable error message
    pub message: String,
    /// Optional additional data
    pub data: Option<serde_json::Value>,
}

/// A JSON-RPC 2.0 notification message
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub struct Notification {
    /// JSON-RPC version, always "2.0"
    pub jsonrpc: String,
    /// Method name (e.g., "notifications/initialized")
    pub method: String,
    /// Method-specific parameters
    pub params: Option<serde_json::Value>,
}

/// Notification messages that do not expect responses
#[derive(Debug, Serialize, Deserialize, Clone, JsonSchema)]
#[serde(tag = "method", content = "params")]
pub enum NotificationMessage {
    #[serde(rename = "notifications/initialized")] Initialized {
        #[serde(flatten)]
        meta: Option<serde_json::Value>,
    },
    #[serde(rename = "notifications/progress")] Progress {
        progress: f64,
        #[serde(rename = "progressToken")]
        progress_token: serde_json::Value,
        total: Option<f64>,
    },
    #[serde(rename = "notifications/resources/list_changed")] ResourcesListChanged {
        #[serde(flatten)]
        meta: Option<serde_json::Value>,
    },
    #[serde(rename = "notifications/resources/updated")] ResourcesUpdated {
        uri: String,
    },
    #[serde(rename = "notifications/prompts/list_changed")] PromptsListChanged {
        #[serde(flatten)]
        meta: Option<serde_json::Value>,
    },
    #[serde(rename = "notifications/tools/list_changed")] ToolsListChanged {
        #[serde(flatten)]
        meta: Option<serde_json::Value>,
    },
    #[serde(rename = "$/cancelRequest")] CancelRequest {
        #[serde(rename = "requestId")]
        request_id: serde_json::Value,
        reason: Option<String>,
    },
}

/// Request messages that expect responses
#[derive(Debug, Serialize, Deserialize, Clone, JsonSchema)]
#[serde(tag = "method", content = "params")]
pub enum RequestMessage {
    #[serde(rename = "initialize")] Initialize {
        #[serde(flatten)]
        params: InitializeRequestParams,
    },
    #[serde(rename = "ping")] Ping {
        #[serde(flatten)]
        meta: Option<serde_json::Value>,
    },
    #[serde(rename = "resources/list")] ListResources {
        #[serde(flatten)]
        params: ListResourcesParams,
    },
    #[serde(rename = "resources/read")] ReadResource {
        #[serde(flatten)]
        params: GetResourceParams,
    },
    #[serde(rename = "resources/create")] CreateResource {
        #[serde(flatten)]
        params: CreateResourceParams,
    },
    #[serde(rename = "resources/update")] UpdateResource {
        #[serde(flatten)]
        params: UpdateResourceParams,
    },
    #[serde(rename = "resources/delete")] DeleteResource {
        #[serde(flatten)]
        params: DeleteResourceParams,
    },
    #[serde(rename = "resources/subscribe")] SubscribeResource {
        uri: String,
    },
    #[serde(rename = "resources/unsubscribe")] UnsubscribeResource {
        uri: String,
    },
    #[serde(rename = "tools/list")] ListTools {
        #[serde(flatten)]
        params: ListToolsParams,
    },
    #[serde(rename = "tools/call")] CallTool {
        #[serde(flatten)]
        params: CallToolParams,
    },
    #[serde(rename = "prompts/list")] ListPrompts {
        #[serde(flatten)]
        params: ListPromptsParams,
    },
    #[serde(rename = "prompts/create")] CreatePrompt {
        #[serde(flatten)]
        params: CreatePromptParams,
    },
    #[serde(rename = "prompts/update")] UpdatePrompt {
        #[serde(flatten)]
        params: UpdatePromptParams,
    },
    #[serde(rename = "prompts/delete")] DeletePrompt {
        #[serde(flatten)]
        params: DeletePromptParams,
    },
    #[serde(rename = "prompts/render")] RenderPrompt {
        #[serde(flatten)]
        params: RenderPromptParams,
    },
    #[serde(rename = "prompts/get")] GetPrompt {
        name: String,
    },
}

/// Response message types for each request type
#[derive(Debug, Serialize, Deserialize, Clone, JsonSchema)]
#[serde(tag = "method", content = "result")]
pub enum ResponseMessage {
    #[serde(rename = "initialize")] Initialize {
        #[serde(flatten)]
        result: InitializeResult,
        #[serde(flatten)]
        meta: Option<serde_json::Value>,
    },
    #[serde(rename = "ping")] Ping {
        #[serde(flatten)]
        meta: Option<serde_json::Value>,
    },
    #[serde(rename = "resources/list")] ListResources {
        #[serde(flatten)]
        result: ListResourcesResult,
        #[serde(flatten)]
        meta: Option<serde_json::Value>,
    },
    #[serde(rename = "resources/read")] ReadResource {
        #[serde(flatten)]
        result: GetResourceResult,
        #[serde(flatten)]
        meta: Option<serde_json::Value>,
    },
    #[serde(rename = "resources/create")] CreateResource {
        #[serde(flatten)]
        result: CreateResourceResult,
        #[serde(flatten)]
        meta: Option<serde_json::Value>,
    },
    #[serde(rename = "resources/update")] UpdateResource {
        #[serde(flatten)]
        result: UpdateResourceResult,
        #[serde(flatten)]
        meta: Option<serde_json::Value>,
    },
    #[serde(rename = "resources/delete")] DeleteResource {
        #[serde(flatten)]
        result: DeleteResourceResult,
        #[serde(flatten)]
        meta: Option<serde_json::Value>,
    },
    #[serde(rename = "resources/subscribe")] SubscribeResource {
        #[serde(flatten)]
        meta: Option<serde_json::Value>,
    },
    #[serde(rename = "resources/unsubscribe")] UnsubscribeResource {
        #[serde(flatten)]
        meta: Option<serde_json::Value>,
    },
    #[serde(rename = "tools/list")] ListTools {
        #[serde(flatten)]
        result: ListToolsResult,
        #[serde(flatten)]
        meta: Option<serde_json::Value>,
    },
    #[serde(rename = "tools/call")] CallTool {
        #[serde(flatten)]
        result: CallToolResult,
        #[serde(flatten)]
        meta: Option<serde_json::Value>,
    },
    #[serde(rename = "prompts/list")] ListPrompts {
        #[serde(flatten)]
        result: ListPromptsResult,
        #[serde(flatten)]
        meta: Option<serde_json::Value>,
    },
    #[serde(rename = "prompts/create")] CreatePrompt {
        #[serde(flatten)]
        result: CreatePromptResult,
        #[serde(flatten)]
        meta: Option<serde_json::Value>,
    },
    #[serde(rename = "prompts/update")] UpdatePrompt {
        #[serde(flatten)]
        result: UpdatePromptResult,
        #[serde(flatten)]
        meta: Option<serde_json::Value>,
    },
    #[serde(rename = "prompts/delete")] DeletePrompt {
        #[serde(flatten)]
        result: DeletePromptResult,
        #[serde(flatten)]
        meta: Option<serde_json::Value>,
    },
    #[serde(rename = "prompts/render")] RenderPrompt {
        #[serde(flatten)]
        result: RenderPromptResult,
        #[serde(flatten)]
        meta: Option<serde_json::Value>,
    },
    #[serde(rename = "prompts/get")] GetPrompt {
        messages: Vec<PromptMessage>,
        description: Option<String>,
        #[serde(flatten)]
        meta: Option<serde_json::Value>,
    },
}

/// Enum representing the types of requests in the MCP protocol
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum RequestType {
    Initialize,
    Ping,
    ListResources,
    ReadResource,
    CreateResource,
    UpdateResource,
    DeleteResource,
    SubscribeResource,
    UnsubscribeResource,
    ListTools,
    CallTool,
    ListPrompts,
    CreatePrompt,
    UpdatePrompt,
    DeletePrompt,
    RenderPrompt,
    GetPrompt,
    Other(String),
}

/// Enum representing the types of notifications in the MCP protocol
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum NotificationType {
    Initialized,
    Progress,
    ResourcesListChanged,
    ResourcesUpdated,
    PromptsListChanged,
    ToolsListChanged,
    CancelRequest,
    Other(String),
}

/// Enum representing the types of responses in the MCP protocol
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ResponseType {
    Initialize,
    Ping,
    ListResources,
    ReadResource,
    CreateResource,
    UpdateResource,
    DeleteResource,
    SubscribeResource,
    UnsubscribeResource,
    ListTools,
    CallTool,
    ListPrompts,
    CreatePrompt,
    UpdatePrompt,
    DeletePrompt,
    RenderPrompt,
    GetPrompt,
    Error,
    Other(String),
}

/// High-level message type
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum MessageType {
    Request(RequestType),
    Notification(NotificationType),
    Response(ResponseType),
}

// Implementation for Message to convert between JSON-RPC and typed formats
impl Message {
    /// Parse a Notification into its typed variant
    pub fn parse_notification(
        notification: &Notification
    ) -> Result<NotificationMessage, serde_json::Error> {
        // Create a temporary object with method and params for deserialization
        let mut value = serde_json::Map::new();
        value.insert("method".to_string(), serde_json::Value::String(notification.method.clone()));

        if let Some(params) = &notification.params {
            value.insert("params".to_string(), params.clone());
        } else {
            value.insert("params".to_string(), serde_json::Value::Object(serde_json::Map::new()));
        }

        serde_json::from_value(serde_json::Value::Object(value))
    }

    /// Parse a Request into its typed variant
    pub fn parse_request(request: &Request) -> Result<RequestMessage, serde_json::Error> {
        // Create a temporary object with method and params for deserialization
        let mut value = serde_json::Map::new();
        value.insert("method".to_string(), serde_json::Value::String(request.method.clone()));

        if let Some(params) = &request.params {
            value.insert("params".to_string(), params.clone());
        } else {
            value.insert("params".to_string(), serde_json::Value::Object(serde_json::Map::new()));
        }

        serde_json::from_value(serde_json::Value::Object(value))
    }

    /// Parse a Response into its typed variant if it's a success
    pub fn parse_response(
        response: &Response
    ) -> Result<Option<ResponseMessage>, serde_json::Error> {
        match &response.outcome {
            ResponseOutcome::Success { result } => {
                // To deserialize properly, we need to include the method
                // The method should be extracted from a previous request, but we'll have to infer it here
                // In a real implementation, you'd store request method when sending
                let method = infer_method_from_result(result)?;

                let mut value = serde_json::Map::new();
                value.insert("method".to_string(), serde_json::Value::String(method));
                value.insert("result".to_string(), result.clone());

                let typed_response: ResponseMessage = serde_json::from_value(
                    serde_json::Value::Object(value)
                )?;
                Ok(Some(typed_response))
            }
            ResponseOutcome::Error { .. } => Ok(None), // No typed variant for errors
        }
    }

    /// Create a Response from a typed ResponseMessage
    pub fn response_from_typed(
        id: i32,
        response: ResponseMessage
    ) -> Result<Response, serde_json::Error> {
        // Serialize then extract just the result part
        let serialized = serde_json::to_value(response)?;
        let result = match serialized {
            serde_json::Value::Object(mut map) => {
                if let Some(result) = map.remove("result") {
                    result
                } else {
                    serde_json::Value::Object(map)
                }
            }
            value => value,
        };

        Ok(Response {
            jsonrpc: "2.0".to_string(),
            id,
            outcome: ResponseOutcome::Success { result },
        })
    }

    /// Create a Request from a typed RequestMessage
    pub fn request_from_typed(
        id: i32,
        request: RequestMessage
    ) -> Result<Request, serde_json::Error> {
        // Serialize then extract method and params
        let serialized = serde_json::to_value(request)?;
        let (method, params) = match serialized {
            serde_json::Value::Object(mut map) => {
                let method = map
                    .remove("method")
                    .and_then(|v| v.as_str().map(|s| s.to_string()))
                    .unwrap_or_default();

                let params = map.remove("params");

                (method, params)
            }
            _ => (String::new(), None),
        };

        Ok(Request {
            jsonrpc: "2.0".to_string(),
            id,
            method,
            params,
        })
    }

    /// Create a Notification from a typed NotificationMessage
    pub fn notification_from_typed(
        notification: NotificationMessage
    ) -> Result<Notification, serde_json::Error> {
        // Serialize then extract method and params
        let serialized = serde_json::to_value(notification)?;
        let (method, params) = match serialized {
            serde_json::Value::Object(mut map) => {
                let method = map
                    .remove("method")
                    .and_then(|v| v.as_str().map(|s| s.to_string()))
                    .unwrap_or_default();

                let params = map.remove("params");

                (method, params)
            }
            _ => (String::new(), None),
        };

        Ok(Notification {
            jsonrpc: "2.0".to_string(),
            method,
            params,
        })
    }

    /// Get the type of this message
    pub fn message_type(&self) -> MessageType {
        match self {
            Message::Request(req) => {
                let request_type = match req.method.as_str() {
                    "initialize" => RequestType::Initialize,
                    "ping" => RequestType::Ping,
                    "resources/list" => RequestType::ListResources,
                    "resources/read" => RequestType::ReadResource,
                    "resources/create" => RequestType::CreateResource,
                    "resources/update" => RequestType::UpdateResource,
                    "resources/delete" => RequestType::DeleteResource,
                    "resources/subscribe" => RequestType::SubscribeResource,
                    "resources/unsubscribe" => RequestType::UnsubscribeResource,
                    "tools/list" => RequestType::ListTools,
                    "tools/call" => RequestType::CallTool,
                    "prompts/list" => RequestType::ListPrompts,
                    "prompts/create" => RequestType::CreatePrompt,
                    "prompts/update" => RequestType::UpdatePrompt,
                    "prompts/delete" => RequestType::DeletePrompt,
                    "prompts/render" => RequestType::RenderPrompt,
                    "prompts/get" => RequestType::GetPrompt,
                    other => RequestType::Other(other.to_string()),
                };
                MessageType::Request(request_type)
            }
            Message::Notification(notif) => {
                let notification_type = match notif.method.as_str() {
                    "notifications/initialized" => NotificationType::Initialized,
                    "notifications/progress" => NotificationType::Progress,
                    "notifications/resources/list_changed" =>
                        NotificationType::ResourcesListChanged,
                    "notifications/resources/updated" => NotificationType::ResourcesUpdated,
                    "notifications/prompts/list_changed" => NotificationType::PromptsListChanged,
                    "notifications/tools/list_changed" => NotificationType::ToolsListChanged,
                    "$/cancelRequest" => NotificationType::CancelRequest,
                    other => NotificationType::Other(other.to_string()),
                };
                MessageType::Notification(notification_type)
            }
            Message::Response(resp) => {
                // For responses, we infer the type from the result if success
                match &resp.outcome {
                    ResponseOutcome::Success { result } => {
                        // Try to infer from result structure
                        if let Ok(method) = infer_method_from_result(result) {
                            let response_type = match method.as_str() {
                                "initialize" => ResponseType::Initialize,
                                "ping" => ResponseType::Ping,
                                "resources/list" => ResponseType::ListResources,
                                "resources/read" => ResponseType::ReadResource,
                                "resources/create" => ResponseType::CreateResource,
                                "resources/update" => ResponseType::UpdateResource,
                                "resources/delete" => ResponseType::DeleteResource,
                                "resources/subscribe" => ResponseType::SubscribeResource,
                                "resources/unsubscribe" => ResponseType::UnsubscribeResource,
                                "tools/list" => ResponseType::ListTools,
                                "tools/call" => ResponseType::CallTool,
                                "prompts/list" => ResponseType::ListPrompts,
                                "prompts/create" => ResponseType::CreatePrompt,
                                "prompts/update" => ResponseType::UpdatePrompt,
                                "prompts/delete" => ResponseType::DeletePrompt,
                                "prompts/render" => ResponseType::RenderPrompt,
                                "prompts/get" => ResponseType::GetPrompt,
                                other => ResponseType::Other(other.to_string()),
                            };
                            MessageType::Response(response_type)
                        } else {
                            MessageType::Response(ResponseType::Other("unknown".to_string()))
                        }
                    }
                    ResponseOutcome::Error { .. } => { MessageType::Response(ResponseType::Error) }
                }
            }
        }
    }

    /// Convenience method to check if this is a specific request type
    pub fn is_request_type(&self, request_type: &RequestType) -> bool {
        match self.message_type() {
            MessageType::Request(rt) => &rt == request_type,
            _ => false,
        }
    }

    /// Convenience method to check if this is a specific notification type
    pub fn is_notification_type(&self, notification_type: &NotificationType) -> bool {
        match self.message_type() {
            MessageType::Notification(nt) => &nt == notification_type,
            _ => false,
        }
    }

    /// Convenience method to check if this is a specific response type
    pub fn is_response_type(&self, response_type: &ResponseType) -> bool {
        match self.message_type() {
            MessageType::Response(rt) => &rt == response_type,
            _ => false,
        }
    }
}

/// Infer the method name from a result value
/// This is a placeholder - in a real implementation you would track request methods
fn infer_method_from_result(result: &serde_json::Value) -> Result<String, serde_json::Error> {
    // Use heuristics to determine the method based on fields in the result
    if result.get("capabilities").is_some() && result.get("serverInfo").is_some() {
        return Ok("initialize".to_string());
    }

    if result.get("resources").is_some() {
        return Ok("resources/list".to_string());
    }

    if result.get("contents").is_some() {
        return Ok("resources/read".to_string());
    }

    if result.get("tools").is_some() {
        return Ok("tools/list".to_string());
    }

    if result.get("content").is_some() {
        return Ok("tools/call".to_string());
    }

    if result.get("prompts").is_some() {
        return Ok("prompts/list".to_string());
    }

    if result.get("messages").is_some() {
        return Ok("prompts/get".to_string());
    }

    // Default to ping for empty results
    Ok("ping".to_string())
}

// Add custom deserialization to correctly distinguish between requests and notifications
impl<'de> serde::de::Deserialize<'de> for Message {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where D: serde::de::Deserializer<'de>
    {
        use serde::de::Error;

        // First deserialize to a generic Value
        let value = serde_json::Value::deserialize(deserializer)?;

        // Check for jsonrpc field - all messages must have this
        if !value.get("jsonrpc").is_some() {
            return Err(D::Error::custom("Missing jsonrpc field"));
        }

        // Check message type based on fields
        if value.get("result").is_some() || value.get("error").is_some() {
            // Has result or error - it's a response
            let response: Response = serde_json
                ::from_value(value.clone())
                .map_err(|e| D::Error::custom(e.to_string()))?;
            return Ok(Message::Response(response));
        } else if value.get("id").is_some() {
            // Has ID - it's a request
            let request: Request = serde_json
                ::from_value(value.clone())
                .map_err(|e| D::Error::custom(e.to_string()))?;
            return Ok(Message::Request(request));
        } else if value.get("method").is_some() {
            // Has method but no ID - it's a notification
            let notification: Notification = serde_json
                ::from_value(value.clone())
                .map_err(|e| D::Error::custom(e.to_string()))?;
            return Ok(Message::Notification(notification));
        }

        Err(D::Error::custom("Invalid JSON-RPC message format"))
    }
}

impl Serialize for Message {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error> where S: serde::Serializer {
        match self {
            Message::Request(req) => req.serialize(serializer),
            Message::Response(resp) => resp.serialize(serializer),
            Message::Notification(notif) => notif.serialize(serializer),
        }
    }
}

// Helper functions
/// Create a success response with the given result
pub fn success_response(id: i32, result: serde_json::Value) -> Response {
    Response {
        jsonrpc: "2.0".to_string(),
        id,
        outcome: ResponseOutcome::Success { result },
    }
}

/// Create an error response with the given code, message, and optional data
pub fn error_response(
    id: i32,
    code: i32,
    message: &str,
    data: Option<serde_json::Value>
) -> Response {
    Response {
        jsonrpc: "2.0".to_string(),
        id,
        outcome: ResponseOutcome::Error {
            error: ErrorData {
                code,
                message: message.to_string(),
                data,
            },
        },
    }
}

/// Resource contents
#[derive(Debug, Serialize, Deserialize, Clone, JsonSchema)]
#[serde(untagged)]
pub enum ResourceContents {
    Text {
        uri: String,
        text: String,
        #[serde(rename = "mimeType")]
        mime_type: Option<String>,
    },
    Blob {
        uri: String,
        blob: String,
        #[serde(rename = "mimeType")]
        mime_type: Option<String>,
    },
}

/// Content types for tool results and other messages
#[derive(Debug, Serialize, Deserialize, Clone, JsonSchema)]
#[serde(tag = "type")]
pub enum Content {
    #[serde(rename = "text")] Text {
        text: String,
        #[serde(skip_serializing_if = "Option::is_none")]
        annotations: Option<Annotations>,
    },
    #[serde(rename = "image")] Image {
        data: String,
        #[serde(rename = "mimeType")]
        mime_type: String,
        #[serde(skip_serializing_if = "Option::is_none")]
        annotations: Option<Annotations>,
    },
    #[serde(rename = "resource")] ResourceContent {
        resource: ResourceContents,
        #[serde(skip_serializing_if = "Option::is_none")]
        annotations: Option<Annotations>,
    },
}

/// Annotations for content
#[derive(Debug, Serialize, Deserialize, Clone, JsonSchema)]
pub struct Annotations {
    pub priority: Option<f64>,
    pub audience: Option<Vec<Role>>,
}


<file_info>
path: src/types/mod.rs
name: mod.rs
</file_info>
//! MCP Type Definitions
//!
//! This module re-exports various type definitions used in the MCP protocol, organizing
//! them into submodules for clarity and ease of use. It includes types for initialization,
//! prompts, resources, and tools.

pub mod initialize;
pub mod prompts;
pub mod protocol;
pub mod resources;
pub mod tools;

// Re-export common types from each module
pub use initialize::{
    ClientCapabilities,
    Implementation,
    InitializeRequestParams,
    InitializeResult,
    ServerCapabilities,
};
pub use prompts::{ ContentPart, Message as PromptMessage, Prompt, PromptArgument, Role };
pub use protocol::{
    Message as ProtocolMessage,
    Request,
    Response,
    Notification,
    ResponseOutcome,
    ErrorData,
    NotificationMessage,
    RequestMessage,
    ResponseMessage,
    success_response,
    error_response,
};
pub use resources::{ ListResourcesParams, ListResourcesResult, Resource };
pub use tools::{ CallToolParams, CallToolResult, Tool, ToolParameter };


<file_info>
path: src/lib.rs
name: lib.rs
</file_info>
//! MCP Rust Library
//!
//! This crate provides a Rust implementation of the Model Context Protocol (MCP),
//! enabling seamless integration between AI applications and external data sources
//! or tools. It includes both client and server components, supporting various
//! transports like STDIO and SSE, with a focus on type safety, performance, and
//! extensibility.

// Re-export core components
pub mod client;
pub mod errors;
pub mod server;
// pub mod server_session;

pub mod transport;
pub mod types;
pub mod utils;
// Re-export commonly used items
pub use errors::Error;
pub use transport::Transport;
pub use transport::sse_server::SseServerTransport;
pub use transport::stdio::StdioTransport;


<file_info>
path: src/server/tools/progress.rs
name: progress.rs
</file_info>
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::Mutex;
use tokio::sync::broadcast;

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ToolProgress {
    pub tool_name: String,
    pub tool_id: String,
    pub progress: f64, // 0.0 to 1.0
    pub message: Option<String>,
    pub timestamp: u64,
}

pub struct ToolProgressTracker {
    progress: Arc<Mutex<HashMap<String, ToolProgress>>>,
    sender: broadcast::Sender<ToolProgress>,
}

impl ToolProgressTracker {
    pub fn new() -> Self {
        let (sender, _) = broadcast::channel(100);
        Self {
            progress: Arc::new(Mutex::new(HashMap::new())),
            sender,
        }
    }

    pub fn subscribe(&self) -> broadcast::Receiver<ToolProgress> {
        self.sender.subscribe()
    }

    pub async fn update_progress(&self, progress: ToolProgress) {
        let mut progress_map = self.progress.lock().await;
        progress_map.insert(progress.tool_id.clone(), progress.clone());
        let _ = self.sender.send(progress);
    }

    pub async fn get_progress(&self, tool_id: &str) -> Option<ToolProgress> {
        let progress_map = self.progress.lock().await;
        progress_map.get(tool_id).cloned()
    }
}


<file_info>
path: src/server/handlers/notification_handler.rs
name: notification_handler.rs
</file_info>
//! Handler for notification messages

use async_trait::async_trait;
use tracing::{ info, debug };

use crate::errors::Error;
use crate::types::protocol::{ Message, NotificationMessage };
use crate::server::MessageHandler;

/// Handler for notification messages
pub struct NotificationHandler;

impl NotificationHandler {
    /// Create a new instance of the notification handler
    pub fn new() -> Self {
        Self {}
    }
}

#[async_trait]
impl MessageHandler for NotificationHandler {
    async fn handle(&self, client_id: &str, message: &Message) -> Result<Option<Message>, Error> {
        match message {
            Message::Notification(notif) => {
                info!("Processing notification '{}' from client {}", notif.method, client_id);

                // Parse into typed notification
                match Message::parse_notification(notif) {
                    Ok(typed_notif) => {
                        debug!("Parsed notification: {:?}", typed_notif);

                        // For specific notifications, we would have additional handling
                        match typed_notif {
                            NotificationMessage::Initialized { meta } => {
                                info!("Client {} initialized with meta {:?}", client_id, meta);
                                // Handle initialization notification
                            }
                            NotificationMessage::Progress { progress, progress_token, total } => {
                                info!(
                                    "Progress update from client {}: {}/{:?} (progress_token: {:?})",
                                    client_id,
                                    progress,
                                    total,
                                    progress_token
                                );
                                // Handle progress notification
                            }
                            NotificationMessage::ResourcesListChanged { meta } => {
                                info!(
                                    "Resources list changed for client {} with meta {:?}",
                                    client_id,
                                    meta
                                );
                                // Handle resources list changed notification
                            }
                            NotificationMessage::ResourcesUpdated { uri } => {
                                info!("Resource updated for client {}: {} ", client_id, uri);
                                // Handle resource updated notification
                            }
                            NotificationMessage::PromptsListChanged { meta } => {
                                info!(
                                    "Prompts list changed for client {} with meta {:?}",
                                    client_id,
                                    meta
                                );
                                // Handle prompts list changed notification
                            }
                            NotificationMessage::ToolsListChanged { meta } => {
                                info!(
                                    "Tools list changed for client {} with meta {:?}",
                                    client_id,
                                    meta
                                );
                                // Handle tools list changed notification
                            }
                            NotificationMessage::CancelRequest { request_id, reason } => {
                                info!(
                                    "Client {} cancelled request {:?} (reason: {:?})",
                                    client_id,
                                    request_id,
                                    reason
                                );
                                // Handle cancel request notification
                            }
                        }
                    }
                    Err(e) => {
                        debug!("Error parsing notification: {}", e);
                        // Continue with generic handling if parsing fails
                    }
                }

                // For now, we don't send any responses to notifications
                Ok(None)
            }
            _ => {
                // This handler only handles notifications
                Err(Error::Transport("Non-notification message received".into()))
            }
        }
    }
}


<file_info>
path: src/server/tools/tool_registry.rs
name: tool_registry.rs
</file_info>
use crate::errors::Error;
use crate::server::tools::process_manager::ToolProcessManager;
use crate::types::tools::{ Tool, CallToolParams, CallToolResult, TextContent };
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::{ Mutex, mpsc };
use tracing::info;

use super::process_manager::ToolOutput;

/// Handler type for in-process tools
type ToolHandler = Arc<dyn (Fn(CallToolParams) -> Result<CallToolResult, Error>) + Send + Sync>;

/// Tool definition variants to properly represent different tool types
pub enum ToolDefinition {
    /// External tool executed as a subprocess
    External {
        tool: Tool,
        command: String,
        args: Vec<String>,
        env: HashMap<String, String>,
    },
    /// In-process tool executed directly
    InProcess {
        tool: Tool,
        handler: ToolHandler,
    },
}

impl ToolDefinition {
    /// Get the tool metadata regardless of type
    pub fn get_tool(&self) -> &Tool {
        match self {
            ToolDefinition::External { tool, .. } => tool,
            ToolDefinition::InProcess { tool, .. } => tool,
        }
    }
}

pub struct ToolRegistry {
    tools: Arc<Mutex<HashMap<String, ToolDefinition>>>,
    process_manager: Arc<ToolProcessManager>,
}

impl ToolRegistry {
    pub fn new() -> Self {
        Self {
            tools: Arc::new(Mutex::new(HashMap::new())),
            process_manager: Arc::new(ToolProcessManager::new()),
        }
    }

    /// Register a tool in the registry
    pub async fn register_external_tool(
        &self,
        tool: Tool,
        command: String,
        args: Vec<String>,
        env: HashMap<String, String>
    ) -> Result<(), Error> {
        let mut tools = self.tools.lock().await;
        tools.insert(tool.name.clone(), ToolDefinition::External {
            tool,
            command,
            args,
            env,
        });
        Ok(())
    }

    /// Register an in-process tool with a function handler
    pub async fn register_in_process_tool(
        &self,
        tool: Tool,
        handler: impl (Fn(CallToolParams) -> Result<CallToolResult, Error>) + Send + Sync + 'static
    ) -> Result<(), Error> {
        let mut tools = self.tools.lock().await;

        // Store the tool definition with its handler
        tools.insert(tool.name.clone(), ToolDefinition::InProcess {
            tool,
            handler: Arc::new(handler),
        });

        Ok(())
    }

    pub async fn list_tools(&self) -> Vec<Tool> {
        let tools = self.tools.lock().await;
        info!(
            "LISTING TOOLS CALLED: Available tools in registry: {}",
            tools.keys().cloned().collect::<Vec<String>>().join(", ")
        );
        tools
            .values()
            .map(|def| def.get_tool().clone())
            .collect()
    }

    /// Execute a tool using CallToolParams and return a CallToolResult
    pub async fn execute_tool_with_params(
        &self,
        params: CallToolParams
    ) -> Result<CallToolResult, Error> {
        let tool_name = &params.name;
        let tools = self.tools.lock().await;

        let definition = tools
            .get(tool_name)
            .ok_or_else(|| Error::Tool(format!("Tool not found: {}", tool_name)))?;

        match definition {
            ToolDefinition::InProcess { handler, .. } => {
                // Execute the in-process handler directly
                handler(params.clone())
            }
            ToolDefinition::External { .. } => {
                // For external tools, use the process executor
                drop(tools); // Release the lock before the async operation
                let receiver = self.execute_tool(tool_name, params.arguments).await?;
                self.process_tool_output(receiver).await
            }
        }
    }

    /// Process the output from a tool execution to create a CallToolResult
    async fn process_tool_output(
        &self,
        mut receiver: mpsc::Receiver<ToolOutput>
    ) -> Result<CallToolResult, Error> {
        let mut stdout_content = String::new();
        let mut stderr_content = String::new();

        // Process output messages
        while let Some(output) = receiver.recv().await {
            match output.output_type {
                super::process_manager::ToolOutputType::Stdout => {
                    stdout_content.push_str(&output.content);
                }
                super::process_manager::ToolOutputType::Stderr => {
                    stderr_content.push_str(&output.content);
                }
            }
        }

        // Determine if there's an error based on stderr content
        let is_error = !stderr_content.is_empty();

        // Prepare the result content
        let content = if is_error {
            // Return stderr as error text
            vec![
                serde_json
                    ::to_value(TextContent {
                        content_type: "text".to_string(),
                        text: stderr_content,
                        annotations: None,
                    })
                    .unwrap()
            ]
        } else {
            // Try to parse stdout as JSON, fall back to text if it fails
            match serde_json::from_str::<serde_json::Value>(&stdout_content) {
                Ok(json_value) => { vec![json_value] }
                Err(_) => {
                    vec![
                        serde_json
                            ::to_value(TextContent {
                                content_type: "text".to_string(),
                                text: stdout_content,
                                annotations: None,
                            })
                            .unwrap()
                    ]
                }
            }
        };

        Ok(CallToolResult {
            content,
            is_error,
        })
    }

    pub async fn execute_tool(
        &self,
        tool_name: &str,
        parameters: HashMap<String, serde_json::Value>
    ) -> Result<mpsc::Receiver<ToolOutput>, Error> {
        let tools = self.tools.lock().await;
        let definition = tools
            .get(tool_name)
            .ok_or_else(|| Error::Tool(format!("Tool not found: {}", tool_name)))?;

        // Handle based on tool type
        match definition {
            ToolDefinition::InProcess { .. } => {
                return Err(
                    Error::Tool(
                        format!("Tool '{}' is an in-process tool and should be executed with execute_tool_with_params", tool_name)
                    )
                );
            }
            ToolDefinition::External { command, args, env, .. } => {
                // Prepare parameters as environment variables
                let mut tool_env = env.clone();
                for (key, value) in &parameters {
                    tool_env.insert(format!("PARAM_{}", key.to_uppercase()), value.to_string());
                }

                // Also pass parameters as JSON
                tool_env.insert(
                    "TOOL_PARAMETERS".to_string(),
                    serde_json::to_string(&parameters).map_err(|e| Error::Json(e))?
                );

                // Convert args to &str array
                let args_ref: Vec<&str> = args
                    .iter()
                    .map(|s| s.as_str())
                    .collect();

                // Execute the tool
                let tool_id = format!("{}_{}", tool_name, uuid::Uuid::new_v4());
                self.process_manager.spawn_process(&tool_id, command, &args_ref, tool_env).await
            }
        }
    }

    /// Check if a tool exists in the registry
    pub async fn has_tool(&self, tool_name: &str) -> bool {
        let tools = self.tools.lock().await;
        tools.contains_key(tool_name)
    }

    /// Get a tool definition by name
    pub async fn get_tool(&self, tool_name: &str) -> Option<Tool> {
        let tools = self.tools.lock().await;
        tools.get(tool_name).map(|def| def.get_tool().clone())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::types::tools::{ ToolBuilder, ToolParameterType };

    #[tokio::test]
    async fn test_in_process_tool() {
        // Create a simple calculator tool
        let calc_tool = ToolBuilder::new("calculator", "Performs basic arithmetic")
            .add_parameter(
                crate::types::tools::ToolParameterBuilder
                    ::new("a", ToolParameterType::Number)
                    .required(true)
                    .build()
            )
            .add_parameter(
                crate::types::tools::ToolParameterBuilder
                    ::new("b", ToolParameterType::Number)
                    .required(true)
                    .build()
            )
            .add_parameter(
                crate::types::tools::ToolParameterBuilder
                    ::new("operation", ToolParameterType::String)
                    .enum_values(vec!["add", "subtract", "multiply", "divide"])
                    .required(true)
                    .build()
            )
            .build();

        // Create a registry
        let registry = ToolRegistry::new();

        // Register the calculator tool
        registry
            .register_in_process_tool(calc_tool, |params: CallToolParams| {
                let a = params.arguments
                    .get("a")
                    .and_then(|v| v.as_f64())
                    .ok_or_else(|| Error::InvalidParams("Missing parameter 'a'".to_string()))?;

                let b = params.arguments
                    .get("b")
                    .and_then(|v| v.as_f64())
                    .ok_or_else(|| Error::InvalidParams("Missing parameter 'b'".to_string()))?;

                let operation = params.arguments
                    .get("operation")
                    .and_then(|v| v.as_str())
                    .ok_or_else(||
                        Error::InvalidParams("Missing parameter 'operation'".to_string())
                    )?;

                let result = match operation {
                    "add" => a + b,
                    "subtract" => a - b,
                    "multiply" => a * b,
                    "divide" => {
                        if b == 0.0 {
                            return Err(Error::InvalidParams("Cannot divide by zero".to_string()));
                        }
                        a / b
                    }
                    _ => {
                        return Err(
                            Error::InvalidParams(format!("Unknown operation: {}", operation))
                        );
                    }
                };

                Ok(CallToolResult {
                    content: vec![serde_json::json!({ "result": result })],
                    is_error: false,
                })
            }).await
            .unwrap();

        // Execute the tool
        let params = CallToolParams {
            name: "calculator".to_string(),
            arguments: [
                ("a".to_string(), serde_json::json!(2)),
                ("b".to_string(), serde_json::json!(3)),
                ("operation".to_string(), serde_json::json!("add")),
            ]
                .into_iter()
                .collect(),
        };

        let result = registry.execute_tool_with_params(params).await.unwrap();
        assert!(!result.is_error);

        let result_value = result.content[0]
            .get("result")
            .and_then(|v| v.as_f64())
            .unwrap();
        assert_eq!(result_value, 5.0);
    }
}


<file_info>
path: src/client.rs
name: client.rs
</file_info>
//! MCP Client
//!
//! This module implements the MCP client, responsible for connecting to MCP servers,
//! sending requests, and receiving responses. It abstracts the underlying transport
//! layer, allowing for easy integration with different communication channels.

use serde::{ Serialize, de::DeserializeOwned };
use std::collections::HashMap;
use std::sync::Arc;
use std::sync::atomic::{ AtomicI32, Ordering };
use tokio::sync::oneshot;
use tokio::sync::{ Mutex, mpsc };
use tokio::task::JoinHandle;

use crate::errors::Error;
use crate::types::protocol::{
    Message as McpMessage,
    Notification,
    Response,
    ResponseOutcome,
    Request,
};
use crate::transport::Transport;
use crate::types::initialize::{ InitializeRequestParams, InitializeResult };
use crate::types::prompts::{
    ContentPart,
    CreatePromptParams,
    CreatePromptResult,
    DeletePromptParams,
    DeletePromptResult,
    ListPromptsParams,
    ListPromptsResult,
    Message,
    RenderPromptParams,
    RenderPromptResult,
    Role,
    UpdatePromptParams,
    UpdatePromptResult,
};
use crate::types::resources::{
    CreateResourceParams,
    CreateResourceResult,
    DeleteResourceParams,
    DeleteResourceResult,
    FileResource,
    GetResourceParams,
    GetResourceResult,
    ListResourcesParams,
    ListResourcesResult,
    UpdateResourceParams,
    UpdateResourceResult,
};
use crate::types::tools::{ CallToolParams, CallToolResult, ListToolsParams, ListToolsResult };
use crate::utils::validation::{ ValidationConfig, validate_request, validate_response };

/// A client for communicating with an MCP server
pub struct Client<T> {
    /// The transport used for communication
    transport: Arc<Mutex<T>>,
    /// Counter for generating request IDs
    request_id_counter: AtomicI32,
    /// Pending requests waiting for responses
    pending_requests: Arc<Mutex<HashMap<i32, oneshot::Sender<Result<Response, Error>>>>>,
    /// Notification listeners
    notification_listeners: Arc<Mutex<Vec<mpsc::Sender<Notification>>>>,
    /// Background task handle for the message loop
    message_loop_handle: Option<JoinHandle<Result<(), Error>>>,
    /// Validation configuration
    validation_config: ValidationConfig,
}

impl<T: Transport + 'static> Client<T> {
    /// Create a new client with the given transport
    pub fn new(transport: T) -> Self {
        Self {
            transport: Arc::new(Mutex::new(transport)),
            request_id_counter: AtomicI32::new(1),
            pending_requests: Arc::new(Mutex::new(HashMap::new())),
            notification_listeners: Arc::new(Mutex::new(Vec::new())),
            message_loop_handle: None,
            validation_config: ValidationConfig::default(),
        }
    }

    /// Set validation configuration
    pub fn with_validation_config(mut self, config: ValidationConfig) -> Self {
        self.validation_config = config;
        self
    }

    /// Enable or disable request validation
    pub fn validate_requests(mut self, validate: bool) -> Self {
        self.validation_config.validate_requests = validate;
        self
    }

    /// Enable or disable response validation
    pub fn validate_responses(mut self, validate: bool) -> Self {
        self.validation_config.validate_responses = validate;
        self
    }

    /// Start the message handling loop in a background task
    pub fn start_message_loop(&mut self) -> Result<(), Error> {
        if self.message_loop_handle.is_some() {
            return Err(Error::Other("Message loop already started".to_string()));
        }

        let transport = self.transport.clone();
        let pending_requests = self.pending_requests.clone();
        let notification_listeners = self.notification_listeners.clone();

        let handle = tokio::spawn(async move {
            tracing::info!("Starting client message loop");
            loop {
                // Use a timeout to periodically check for messages and ensure we don't hold the lock indefinitely
                let mut transport_guard = transport.lock().await;

                let message_result = match
                    tokio::time::timeout(
                        std::time::Duration::from_millis(100),
                        transport_guard.receive()
                    ).await
                {
                    Ok(result) => {
                        // Received a message or error before timeout
                        drop(transport_guard);

                        result
                    }
                    Err(_) => {
                        // Timeout occurred, release lock and continue
                        drop(transport_guard);
                        tracing::debug!("Message loop released transport lock after timeout");
                        // Small sleep to avoid tight loop
                        tokio::time::sleep(tokio::time::Duration::from_millis(10)).await;
                        continue;
                    }
                };

                // Process the message or error
                match message_result {
                    Ok((_, message)) =>
                        match message {
                            McpMessage::Response(response) => {
                                tracing::debug!("Received response with id={}", response.id);
                                let mut requests = pending_requests.lock().await;
                                let sender = requests.remove(&response.id);
                                tracing::debug!(
                                    "Sender found for id={}: {}",
                                    response.id,
                                    sender.is_some()
                                );
                                if let Some(sender) = sender {
                                    if sender.send(Ok(response.clone())).is_err() {
                                        tracing::warn!(
                                            "Failed to send response to oneshot channel for id={}",
                                            response.id
                                        );
                                    }
                                } else {
                                    tracing::warn!(
                                        "No sender found for response id={}",
                                        response.id
                                    );
                                }
                            }
                            McpMessage::Notification(notification) => {
                                tracing::debug!("Received notification: {}", notification.method);
                                let listeners = notification_listeners.lock().await.clone();
                                for listener in listeners {
                                    let _ = listener.try_send(notification.clone());
                                }
                            }
                            McpMessage::Request(_) => {
                                tracing::warn!("Client received unexpected request");
                            }
                        }
                    Err(e) => {
                        tracing::error!("Message loop error: {}", e);
                        return Err(e);
                    }
                }
            }
        });

        self.message_loop_handle = Some(handle);
        Ok(())
    }
    /// Stop the message handling loop
    pub async fn stop_message_loop(&mut self) -> Result<(), Error> {
        if let Some(handle) = self.message_loop_handle.take() {
            handle.abort();
            let _ = handle.await;
        }
        Ok(())
    }

    /// Send a request and wait for a response
    pub async fn send_request<P, R>(&self, method: &str, params: P) -> Result<R, Error>
        where P: Serialize + Send + Sync, R: DeserializeOwned + Send + Sync
    {
        let id = self.request_id_counter.fetch_add(1, Ordering::SeqCst);
        tracing::debug!("Preparing request id={} for method={}", id, method);

        let request = Request {
            jsonrpc: "2.0".to_string(),
            id,
            method: method.to_string(),
            params: Some(serde_json::to_value(params).map_err(Error::Json)?),
        };

        if let Err(e) = validate_request(&request, &self.validation_config) {
            tracing::error!("Request validation failed: {}", e);
            return Err(e);
        }

        let (tx, rx) = oneshot::channel();

        {
            let mut pending = self.pending_requests.lock().await;
            tracing::debug!("Registering request id={} in pending_requests", id);
            pending.insert(id, tx);
        }

        tracing::debug!("About to acquire transport lock for request id={}", id);
        let send_result = {
            let start = std::time::Instant::now();

            // Use a timeout to acquire the transport lock to avoid deadlocks
            let transport_lock_result = tokio::time::timeout(
                std::time::Duration::from_secs(10),
                self.transport.lock()
            ).await;

            match transport_lock_result {
                Ok(mut transport_guard) => {
                    let elapsed = start.elapsed();
                    tracing::debug!(
                        "Acquired transport lock for request id={} after {:?}",
                        id,
                        elapsed
                    );

                    tracing::debug!("Sending request id={} via transport", id);
                    let result = transport_guard.send(&McpMessage::Request(request)).await;
                    tracing::debug!(
                        "Transport.send completed for request id={}, result: {:?}",
                        id,
                        result.is_ok()
                    );
                    result
                }
                Err(_) => {
                    tracing::error!(
                        "Timeout waiting to acquire transport lock for request id={}",
                        id
                    );
                    Err(Error::Transport("Timeout waiting to acquire transport lock".to_string()))
                }
            }
        };
        tracing::debug!("Released transport lock for request id={}", id);

        if let Err(e) = send_result {
            tracing::error!("Failed to send request id={}: {}", id, e);
            let mut pending = self.pending_requests.lock().await;
            pending.remove(&id);
            return Err(e);
        }

        tracing::debug!("Request id={} sent successfully, waiting for response", id);

        let response = tokio::time
            ::timeout(std::time::Duration::from_secs(30), rx).await
            .map_err(|_| {
                Error::Transport(format!("Timeout waiting for response to request id={}", id))
            })?
            .map_err(|_| Error::Transport("Response channel closed".to_string()))?;

        let response = response?;

        if self.validation_config.validate_responses {
            if let Err(e) = validate_response(&response, method, &self.validation_config) {
                tracing::error!("Response validation failed: {}", e);
                return Err(e);
            }
        }

        match response.outcome {
            ResponseOutcome::Success { result } => {
                tracing::debug!("Received successful response for id={}", id);
                Ok(serde_json::from_value(result).map_err(Error::Json)?)
            }
            ResponseOutcome::Error { error } => {
                tracing::error!(
                    "Received error response for id={}: {} (code: {})",
                    id,
                    error.message,
                    error.code
                );
                Err(
                    Error::Protocol(
                        format!("Server returned error: {} (code: {})", error.message, error.code)
                    )
                )
            }
        }
    }

    /// Register a listener for notifications
    pub async fn register_notification_listener(&self) -> mpsc::Receiver<Notification> {
        let (tx, rx) = mpsc::channel(100);

        let mut listeners = self.notification_listeners.lock().await;
        listeners.push(tx);

        rx
    }

    /// Initialize the connection with the server
    pub async fn initialize(
        &self,
        params: InitializeRequestParams
    ) -> Result<InitializeResult, Error> {
        self.send_request("initialize", params).await
    }

    /// List available resources
    pub async fn list_resources(
        &self,
        params: ListResourcesParams
    ) -> Result<ListResourcesResult, Error> {
        self.send_request("resources/list", params).await
    }

    /// Get a resource by URI
    pub async fn get_resource(
        &self,
        params: GetResourceParams
    ) -> Result<GetResourceResult, Error> {
        self.send_request("resources/get", params).await
    }

    /// Create a new resource
    pub async fn create_resource(
        &self,
        params: CreateResourceParams
    ) -> Result<CreateResourceResult, Error> {
        self.send_request("resources/create", params).await
    }

    /// Update an existing resource
    pub async fn update_resource(
        &self,
        params: UpdateResourceParams
    ) -> Result<UpdateResourceResult, Error> {
        self.send_request("resources/update", params).await
    }

    /// Delete a resource
    pub async fn delete_resource(
        &self,
        params: DeleteResourceParams
    ) -> Result<DeleteResourceResult, Error> {
        self.send_request("resources/delete", params).await
    }

    /// List available prompts
    pub async fn list_prompts(
        &self,
        params: ListPromptsParams
    ) -> Result<ListPromptsResult, Error> {
        self.send_request("prompts/list", params).await
    }

    /// Create a new prompt
    pub async fn create_prompt(
        &self,
        params: CreatePromptParams
    ) -> Result<CreatePromptResult, Error> {
        self.send_request("prompts/create", params).await
    }

    /// Update an existing prompt
    pub async fn update_prompt(
        &self,
        params: UpdatePromptParams
    ) -> Result<UpdatePromptResult, Error> {
        self.send_request("prompts/update", params).await
    }

    /// Delete a prompt
    pub async fn delete_prompt(
        &self,
        params: DeletePromptParams
    ) -> Result<DeletePromptResult, Error> {
        self.send_request("prompts/delete", params).await
    }

    /// Render a prompt with the given arguments
    pub async fn render_prompt(
        &self,
        params: RenderPromptParams
    ) -> Result<RenderPromptResult, Error> {
        self.send_request("prompts/render", params).await
    }

    /// List available tools
    pub async fn list_tools(&self, params: ListToolsParams) -> Result<ListToolsResult, Error> {
        self.send_request("tools/list", params).await
    }

    /// Call a tool
    pub async fn call_tool(&self, params: CallToolParams) -> Result<CallToolResult, Error> {
        self.send_request("tools/call", params).await
    }

    /// Close the client and its transport
    pub async fn close(&self) -> Result<(), Error> {
        let mut transport = self.transport.lock().await;
        transport.close().await
    }

    /// Create a FileResource instance without uploading it
    pub fn file_resource(
        &self,
        name: &str,
        path: &std::path::Path,
        description: Option<String>,
        mime_type: Option<String>,
        is_binary: bool
    ) -> Result<FileResource, Error> {
        FileResource::new(None, name.to_string(), path, description, mime_type, is_binary).map_err(
            |e| Error::Resource(format!("Failed to create file resource: {}", e))
        )
    }
}

/// Builder for creating and configuring a client
pub struct ClientBuilder<T> {
    transport: T,
}

impl<T: Transport + 'static> ClientBuilder<T> {
    /// Create a new client builder with the given transport
    pub fn new(transport: T) -> Self {
        Self { transport }
    }

    /// Build the client and start its message loop
    pub async fn build(self) -> Result<Client<T>, Error> {
        let mut client = Client::new(self.transport);
        client.start_message_loop()?;
        Ok(client)
    }
}

/// A session-oriented wrapper for the MCP client
///
/// This provides a higher-level session-based interface for working with MCP servers,
/// including support for file resources, progress notifications, and message creation.
pub struct ClientSession<T: Transport + 'static> {
    /// The underlying client
    client: Client<T>,
    /// Session state information
    session_info: Arc<Mutex<Option<InitializeResult>>>,
    /// Indicates whether the session is started
    is_started: bool,
    /// Server information
    server_info: Option<InitializeResult>,
}

impl<T: Transport + 'static> ClientSession<T> {
    /// Create a new client session with the given transport
    pub fn new(transport: T) -> Self {
        Self {
            client: Client::new(transport),
            session_info: Arc::new(Mutex::new(None)),
            is_started: false,
            server_info: None,
        }
    }

    /// Configure validation for this session
    pub fn with_validation_config(self, config: ValidationConfig) -> Self {
        Self {
            client: self.client.with_validation_config(config),
            session_info: self.session_info,
            is_started: self.is_started,
            server_info: self.server_info,
        }
    }

    /// Start the session by initializing the message loop
    pub async fn start(&mut self) -> Result<(), Error> {
        if self.is_started {
            tracing::warn!("ClientSession.start() called but session is already started");
            return Ok(());
        }

        tracing::info!("Starting client session message loop");
        self.client.start_message_loop()?;
        self.is_started = true;
        Ok(())
    }

    /// Initialize the connection with the server and store session info
    pub async fn initialize(
        &mut self,
        params: InitializeRequestParams
    ) -> Result<InitializeResult, Error> {
        if !self.is_started {
            return Err(
                Error::Protocol(
                    "Session not started. Call start() before making requests.".to_string()
                )
            );
        }

        tracing::info!("Sending initialize request");
        let result = self.client.initialize(params).await?;
        self.server_info = Some(result.clone());
        tracing::info!("Initialize request completed successfully");
        Ok(result)
    }

    /// Get the current session information if initialized
    pub async fn session_info(&self) -> Option<InitializeResult> {
        let session_info = self.session_info.lock().await;
        session_info.clone()
    }

    /// Close the session, stopping the message loop and closing the transport
    pub async fn close(&mut self) -> Result<(), Error> {
        self.client.stop_message_loop().await?;
        self.client.close().await
    }

    /// Send a request to the server and await the response
    pub async fn send_request<P, R>(&self, method: &str, params: P) -> Result<R, Error>
        where P: Serialize + Send + Sync, R: DeserializeOwned + Send + Sync
    {
        self.client.send_request(method, params).await
    }

    /// Register a listener for notifications
    pub async fn register_notification_listener(&self) -> mpsc::Receiver<Notification> {
        self.client.register_notification_listener().await
    }

    //==== File Resource Methods ====

    /// Create a file resource from a local path
    pub async fn create_file_resource(
        &self,
        name: &str,
        path: &std::path::Path,
        description: Option<String>,
        mime_type: Option<String>
    ) -> Result<CreateResourceResult, Error> {
        // Create a FileResource object
        let file_resource = FileResource::new(
            None,
            name.to_string(),
            path,
            description,
            mime_type,
            false // Not binary
        ).map_err(|e| Error::Resource(format!("Failed to create file resource: {}", e)))?;

        // Convert to params and create on the server
        let params = file_resource
            .to_create_params()
            .map_err(|e| Error::Resource(format!("Failed to read file: {}", e)))?;

        self.client.create_resource(params).await
    }

    /// Create a binary file resource from a local path
    pub async fn create_binary_file_resource(
        &self,
        name: &str,
        path: &std::path::Path,
        description: Option<String>,
        mime_type: Option<String>
    ) -> Result<CreateResourceResult, Error> {
        // Create a FileResource object
        let file_resource = FileResource::new(
            None,
            name.to_string(),
            path,
            description,
            mime_type,
            true // Binary
        ).map_err(|e| Error::Resource(format!("Failed to create file resource: {}", e)))?;

        // Convert to params and create on the server
        let params = file_resource
            .to_create_params()
            .map_err(|e| Error::Resource(format!("Failed to read file: {}", e)))?;

        self.client.create_resource(params).await
    }

    //==== Tools and Notifications Methods ====

    /// Call a tool with the given parameters
    pub async fn call_tool(&self, params: CallToolParams) -> Result<CallToolResult, Error> {
        self.client.call_tool(params).await
    }

    /// Send a progress notification to the server
    pub async fn send_progress_notification(
        &self,
        tool_name: &str,
        progress: f64,
        message: Option<String>
    ) -> Result<(), Error> {
        // Create the notification message
        let notification = Notification {
            jsonrpc: "2.0".to_string(),
            method: "tools/progress".to_string(),
            params: Some(
                serde_json::json!({
                "tool_name": tool_name,
                "progress": progress,
                "message": message
            })
            ),
        };

        // Send the notification
        let mut transport = self.client.transport.lock().await;
        transport.send(&McpMessage::Notification(notification)).await
    }

    //==== Message Creation Methods ====

    /// Create a message for sampling
    pub fn create_message(&self, role: Role, content: Vec<ContentPart>) -> Message {
        Message { role, content }
    }

    /// Create a text content part
    pub fn create_text_content(&self, text: &str) -> ContentPart {
        ContentPart::Text(text.to_string())
    }

    /// Create an image content part from a resource URI
    pub fn create_image_content(&self, uri: &str) -> ContentPart {
        ContentPart::Image {
            uri: uri.to_string(),
        }
    }

    //==== Standard MCP Operations ====

    /// List available resources
    pub async fn list_resources(
        &self,
        params: ListResourcesParams
    ) -> Result<ListResourcesResult, Error> {
        self.client.list_resources(params).await
    }

    /// Get a specific resource
    pub async fn get_resource(
        &self,
        params: GetResourceParams
    ) -> Result<GetResourceResult, Error> {
        self.client.get_resource(params).await
    }

    /// Create a new resource
    pub async fn create_resource(
        &self,
        params: CreateResourceParams
    ) -> Result<CreateResourceResult, Error> {
        self.client.create_resource(params).await
    }

    /// Update an existing resource
    pub async fn update_resource(
        &self,
        params: UpdateResourceParams
    ) -> Result<UpdateResourceResult, Error> {
        self.client.update_resource(params).await
    }

    /// Delete a resource
    pub async fn delete_resource(
        &self,
        params: DeleteResourceParams
    ) -> Result<DeleteResourceResult, Error> {
        self.client.delete_resource(params).await
    }

    /// List available prompts
    pub async fn list_prompts(
        &self,
        params: ListPromptsParams
    ) -> Result<ListPromptsResult, Error> {
        self.client.list_prompts(params).await
    }

    /// Create a new prompt
    pub async fn create_prompt(
        &self,
        params: CreatePromptParams
    ) -> Result<CreatePromptResult, Error> {
        self.client.create_prompt(params).await
    }

    /// Update an existing prompt
    pub async fn update_prompt(
        &self,
        params: UpdatePromptParams
    ) -> Result<UpdatePromptResult, Error> {
        self.client.update_prompt(params).await
    }

    /// Delete a prompt
    pub async fn delete_prompt(
        &self,
        params: DeletePromptParams
    ) -> Result<DeletePromptResult, Error> {
        self.client.delete_prompt(params).await
    }

    /// Render a prompt with the given arguments
    pub async fn render_prompt(
        &self,
        params: RenderPromptParams
    ) -> Result<RenderPromptResult, Error> {
        self.client.render_prompt(params).await
    }

    /// List available tools
    pub async fn list_tools(&self, params: ListToolsParams) -> Result<ListToolsResult, Error> {
        self.client.list_tools(params).await
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::errors::error_codes;
    use crate::types::protocol::error_response;
    use async_trait::async_trait;
    use std::sync::atomic::{ AtomicBool, Ordering };

    struct MockTransport {
        connected: Arc<AtomicBool>,
        response: Option<McpMessage>,
    }

    impl MockTransport {
        fn new(response: Option<McpMessage>) -> Self {
            Self {
                connected: Arc::new(AtomicBool::new(true)),
                response,
            }
        }
    }

    #[async_trait]
    impl Transport for MockTransport {
        async fn receive(&mut self) -> Result<(Option<String>, McpMessage), Error> {
            if let Some(response) = self.response.take() {
                return Ok((None, response));
            }
            Err(Error::Transport("No more messages".to_string()))
        }

        async fn send(&mut self, _message: &McpMessage) -> Result<(), Error> {
            Ok(())
        }

        async fn send_to(&mut self, _client_id: &str, message: &McpMessage) -> Result<(), Error> {
            // For client transports, send_to is the same as send
            self.send(message).await
        }

        async fn is_connected(&self) -> bool {
            self.connected.load(Ordering::SeqCst)
        }

        async fn close(&mut self) -> Result<(), Error> {
            self.connected.store(false, Ordering::SeqCst);
            Ok(())
        }

        async fn start(&mut self) -> Result<(), Error> {
            Ok(())
        }
    }

    #[tokio::test]
    async fn test_send_request_success() {
        let response = McpMessage::Response(Response {
            jsonrpc: "2.0".to_string(),
            id: 1,
            outcome: ResponseOutcome::Success {
                result: serde_json::json!({"protocol_version": "1.0"}),
            },
        });

        let transport = MockTransport::new(Some(response));
        let client = Client::new(transport);

        let result: InitializeResult = client
            .send_request("initialize", InitializeRequestParams {
                protocol_version: "1.0".to_string(),
                capabilities: crate::types::initialize::ClientCapabilities {
                    roots: None,
                    experimental: None,
                    sampling: None,
                },
                client_info: None,
            }).await
            .unwrap();

        assert_eq!(result.protocol_version, "1.0");
    }

    #[tokio::test]
    async fn test_send_request_error() {
        let response = McpMessage::Response(
            error_response(1, error_codes::METHOD_NOT_FOUND, "Method not found", None)
        );

        let transport = MockTransport::new(Some(response));
        let client = Client::new(transport);

        let result = client.send_request::<(), ()>("unknown_method", ()).await;

        assert!(result.is_err());
    }
}


<file_info>
path: src/types/tools.rs
name: tools.rs
</file_info>
//! MCP Tool Types
//!
//! This module defines types related to tools in the MCP protocol, including
//! `Tool` and `CallToolParams`, which allow the AI application to perform actions
//! or computations via the server.

use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Represents a parameter for a tool
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ToolParameterType {
    #[serde(rename = "string")]
    String,
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "boolean")]
    Boolean,
    #[serde(rename = "object")]
    Object,
    #[serde(rename = "array")]
    Array,
}

/// Represents a parameter for a tool
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToolParameter {
    /// Name of the parameter
    pub name: String,
    /// Type of the parameter
    #[serde(rename = "type")]
    pub type_name: ToolParameterType,
    /// Description of the parameter
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// Whether the parameter is required
    #[serde(skip_serializing_if = "Option::is_none")]
    pub required: Option<bool>,
    /// Schema for the parameter (for complex types)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema: Option<serde_json::Value>,
    /// Default value
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default: Option<serde_json::Value>,
    /// Enum values (for string parameters)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enum_values: Option<Vec<String>>,
}

/// Represents a tool in the MCP protocol
#[derive(Debug, Clone)]
pub struct Tool {
    /// Unique name of the tool
    pub name: String,
    /// Description of what the tool does
    pub description: String,
    /// Parameters that the tool accepts
    pub parameters: Option<Vec<ToolParameter>>,
    /// Type of the return value
    pub return_type: Option<String>,
    /// Schema for the return value
    pub return_schema: Option<serde_json::Value>,
    /// Whether the tool execution is streaming
    pub is_streaming: Option<bool>,
    /// Whether the tool can be cancelled
    pub is_cancellable: Option<bool>,
    /// Maximum execution time in seconds
    pub timeout_seconds: Option<u64>,
}

/// Parameters for listing tools
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct ListToolsParams {
    /// Optional pagination token
    #[serde(skip_serializing_if = "Option::is_none")]
    pub page_token: Option<String>,
    /// Optional limit on the number of tools to return
    #[serde(skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i32>,
}

/// Result of listing tools
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct ListToolsResult {
    /// List of tools
    pub tools: Vec<Tool>,
    /// Token for the next page (if there are more tools)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_page_token: Option<String>,
}

/// Parameters for calling a tool
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct CallToolParams {
    /// Name of the tool to call (field used by Python/JS clients)
    #[serde(default)]
    pub name: String,
    /// Arguments to pass to the tool (field used by Python/JS clients)
    #[serde(default)]
    pub arguments: HashMap<String, serde_json::Value>,
}

/// Text content for a message or tool result
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct TextContent {
    /// The type of content (always "text" for TextContent)
    #[serde(rename = "type")]
    pub content_type: String,

    /// The text content
    pub text: String,

    /// Optional annotations (not used in this implementation)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub annotations: Option<serde_json::Value>,
}

/// Result of calling a tool
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct CallToolResult {
    /// Content of the tool call result
    pub content: Vec<serde_json::Value>,

    /// Flag indicating whether this is an error (using camelCase for Python compatibility)
    #[serde(rename = "isError")]
    pub is_error: bool,
}

// Instead of directly implementing JsonSchema for Tool, create a helper struct
// that can be used for JsonSchema derivation
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct ToolSchema {
    /// Unique name of the tool
    pub name: String,
    /// Description of what the tool does
    pub description: String,
    /// Input schema for the tool
    #[serde(rename = "inputSchema")]
    pub input_schema: serde_json::Value,
    /// Type of the return value
    #[serde(rename = "returnType", skip_serializing_if = "Option::is_none")]
    pub return_type: Option<String>,
    /// Schema for the return value
    #[serde(rename = "returnSchema", skip_serializing_if = "Option::is_none")]
    pub return_schema: Option<serde_json::Value>,
    /// Whether the tool execution is streaming
    #[serde(rename = "isStreaming", skip_serializing_if = "Option::is_none")]
    pub is_streaming: Option<bool>,
    /// Whether the tool can be cancelled
    #[serde(rename = "isCancellable", skip_serializing_if = "Option::is_none")]
    pub is_cancellable: Option<bool>,
    /// Maximum execution time in seconds
    #[serde(rename = "timeoutSeconds", skip_serializing_if = "Option::is_none")]
    pub timeout_seconds: Option<u64>,
}

// Add a conversion from Tool to ToolSchema
impl From<&Tool> for ToolSchema {
    fn from(tool: &Tool) -> Self {
        // Build inputSchema from parameters
        let input_schema = if let Some(params) = &tool.parameters {
            let mut properties = serde_json::Map::new();
            let mut required = Vec::new();

            for param in params {
                // Create schema for this parameter
                let mut schema = match &param.schema {
                    Some(schema) => schema.clone(),
                    None => {
                        // Create default schema based on type_name
                        let type_str = match param.type_name {
                            ToolParameterType::String => "string",
                            ToolParameterType::Number => "number",
                            ToolParameterType::Boolean => "boolean",
                            ToolParameterType::Object => "object",
                            ToolParameterType::Array => "array",
                        };
                        serde_json::json!({ "type": type_str })
                    }
                };

                // Add enum values if present
                if let Some(enum_values) = &param.enum_values {
                    if !enum_values.is_empty() {
                        if let Some(obj) = schema.as_object_mut() {
                            obj.insert(
                                "enum".to_string(),
                                serde_json::Value::Array(
                                    enum_values
                                        .iter()
                                        .map(|v| serde_json::Value::String(v.clone()))
                                        .collect(),
                                ),
                            );
                        }
                    }
                }

                // Add default value if present
                if let Some(default_value) = &param.default {
                    if let Some(obj) = schema.as_object_mut() {
                        obj.insert("default".to_string(), default_value.clone());
                    }
                }

                // Add to properties map
                properties.insert(param.name.clone(), schema);

                // Add to required array if parameter is required
                if param.required.unwrap_or(false) {
                    required.push(param.name.clone());
                }
            }

            // Create the inputSchema object
            serde_json::json!({
                "type": "object",
                "properties": properties,
                "required": required
            })
        } else {
            // Add minimal inputSchema if no parameters
            serde_json::json!({
                "type": "object",
                "properties": {}
            })
        };

        ToolSchema {
            name: tool.name.clone(),
            description: tool.description.clone(),
            input_schema,
            return_type: tool.return_type.clone(),
            return_schema: tool.return_schema.clone(),
            is_streaming: tool.is_streaming,
            is_cancellable: tool.is_cancellable,
            timeout_seconds: tool.timeout_seconds,
        }
    }
}

// Implement Serialize for Tool to properly handle the inputSchema field
impl Serialize for Tool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        ToolSchema::from(self).serialize(serializer)
    }
}

// Implement Deserialize for Tool
impl<'de> Deserialize<'de> for Tool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(Deserialize)]
        struct ToolHelper {
            name: String,
            description: String,
            #[serde(rename = "inputSchema")]
            input_schema: Option<serde_json::Value>,
            #[serde(rename = "returnType")]
            return_type: Option<String>,
            #[serde(rename = "returnSchema")]
            return_schema: Option<serde_json::Value>,
            #[serde(rename = "isStreaming")]
            is_streaming: Option<bool>,
            #[serde(rename = "isCancellable")]
            is_cancellable: Option<bool>,
            #[serde(rename = "timeoutSeconds")]
            timeout_seconds: Option<u64>,
        }

        let helper = ToolHelper::deserialize(deserializer)?;

        // Convert inputSchema back to parameters
        let parameters = if let Some(input_schema) = helper.input_schema {
            if let Some(properties) = input_schema.get("properties").and_then(|p| p.as_object()) {
                let required: Vec<String> = input_schema
                    .get("required")
                    .and_then(|r| r.as_array())
                    .map(|arr| {
                        arr.iter()
                            .filter_map(|v| v.as_str().map(|s| s.to_string()))
                            .collect()
                    })
                    .unwrap_or_default();

                let mut params = Vec::new();
                for (name, schema) in properties {
                    let type_name = schema
                        .get("type")
                        .and_then(|t| t.as_str())
                        .map(|t| {
                            match t {
                                "string" => ToolParameterType::String,
                                "number" => ToolParameterType::Number,
                                "boolean" => ToolParameterType::Boolean,
                                "object" => ToolParameterType::Object,
                                "array" => ToolParameterType::Array,
                                _ => ToolParameterType::String, // Default to string for unknown types
                            }
                        })
                        .unwrap_or(ToolParameterType::String);

                    let enum_values = schema.get("enum").and_then(|e| e.as_array()).map(|arr| {
                        arr.iter()
                            .filter_map(|v| v.as_str().map(|s| s.to_string()))
                            .collect()
                    });

                    let default = schema.get("default").cloned();

                    params.push(ToolParameter {
                        name: name.clone(),
                        type_name,
                        description: None, // Description is not stored in JSON Schema
                        required: Some(required.contains(name)),
                        schema: Some(schema.clone()),
                        default,
                        enum_values,
                    });
                }

                Some(params)
            } else {
                None
            }
        } else {
            None
        };

        Ok(Tool {
            name: helper.name,
            description: helper.description,
            parameters,
            return_type: helper.return_type,
            return_schema: helper.return_schema,
            is_streaming: helper.is_streaming,
            is_cancellable: helper.is_cancellable,
            timeout_seconds: helper.timeout_seconds,
        })
    }
}

// Fix the JsonSchema implementation to avoid using 'gen' as parameter name
impl JsonSchema for Tool {
    fn schema_name() -> String {
        "Tool".to_string()
    }

    fn json_schema(
        schema_generator: &mut schemars::r#gen::SchemaGenerator,
    ) -> schemars::schema::Schema {
        <ToolSchema as JsonSchema>::json_schema(schema_generator)
    }
}

/// Builder for tool parameter
pub struct ToolParameterBuilder {
    name: String,
    type_name: ToolParameterType,
    description: Option<String>,
    required: Option<bool>,
    schema: Option<serde_json::Value>,
    default: Option<serde_json::Value>,
    enum_values: Option<Vec<String>>,
}

impl ToolParameterBuilder {
    /// Create a new parameter builder with the given name and type
    pub fn new(name: impl Into<String>, type_name: ToolParameterType) -> Self {
        Self {
            name: name.into(),
            type_name,
            description: None,
            required: None,
            schema: None,
            default: None,
            enum_values: None,
        }
    }

    /// Set the description for this parameter
    pub fn description(mut self, description: impl Into<String>) -> Self {
        self.description = Some(description.into());
        self
    }

    /// Mark this parameter as required or optional
    pub fn required(mut self, required: bool) -> Self {
        self.required = Some(required);
        self
    }

    /// Set a custom JSON schema for this parameter
    pub fn schema(mut self, schema: serde_json::Value) -> Self {
        self.schema = Some(schema);
        self
    }

    /// Set a default value for this parameter
    pub fn default<T: Serialize>(mut self, value: T) -> Result<Self, serde_json::Error> {
        self.default = Some(serde_json::to_value(value)?);
        Ok(self)
    }

    /// Set enum values for string parameters
    pub fn enum_values(mut self, values: Vec<impl Into<String>>) -> Self {
        self.enum_values = Some(values.into_iter().map(|v| v.into()).collect());
        self
    }

    /// Build the parameter
    pub fn build(self) -> ToolParameter {
        ToolParameter {
            name: self.name,
            type_name: self.type_name,
            description: self.description,
            required: self.required,
            schema: self.schema,
            default: self.default,
            enum_values: self.enum_values,
        }
    }
}

/// Builder for creating tools
pub struct ToolBuilder {
    name: String,
    description: String,
    parameters: Vec<ToolParameter>,
    return_type: Option<String>,
    return_schema: Option<serde_json::Value>,
    is_streaming: Option<bool>,
    is_cancellable: Option<bool>,
    timeout_seconds: Option<u64>,
}

impl ToolBuilder {
    /// Create a new tool builder with the given name and description
    pub fn new(name: impl Into<String>, description: impl Into<String>) -> Self {
        Self {
            name: name.into(),
            description: description.into(),
            parameters: Vec::new(),
            return_type: None,
            return_schema: None,
            is_streaming: None,
            is_cancellable: None,
            timeout_seconds: None,
        }
    }

    /// Add a parameter to this tool
    pub fn add_parameter(mut self, parameter: ToolParameter) -> Self {
        self.parameters.push(parameter);
        self
    }

    /// Starts building a parameter with the given name and type.
    /// This returns a tuple of (ToolBuilder, ToolParameterBuilder) to allow for fluent parameter definition
    /// while preserving the tool builder context.
    pub fn parameter(
        self,
        name: impl Into<String>,
        type_name: ToolParameterType,
    ) -> (Self, ToolParameterBuilder) {
        (self, ToolParameterBuilder::new(name, type_name))
    }

    /// Add the parameter built by the parameter builder
    pub fn with_parameter(mut self, parameter_builder: ToolParameterBuilder) -> Self {
        self.parameters.push(parameter_builder.build());
        self
    }

    /// Set the return type for this tool
    pub fn return_type(mut self, return_type: impl Into<String>) -> Self {
        self.return_type = Some(return_type.into());
        self
    }

    /// Set the return schema for this tool
    pub fn return_schema(mut self, schema: serde_json::Value) -> Self {
        self.return_schema = Some(schema);
        self
    }

    /// Set whether the tool streams results
    pub fn streaming(mut self, is_streaming: bool) -> Self {
        self.is_streaming = Some(is_streaming);
        self
    }

    /// Set whether the tool can be cancelled
    pub fn cancellable(mut self, is_cancellable: bool) -> Self {
        self.is_cancellable = Some(is_cancellable);
        self
    }

    /// Set the timeout in seconds
    pub fn timeout(mut self, seconds: u64) -> Self {
        self.timeout_seconds = Some(seconds);
        self
    }

    /// Build the tool
    pub fn build(self) -> Tool {
        Tool {
            name: self.name,
            description: self.description,
            parameters: if self.parameters.is_empty() {
                None
            } else {
                Some(self.parameters)
            },
            return_type: self.return_type,
            return_schema: self.return_schema,
            is_streaming: self.is_streaming,
            is_cancellable: self.is_cancellable,
            timeout_seconds: self.timeout_seconds,
        }
    }
}

// Helper traits and implementations to make the builder pattern more ergonomic

/// Helper trait for creating tool parameters with a specific type
pub trait IntoToolParameter {
    fn string_param(self, name: impl Into<String>) -> ToolParameterBuilder;
    fn number_param(self, name: impl Into<String>) -> ToolParameterBuilder;
    fn boolean_param(self, name: impl Into<String>) -> ToolParameterBuilder;
    fn object_param(self, name: impl Into<String>) -> ToolParameterBuilder;
    fn array_param(self, name: impl Into<String>) -> ToolParameterBuilder;
}

impl IntoToolParameter for &ToolBuilder {
    fn string_param(self, name: impl Into<String>) -> ToolParameterBuilder {
        ToolParameterBuilder::new(name, ToolParameterType::String)
    }

    fn number_param(self, name: impl Into<String>) -> ToolParameterBuilder {
        ToolParameterBuilder::new(name, ToolParameterType::Number)
    }

    fn boolean_param(self, name: impl Into<String>) -> ToolParameterBuilder {
        ToolParameterBuilder::new(name, ToolParameterType::Boolean)
    }

    fn object_param(self, name: impl Into<String>) -> ToolParameterBuilder {
        ToolParameterBuilder::new(name, ToolParameterType::Object)
    }

    fn array_param(self, name: impl Into<String>) -> ToolParameterBuilder {
        ToolParameterBuilder::new(name, ToolParameterType::Array)
    }
}

// Extension trait for ToolBuilder
pub trait ToolBuilderExt {
    fn add_string_parameter(self, name: impl Into<String>) -> (Box<Self>, ToolParameterBuilder);
    fn add_number_parameter(self, name: impl Into<String>) -> (Box<Self>, ToolParameterBuilder);
    fn add_boolean_parameter(self, name: impl Into<String>) -> (Box<Self>, ToolParameterBuilder);
    fn add_object_parameter(self, name: impl Into<String>) -> (Box<Self>, ToolParameterBuilder);
    fn add_array_parameter(self, name: impl Into<String>) -> (Box<Self>, ToolParameterBuilder);
}

impl ToolBuilderExt for ToolBuilder {
    fn add_string_parameter(self, name: impl Into<String>) -> (Box<Self>, ToolParameterBuilder) {
        let param_builder = ToolParameterBuilder::new(name, ToolParameterType::String);
        (Box::new(self), param_builder)
    }

    fn add_number_parameter(self, name: impl Into<String>) -> (Box<Self>, ToolParameterBuilder) {
        let param_builder = ToolParameterBuilder::new(name, ToolParameterType::Number);
        (Box::new(self), param_builder)
    }

    fn add_boolean_parameter(self, name: impl Into<String>) -> (Box<Self>, ToolParameterBuilder) {
        let param_builder = ToolParameterBuilder::new(name, ToolParameterType::Boolean);
        (Box::new(self), param_builder)
    }

    fn add_object_parameter(self, name: impl Into<String>) -> (Box<Self>, ToolParameterBuilder) {
        let param_builder = ToolParameterBuilder::new(name, ToolParameterType::Object);
        (Box::new(self), param_builder)
    }

    fn add_array_parameter(self, name: impl Into<String>) -> (Box<Self>, ToolParameterBuilder) {
        let param_builder = ToolParameterBuilder::new(name, ToolParameterType::Array);
        (Box::new(self), param_builder)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;

    #[test]
    fn test_tool_builder() {
        let tool = ToolBuilder::new("calculator", "Performs basic calculations")
            .add_parameter(
                ToolParameterBuilder::new("operation", ToolParameterType::String)
                    .description("Operation to perform")
                    .required(true)
                    .enum_values(vec!["add", "subtract", "multiply", "divide"])
                    .default("add")
                    .unwrap()
                    .build(),
            )
            .add_parameter(
                ToolParameterBuilder::new("a", ToolParameterType::Number)
                    .description("First operand")
                    .required(true)
                    .build(),
            )
            .add_parameter(
                ToolParameterBuilder::new("b", ToolParameterType::Number)
                    .description("Second operand")
                    .required(true)
                    .build(),
            )
            .return_type("object")
            .return_schema(json!({
                "type": "object",
                "properties": {
                    "result": { "type": "number" }
                },
                "required": ["result"]
            }))
            .streaming(false)
            .cancellable(false)
            .timeout(30)
            .build();

        assert_eq!(tool.name, "calculator");
        assert_eq!(tool.description, "Performs basic calculations");
        assert_eq!(tool.parameters.as_ref().unwrap().len(), 3);
        assert_eq!(tool.is_streaming, Some(false));
        assert_eq!(tool.is_cancellable, Some(false));
        assert_eq!(tool.timeout_seconds, Some(30));
    }

    #[test]
    fn test_tool_builder_with_extension_trait() {
        let (builder_box, param_builder) =
            ToolBuilder::new("calculator", "Performs basic calculations")
                .add_string_parameter("operation");

        let tool = (*builder_box)
            .with_parameter(
                param_builder
                    .description("Operation to perform")
                    .required(true)
                    .enum_values(vec!["add", "subtract", "multiply", "divide"])
                    .default("add")
                    .unwrap(),
            )
            .build();

        assert_eq!(tool.name, "calculator");
        assert_eq!(tool.parameters.as_ref().unwrap().len(), 1);
        assert_eq!(tool.parameters.as_ref().unwrap()[0].name, "operation");
    }
}


<file_info>
path: src/types/initialize.rs
name: initialize.rs
</file_info>
//! MCP Initialization Types
//!
//! This module defines types related to the initialization phase of the MCP protocol,
//! such as `InitializeRequestParams` and `InitializeResult`, ensuring proper setup and capability
//! negotiation between client and server.

use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

/// Parameters for the initialize request
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct InitializeRequestParams {
    /// The version of the MCP protocol, e.g., "2024-11-05"
    #[serde(rename = "protocolVersion")]
    pub protocol_version: String,
    /// Client capabilities for feature negotiation
    pub capabilities: ClientCapabilities,
    /// Information about the client implementation
    #[serde(rename = "clientInfo")]
    pub client_info: Option<Implementation>,
}

/// Result of the initialize request
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct InitializeResult {
    /// The negotiated protocol version
    #[serde(rename = "protocolVersion")]
    pub protocol_version: String,
    /// Server capabilities for feature negotiation
    pub capabilities: ServerCapabilities,
    /// Information about the server implementation
    #[serde(rename = "serverInfo")]
    pub server_info: Option<Implementation>,
    /// Optional instructions for the client
    #[serde(skip_serializing_if = "Option::is_none")]
    pub instructions: Option<String>,
}

/// Information about an implementation (client or server)
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct Implementation {
    /// Name of the implementation
    pub name: String,
    /// Version of the implementation
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// Client capabilities
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct ClientCapabilities {
    /// Root capabilities
    #[serde(skip_serializing_if = "Option::is_none")]
    pub roots: Option<RootCapabilities>,
    /// Sampling capabilities
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sampling: Option<SamplingCapabilities>,
    /// Experimental capabilities
    #[serde(skip_serializing_if = "Option::is_none")]
    pub experimental: Option<serde_json::Value>,
}

/// Server capabilities
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema, Default)]
pub struct ServerCapabilities {
    /// Resource capabilities
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resources: Option<ResourceCapabilities>,
    /// Tool capabilities
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tools: Option<ToolCapabilities>,
    /// Prompt capabilities
    #[serde(skip_serializing_if = "Option::is_none")]
    pub prompts: Option<PromptCapabilities>,
    /// Logging capabilities
    #[serde(skip_serializing_if = "Option::is_none")]
    pub logging: Option<LoggingCapabilities>,
    /// Experimental capabilities
    #[serde(skip_serializing_if = "Option::is_none")]
    pub experimental: Option<serde_json::Value>,
}

/// Root capabilities
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub struct RootCapabilities {
    /// Support for list changes
    #[serde(rename = "listChanged")]
    pub list_changed: bool,
}

/// Sampling capabilities
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub struct SamplingCapabilities {}

/// Resource capabilities
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub struct ResourceCapabilities {
    /// Support for resource subscription
    pub subscribe: bool,
    /// Support for list changes
    #[serde(rename = "listChanged")]
    pub list_changed: bool,
}

/// Prompt capabilities
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub struct PromptCapabilities {
    /// Support for list changes
    #[serde(rename = "listChanged")]
    pub list_changed: bool,
}

/// Tool capabilities
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub struct ToolCapabilities {
    /// Support for list changes
    #[serde(rename = "listChanged")]
    pub list_changed: bool,
}

/// Logging capabilities
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub struct LoggingCapabilities {
    // Custom logging fields can be added here as needed
}


<file_info>
path: src/server/tools/process_manager.rs
name: process_manager.rs
</file_info>
//! Process Manager for Tool Execution
//!
//! This module implements the process management functionality for executing tools
//! as external processes, capturing their output, and managing their lifecycle.

use crate::errors::Error;
use std::collections::HashMap;
use std::process::Stdio;
use std::sync::Arc;
use tokio::io::{AsyncBufReadExt, AsyncWriteExt, BufReader};
use tokio::process::{Child, Command as TokioCommand};
use tokio::sync::{Mutex, mpsc, oneshot};

/// Type of tool output (stdout or stderr)
#[derive(Debug, Clone)]
pub enum ToolOutputType {
    /// Standard output
    Stdout,
    /// Standard error
    Stderr,
}

/// Output from a tool process
#[derive(Debug, Clone)]
pub struct ToolOutput {
    /// Type of output (stdout or stderr)
    pub output_type: ToolOutputType,
    /// Content of the output
    pub content: String,
}

/// A running tool process
struct ToolProcess {
    /// The child process
    child: Child,
    /// The stdin handle for writing to the process
    stdin: Option<tokio::process::ChildStdin>,
    /// Channel for cancelling the process
    cancellation_tx: Option<oneshot::Sender<()>>,
}

/// Manager for spawning and interacting with tool processes
pub struct ToolProcessManager {
    /// Map of running processes by ID
    processes: Arc<Mutex<HashMap<String, ToolProcess>>>,
}

impl ToolProcessManager {
    /// Create a new tool process manager
    pub fn new() -> Self {
        Self {
            processes: Arc::new(Mutex::new(HashMap::new())),
        }
    }

    /// Spawn a new process for a tool
    pub async fn spawn_process(
        &self,
        tool_id: &str,
        command: &str,
        args: &[&str],
        env: HashMap<String, String>,
    ) -> Result<mpsc::Receiver<ToolOutput>, Error> {
        let mut command = TokioCommand::new(command);
        command
            .args(args)
            .stdin(Stdio::piped())
            .stdout(Stdio::piped())
            .stderr(Stdio::piped());

        // Add environment variables
        for (key, value) in env {
            command.env(key, value);
        }

        // Spawn the process
        let mut child = command
            .spawn()
            .map_err(|e| Error::Tool(format!("Failed to spawn process: {}", e)))?;

        let stdin = child.stdin.take();
        let stdout = child
            .stdout
            .take()
            .ok_or_else(|| Error::Tool("Failed to capture stdout".to_string()))?;
        let stderr = child
            .stderr
            .take()
            .ok_or_else(|| Error::Tool("Failed to capture stderr".to_string()))?;

        // Create communication channels
        let (output_tx, output_rx) = mpsc::channel(100);
        let (cancel_tx, cancel_rx) = oneshot::channel();

        // Store the process
        let mut processes = self.processes.lock().await;
        processes.insert(
            tool_id.to_string(),
            ToolProcess {
                child,
                stdin,
                cancellation_tx: Some(cancel_tx),
            },
        );

        // Process stdout/stderr in background tasks
        self.process_output(stdout, output_tx.clone(), ToolOutputType::Stdout);
        self.process_output(stderr, output_tx.clone(), ToolOutputType::Stderr);

        // Handle cancellation
        let processes_ref = self.processes.clone();
        let tool_id = tool_id.to_string();
        tokio::spawn(async move {
            let _ = cancel_rx.await;
            let mut processes = processes_ref.lock().await;
            if let Some(process) = processes.get_mut(&tool_id) {
                let _ = process.child.kill().await;
            }
            processes.remove(&tool_id);
        });

        Ok(output_rx)
    }

    /// Process output from a subprocess
    fn process_output<R: tokio::io::AsyncRead + Unpin + Send + 'static>(
        &self,
        reader: R,
        tx: mpsc::Sender<ToolOutput>,
        output_type: ToolOutputType,
    ) {
        let mut buf_reader = BufReader::new(reader);
        let mut line = String::new();

        tokio::spawn(async move {
            loop {
                line.clear();
                match buf_reader.read_line(&mut line).await {
                    Ok(0) => {
                        break;
                    } // EOF
                    Ok(_) => {
                        let output = ToolOutput {
                            output_type: output_type.clone(),
                            content: line.clone(),
                        };

                        if tx.send(output).await.is_err() {
                            break;
                        }
                    }
                    Err(_) => {
                        break;
                    }
                }
            }
        });
    }

    /// Send input to a running process
    pub async fn send_input(&self, tool_id: &str, input: &str) -> Result<(), Error> {
        let mut processes = self.processes.lock().await;
        let process = processes
            .get_mut(tool_id)
            .ok_or_else(|| Error::Tool(format!("Process not found: {}", tool_id)))?;

        if let Some(stdin) = &mut process.stdin {
            stdin
                .write_all(input.as_bytes())
                .await
                .map_err(|e| Error::Tool(format!("Failed to write to process: {}", e)))?;
            stdin
                .flush()
                .await
                .map_err(|e| Error::Tool(format!("Failed to flush stdin: {}", e)))?;
            Ok(())
        } else {
            Err(Error::Tool("Process stdin not available".to_string()))
        }
    }

    /// Cancel a running process
    pub async fn cancel_process(&self, tool_id: &str) -> Result<(), Error> {
        let mut processes = self.processes.lock().await;
        if let Some(process) = processes.get_mut(tool_id) {
            if let Some(tx) = process.cancellation_tx.take() {
                let _ = tx.send(());
            }
            processes.remove(tool_id);
            Ok(())
        } else {
            Err(Error::Tool(format!("Process not found: {}", tool_id)))
        }
    }
}


<file_info>
path: src/errors.rs
name: errors.rs
</file_info>
//! MCP Error Types
//!
//! This module defines custom error types for the MCP library, providing detailed
//! and type-safe error handling for various failure scenarios, such as protocol
//! errors, transport issues, and message parsing failures.

use schemars::JsonSchema;
use serde::{ Deserialize, Serialize };
use thiserror::Error;

/// Error data for JSON-RPC responses
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct ErrorData {
    /// Error code
    pub code: i32,
    /// Error message
    pub message: String,
    /// Optional additional data
    #[serde(skip_serializing_if = "Option::is_none")]
    pub data: Option<serde_json::Value>,
}

/// The main Error type for the MCP library
#[derive(Error, Debug)]
pub enum Error {
    /// JSON serialization/deserialization errors
    #[error("JSON error: {0}")]
    Json(#[from] serde_json::Error),

    /// I/O errors
    #[error("I/O error: {0}")]
    Io(#[from] std::io::Error),

    /// Transport-related errors
    #[error("Transport error: {0}")]
    Transport(String),

    /// Protocol errors (e.g., invalid message format)
    #[error("Protocol error: {0}")]
    Protocol(String),

    /// Method not found
    #[error("Method not found: {0}")]
    MethodNotFound(String),

    /// Invalid parameters
    #[error("Invalid parameters: {0}")]
    InvalidParams(String),

    /// Resource errors
    #[error("Resource error: {0}")]
    Resource(String),

    /// Tool errors
    #[error("Tool error: {0}")]
    Tool(String),

    /// Prompt errors
    #[error("Prompt error: {0}")]
    Prompt(String),

    /// Request validation error
    #[error("Validation error: {0}")]
    Validation(String),

    /// Schema validation error
    #[error("Schema validation error: {0}")]
    SchemaValidation(String),

    /// Version incompatibility error
    #[error("Version incompatibility: {0}")]
    VersionIncompatibility(String),

    /// Authentication error
    #[error("Authentication error: {0}")]
    Authentication(String),

    /// Authorization error
    #[error("Authorization error: {0}")]
    Authorization(String),

    /// Rate limit exceeded
    #[error("Rate limit exceeded: {0}")]
    RateLimit(String),

    /// Request timeout
    #[error("Request timeout: {0}")]
    Timeout(String),

    /// Initialization error
    #[error("Initialization error: {0}")]
    Initialization(String),

    /// Server busy or unavailable
    #[error("Server unavailable: {0}")]
    ServerUnavailable(String),

    /// Invalid state for requested operation
    #[error("Invalid state: {0}")]
    InvalidState(String),

    /// Other errors
    #[error("{0}")]
    Other(String),
}

/// Standard JSON-RPC 2.0 error codes
pub mod error_codes {
    /// Parse error
    pub const PARSE_ERROR: i32 = -32700;
    /// Invalid request
    pub const INVALID_REQUEST: i32 = -32600;
    /// Method not found
    pub const METHOD_NOT_FOUND: i32 = -32601;
    /// Invalid params
    pub const INVALID_PARAMS: i32 = -32602;
    /// Internal error
    pub const INTERNAL_ERROR: i32 = -32603;
    /// Server error range start
    pub const SERVER_ERROR_START: i32 = -32099;
    /// Server error range end
    pub const SERVER_ERROR_END: i32 = -32000;
    /// MCP-specific error codes can be defined in the range below -32000
    pub const RESOURCE_NOT_FOUND: i32 = -33000;
    /// Tool not found
    pub const TOOL_NOT_FOUND: i32 = -33001;
    /// Tool execution error
    pub const TOOL_EXECUTION_ERROR: i32 = -33002;
    /// Prompt not found
    pub const PROMPT_NOT_FOUND: i32 = -33003;
    /// Prompt validation error
    pub const PROMPT_VALIDATION_ERROR: i32 = -33004;
    /// Server is not initialized
    pub const SERVER_NOT_INITIALIZED: i32 = -33005;
    /// Client is not initialized
    pub const CLIENT_NOT_INITIALIZED: i32 = -33006;
    /// Incompatible protocol version
    pub const INCOMPATIBLE_VERSION: i32 = -33007;
    /// Authentication error
    pub const AUTHENTICATION_ERROR: i32 = -33008;
    /// Authorization error
    pub const AUTHORIZATION_ERROR: i32 = -33009;
    /// Rate limit exceeded
    pub const RATE_LIMIT_EXCEEDED: i32 = -33010;
    /// Request timeout
    pub const REQUEST_TIMEOUT: i32 = -33011;
    /// Resource content error
    pub const RESOURCE_CONTENT_ERROR: i32 = -33012;
    /// Tool parameter error
    pub const TOOL_PARAMETER_ERROR: i32 = -33013;
    /// Server busy or unavailable
    pub const SERVER_UNAVAILABLE: i32 = -33014;
    /// Schema validation error
    pub const SCHEMA_VALIDATION_ERROR: i32 = -33015;
}

impl Error {
    /// Convert an error to a JSON-RPC error code
    pub fn to_code(&self) -> i32 {
        use error_codes::*;
        match self {
            Error::Json(_) => PARSE_ERROR,
            Error::Protocol(_) => INVALID_REQUEST,
            Error::MethodNotFound(_) => METHOD_NOT_FOUND,
            Error::InvalidParams(_) => INVALID_PARAMS,
            Error::Resource(_) => RESOURCE_NOT_FOUND,
            Error::Tool(_) => TOOL_NOT_FOUND,
            Error::Prompt(_) => PROMPT_NOT_FOUND,
            Error::Validation(_) => INVALID_PARAMS,
            Error::SchemaValidation(_) => SCHEMA_VALIDATION_ERROR,
            Error::VersionIncompatibility(_) => INCOMPATIBLE_VERSION,
            Error::Authentication(_) => AUTHENTICATION_ERROR,
            Error::Authorization(_) => AUTHORIZATION_ERROR,
            Error::RateLimit(_) => RATE_LIMIT_EXCEEDED,
            Error::Timeout(_) => REQUEST_TIMEOUT,
            Error::Initialization(_) => SERVER_NOT_INITIALIZED,
            Error::InvalidState(_) => SERVER_NOT_INITIALIZED,
            Error::ServerUnavailable(_) => SERVER_UNAVAILABLE,
            Error::Io(_) => INTERNAL_ERROR,
            Error::Transport(_) => INTERNAL_ERROR,
            Error::Other(_) => INTERNAL_ERROR,
        }
    }

    /// Create an error response payload from this error
    pub fn to_response_payload(&self, id: i32) -> crate::types::protocol::Response {
        let code = self.to_code();
        let message = self.to_string();

        crate::types::protocol::error_response(id, code, &message, None)
    }
}

// Manual implementation of Clone that handles non-cloneable types
impl Clone for Error {
    fn clone(&self) -> Self {
        match self {
            Error::Json(e) => Error::Transport(format!("JSON error: {}", e)),
            Error::Io(e) => Error::Transport(format!("I/O error: {}", e)),
            Error::Transport(s) => Error::Transport(s.clone()),
            Error::Protocol(s) => Error::Protocol(s.clone()),
            Error::MethodNotFound(s) => Error::MethodNotFound(s.clone()),
            Error::InvalidParams(s) => Error::InvalidParams(s.clone()),
            Error::Resource(s) => Error::Resource(s.clone()),
            Error::Tool(s) => Error::Tool(s.clone()),
            Error::Prompt(s) => Error::Prompt(s.clone()),
            Error::Validation(s) => Error::Validation(s.clone()),
            Error::SchemaValidation(s) => Error::SchemaValidation(s.clone()),
            Error::VersionIncompatibility(s) => Error::VersionIncompatibility(s.clone()),
            Error::Authentication(s) => Error::Authentication(s.clone()),
            Error::Authorization(s) => Error::Authorization(s.clone()),
            Error::RateLimit(s) => Error::RateLimit(s.clone()),
            Error::Timeout(s) => Error::Timeout(s.clone()),
            Error::Initialization(s) => Error::Initialization(s.clone()),
            Error::ServerUnavailable(s) => Error::ServerUnavailable(s.clone()),
            Error::InvalidState(s) => Error::InvalidState(s.clone()),
            Error::Other(s) => Error::Other(s.clone()),
        }
    }
}


<file_info>
path: src/transport/connection_manager.rs
name: connection_manager.rs
</file_info>
//! Connection manager for SSE server transport
//!
//! This module provides the connection management functionality for the SSE server,
//! handling client connections, sessions, and message routing.

use std::collections::HashMap;
use std::sync::Arc;
use std::time::{ Duration, SystemTime };
use std::sync::atomic::{ AtomicU64, Ordering };

use tokio::sync::{ broadcast, RwLock };

use crate::errors::Error;
use crate::types::protocol::Message;
use crate::transport::sse_server::{ ConnectionEvent, MessageEvent };

/// Gets the current time in milliseconds
fn now_millis() -> u64 {
    SystemTime::now().duration_since(SystemTime::UNIX_EPOCH).unwrap_or_default().as_millis() as u64
}

/// Connection event handler type
pub type ConnectionEventHandler = Box<dyn Fn(ConnectionEvent) + Send + Sync + 'static>;

/// Message event handler type
pub type MessageEventHandler = Box<
    dyn (Fn(MessageEvent) -> Result<(), Error>) + Send + Sync + 'static
>;

/// Client connection information
pub struct ClientConnection {
    /// Client ID
    pub client_id: String,
    /// Session ID
    pub session_id: String,
    /// Connection time
    pub connected_at: SystemTime,
    /// Last activity timestamp (stored as millis since epoch for atomic updates)
    pub last_activity: Arc<AtomicU64>,
    /// Message sender channel for sending events to the client
    pub message_sender: broadcast::Sender<Message>,
    /// Client properties
    pub properties: HashMap<String, String>,
}

impl Clone for ClientConnection {
    fn clone(&self) -> Self {
        Self {
            client_id: self.client_id.clone(),
            session_id: self.session_id.clone(),
            connected_at: self.connected_at,
            last_activity: self.last_activity.clone(),
            message_sender: self.message_sender.clone(),
            properties: self.properties.clone(),
        }
    }
}

/// Connection manager for the SSE server
pub struct ConnectionManager {
    /// Primary map - client_id to client connection
    connections: Arc<RwLock<HashMap<String, ClientConnection>>>,
    /// Session lookup - session_id to client_id mapping
    sessions: Arc<RwLock<HashMap<String, String>>>,
    /// Connection timeout
    connection_timeout: Duration,
}

impl ConnectionManager {
    /// Create a new connection manager
    pub fn new(connection_timeout: Duration) -> Self {
        Self {
            connections: Arc::new(RwLock::new(HashMap::new())),
            sessions: Arc::new(RwLock::new(HashMap::new())),
            connection_timeout,
        }
    }

    /// Register a client
    pub fn register_client(&self, client_id: String, session_id: String) -> ClientConnection {
        // Create message channel
        let (sender, _) = broadcast::channel(100);

        // Create client connection
        let client = ClientConnection {
            client_id: client_id.clone(),
            session_id: session_id.clone(),
            connected_at: SystemTime::now(),
            last_activity: Arc::new(AtomicU64::new(now_millis())),
            message_sender: sender,
            properties: HashMap::new(),
        };

        let client_clone = client.clone();
        let self_clone = self.clone();
        let client_id_clone = client_id.clone();

        // Store client and session mapping
        tokio::spawn(async move {
            let mut connections = self_clone.connections.write().await;
            connections.insert(client_id_clone.clone(), client_clone);

            let mut sessions = self_clone.sessions.write().await;
            sessions.insert(session_id, client_id_clone.clone());
        });

        client
    }

    /// Get a client by ID
    pub async fn get_client(&self, client_id: &str) -> Option<ClientConnection> {
        let connections = self.connections.read().await;
        connections.get(client_id).cloned()
    }

    /// Get a client by session ID
    pub async fn get_client_by_session(&self, session_id: &str) -> Option<ClientConnection> {
        let sessions = self.sessions.read().await;
        if let Some(client_id) = sessions.get(session_id) {
            let connections = self.connections.read().await;
            connections.get(client_id).cloned()
        } else {
            None
        }
    }

    /// Update client activity
    pub fn update_client_activity(&self, client_id: &str) {
        let self_clone = self.clone();
        let client_id = client_id.to_string();

        tokio::spawn(async move {
            if let Some(client) = self_clone.get_client(&client_id).await {
                client.last_activity.store(now_millis(), Ordering::SeqCst);
            }
        });
    }

    /// Unregister a client
    pub async fn unregister_client(&self, client_id: &str) -> Result<(), Error> {
        // Get client
        let client = match self.get_client(client_id).await {
            Some(client) => client,
            None => {
                return Err(Error::Transport(format!("Client not found: {}", client_id)));
            }
        };

        let session_id = client.session_id.clone();

        // Remove from connections and sessions
        {
            let mut connections = self.connections.write().await;
            connections.remove(client_id);

            let mut sessions = self.sessions.write().await;
            sessions.remove(&session_id);
        }

        Ok(())
    }

    /// Check if a client is connected
    pub async fn is_client_connected(&self, client_id: &str) -> bool {
        let connections = self.connections.read().await;
        connections.contains_key(client_id)
    }

    /// Get a list of connected client IDs
    pub async fn connected_clients(&self) -> Vec<String> {
        let connections = self.connections.read().await;
        connections.keys().cloned().collect()
    }

    /// Run maintenance tasks
    pub async fn run_maintenance(&self) {
        let now = now_millis();
        let timeout_millis = self.connection_timeout.as_millis() as u64;
        let mut clients_to_remove = Vec::new();

        // Check for inactive clients
        {
            let connections = self.connections.read().await;
            for (client_id, client) in connections.iter() {
                let last_activity = client.last_activity.load(Ordering::SeqCst);
                if now - last_activity > timeout_millis {
                    clients_to_remove.push(client_id.clone());
                }
            }
        }

        // Remove inactive clients
        for client_id in clients_to_remove {
            let _ = self.unregister_client(&client_id).await;
        }
    }

    /// Shutdown and clean up all connections
    pub async fn shutdown(&self) -> Result<(), Error> {
        // Get all clients
        let client_ids = self.connected_clients().await;

        // Disconnect each client
        for client_id in client_ids {
            let _ = self.unregister_client(&client_id).await;
        }

        Ok(())
    }

    /// Clone the connection manager
    pub fn clone(&self) -> Self {
        Self {
            connections: self.connections.clone(),
            sessions: self.sessions.clone(),
            connection_timeout: self.connection_timeout,
        }
    }
}


<file_info>
path: src/server/handlers/mod.rs
name: mod.rs
</file_info>
//! Message handlers for different message types
//!
//! This module contains implementations of the MessageHandler trait
//! for various message types.

mod notification_handler;
mod request_handler;
mod initialize_handler;
mod tool_handler;

pub use notification_handler::NotificationHandler;
pub use request_handler::RequestHandler;
pub use initialize_handler::InitializeHandler;
pub use tool_handler::ToolHandler;


<file_info>
path: src/server/handlers/request_handler.rs
name: request_handler.rs
</file_info>
//! Handler for request messages

use async_trait::async_trait;
use tracing::{ debug, info, warn };

use crate::errors::Error;
use crate::types::protocol::{ Message, RequestMessage, error_response, success_response };
use crate::server::MessageHandler;

/// Handler for request messages
pub struct RequestHandler;

impl RequestHandler {
    /// Create a new instance of the request handler
    pub fn new() -> Self {
        Self {}
    }
}

#[async_trait]
impl MessageHandler for RequestHandler {
    async fn handle(&self, client_id: &str, message: &Message) -> Result<Option<Message>, Error> {
        match message {
            Message::Request(req) => {
                // Special case for shutdown request
                if req.method == "shutdown" {
                    debug!("Received shutdown request from client {}", client_id);
                    return Ok(None);
                }

                // Parse into typed request
                match Message::parse_request(req) {
                    Ok(typed_req) => {
                        debug!("Parsed request: {:?}", typed_req);

                        // Handle the typed request
                        match typed_req {
                            RequestMessage::Ping { meta } => {
                                info!(
                                    "Ping request from client {} with meta {:?}",
                                    client_id,
                                    meta
                                );
                                // Return a simple pong response
                                return Ok(
                                    Some(
                                        Message::Response(
                                            success_response(req.id, serde_json::json!({}))
                                        )
                                    )
                                );
                            }
                            // Additional request types would be handled here
                            _ => {
                                warn!("Unhandled request type: {:?}", typed_req);
                                // Return a method not found error
                                return Ok(
                                    Some(
                                        Message::Response(
                                            error_response(
                                                req.id,
                                                -32601,
                                                &format!("Method not implemented: {}", req.method),
                                                None
                                            )
                                        )
                                    )
                                );
                            }
                        }
                    }
                    Err(e) => {
                        debug!("Error parsing request: {}", e);
                        // Return a parse error
                        return Ok(
                            Some(
                                Message::Response(
                                    error_response(
                                        req.id,
                                        -32700,
                                        &format!("Parse error: {}", e),
                                        None
                                    )
                                )
                            )
                        );
                    }
                }
            }
            _ => {
                // This handler only handles requests
                Err(Error::Transport("Non-request message received".into()))
            }
        }
    }
}


<file_info>
path: src/utils.rs
name: utils.rs
</file_info>
//! MCP Utilities
//!
//! This module provides utility functions and helpers for the MCP library, such as
//! schema generation, message validation, or other common operations used across
//! the crate.

use crate::errors::Error;
use crate::types::protocol::{ ErrorData, Message, Response, ResponseOutcome };
use serde::{ Deserialize, Serialize, de::DeserializeOwned };
use serde_json::Value;
use std::future::Future;
use std::str::FromStr;
use std::time::Duration;
use tokio::time::timeout as tokio_timeout;
use tracing::{ debug, trace, warn };
use url::Url;

//=============================================================================
// 1. JSON Utilities
//=============================================================================

/// JSON utility functions for working with MCP data
pub mod json {
    use super::*;

    /// Serialize a value to a JSON string with pretty formatting
    pub fn to_pretty_string<T: Serialize>(value: &T) -> Result<String, Error> {
        serde_json::to_string_pretty(value).map_err(Error::Json)
    }

    /// Serialize a value to a compact JSON string
    pub fn to_string<T: Serialize>(value: &T) -> Result<String, Error> {
        serde_json::to_string(value).map_err(Error::Json)
    }

    /// Deserialize a JSON string to a value of type T
    pub fn from_str<T: DeserializeOwned>(s: &str) -> Result<T, Error> {
        serde_json::from_str(s).map_err(Error::Json)
    }

    /// Extract a field from a JSON Value as a specific type
    pub fn extract_field<T: DeserializeOwned>(value: &Value, field: &str) -> Result<T, Error> {
        let field_value = value
            .get(field)
            .ok_or_else(|| {
                Error::Protocol(format!("Field '{}' not found in JSON object", field))
            })?;

        serde_json::from_value(field_value.clone()).map_err(Error::Json)
    }

    /// Merge two JSON objects, with values from the second overriding the first
    pub fn merge_objects(base: &mut Value, overlay: &Value) -> Result<(), Error> {
        if !base.is_object() || !overlay.is_object() {
            return Err(Error::Protocol("Can only merge JSON objects".to_string()));
        }

        let base_map = base.as_object_mut().unwrap();
        let overlay_map = overlay.as_object().unwrap();

        for (key, value) in overlay_map {
            if let Some(existing) = base_map.get_mut(key) {
                if existing.is_object() && value.is_object() {
                    merge_objects(existing, value)?;
                } else {
                    *existing = value.clone();
                }
            } else {
                base_map.insert(key.clone(), value.clone());
            }
        }

        Ok(())
    }
}

//=============================================================================
// 2. URI Handling
//=============================================================================

/// URI utility functions for working with MCP resources
pub mod uri {
    use super::*;

    /// The scheme for MCP resource URIs
    pub const MCP_SCHEME: &str = "mcp";

    /// A typed representation of an MCP URI
    #[derive(Debug, Clone, PartialEq, Eq)]
    pub struct McpUri {
        url: Url,
    }

    impl McpUri {
        /// Create a new MCP URI from the given path components
        pub fn new(components: &[&str]) -> Result<Self, Error> {
            let path = components.join("/");
            let uri_str = format!("{}://{}", MCP_SCHEME, path);
            Self::from_str(&uri_str)
        }

        /// Return the scheme of the URI
        pub fn scheme(&self) -> &str {
            self.url.scheme()
        }

        /// Return the path of the URI
        pub fn path(&self) -> &str {
            self.url.path()
        }

        /// Return the resource type from the URI
        pub fn resource_type(&self) -> Option<&str> {
            self.url.path_segments()?.next()
        }

        /// Return the resource ID from the URI
        pub fn resource_id(&self) -> Option<&str> {
            let mut segments = self.url.path_segments()?;
            segments.next()?; // Skip the type
            segments.next() // Get the ID
        }

        /// Check if this is a valid MCP URI
        pub fn is_valid(&self) -> bool {
            self.scheme() == MCP_SCHEME && self.resource_type().is_some()
        }
    }

    impl FromStr for McpUri {
        type Err = Error;

        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match Url::parse(s) {
                Ok(url) => Ok(McpUri { url }),
                Err(e) => Err(Error::Resource(format!("Invalid URI: {}", e))),
            }
        }
    }

    impl ToString for McpUri {
        fn to_string(&self) -> String {
            self.url.to_string()
        }
    }

    /// Validate that a URI string is a valid MCP URI
    pub fn validate_uri(uri: &str) -> Result<(), Error> {
        let mcp_uri = McpUri::from_str(uri)?;
        if !mcp_uri.is_valid() {
            return Err(Error::Resource(format!("Invalid MCP URI format: {}", uri)));
        }
        Ok(())
    }
}

//=============================================================================
// 3. Error Utilities
//=============================================================================

/// Error utility functions for MCP error handling
pub mod errors {
    use super::*;
    use crate::errors::error_codes;

    /// Create an error response with the given code, message, and optional data
    pub fn create_error_response(
        id: i32,
        code: i32,
        message: &str,
        data: Option<Value>
    ) -> Response {
        Response {
            jsonrpc: "2.0".to_string(),
            id,
            outcome: ResponseOutcome::Error {
                error: ErrorData {
                    code,
                    message: message.to_string(),
                    data,
                },
            },
        }
    }

    /// Create a standard protocol error response
    pub fn protocol_error(id: i32, message: &str) -> Response {
        create_error_response(id, error_codes::INVALID_REQUEST, message, None)
    }

    /// Create a method not found error response
    pub fn method_not_found(id: i32, method: &str) -> Response {
        create_error_response(
            id,
            error_codes::METHOD_NOT_FOUND,
            &format!("Method not found: {}", method),
            None
        )
    }

    /// Create an invalid params error response
    pub fn invalid_params(id: i32, message: &str) -> Response {
        create_error_response(id, error_codes::INVALID_PARAMS, message, None)
    }

    /// Create an internal error response
    pub fn internal_error(id: i32, message: &str) -> Response {
        create_error_response(id, error_codes::INTERNAL_ERROR, message, None)
    }

    /// Create a resource not found error response
    pub fn resource_not_found(id: i32, uri: &str) -> Response {
        create_error_response(
            id,
            error_codes::RESOURCE_NOT_FOUND,
            &format!("Resource not found: {}", uri),
            None
        )
    }

    /// Create a tool not found error response
    pub fn tool_not_found(id: i32, tool_name: &str) -> Response {
        create_error_response(
            id,
            error_codes::TOOL_NOT_FOUND,
            &format!("Tool not found: {}", tool_name),
            None
        )
    }

    /// Create a tool execution error response
    pub fn tool_execution_error(id: i32, tool_name: &str, error_msg: &str) -> Response {
        create_error_response(
            id,
            error_codes::TOOL_EXECUTION_ERROR,
            &format!("Error executing tool {}: {}", tool_name, error_msg),
            None
        )
    }
}

//=============================================================================
// 4. Async Utilities
//=============================================================================

/// Async utility functions for working with futures in MCP
pub mod async_utils {
    use super::*;

    /// Run a future with a timeout
    pub async fn timeout<F, T>(duration: Duration, future: F) -> Result<T, Error>
        where F: Future<Output = Result<T, Error>>
    {
        match tokio_timeout(duration, future).await {
            Ok(result) => result,
            Err(_) => Err(Error::Other(format!("Operation timed out after {:?}", duration))),
        }
    }

    /// Retry an async operation with exponential backoff
    pub async fn retry<F, Fut, T>(
        operation: F,
        max_attempts: usize,
        initial_backoff: Duration
    )
        -> Result<T, Error>
        where F: Fn() -> Fut, Fut: Future<Output = Result<T, Error>>
    {
        let mut attempts = 0;
        let mut backoff = initial_backoff;

        loop {
            attempts += 1;
            match operation().await {
                Ok(value) => {
                    return Ok(value);
                }
                Err(error) => {
                    if attempts >= max_attempts {
                        return Err(error);
                    }

                    debug!("Retry attempt {}/{} failed: {}", attempts, max_attempts, error);
                    tokio::time::sleep(backoff).await;
                    backoff *= 2; // Exponential backoff
                }
            }
        }
    }

    /// Cancel a future after a specified duration
    pub async fn with_timeout<F, T>(future: F, duration: Duration) -> Result<T, Error>
        where F: Future<Output = T>
    {
        tokio_timeout(duration, future).await.map_err(|_|
            Error::Other(format!("Operation timed out after {:?}", duration))
        )
    }
}

//=============================================================================
// 5. Schema Utilities
//=============================================================================

/// Schema utility functions for working with JSON schemas in MCP
pub mod schema {
    use jsonschema::JSONSchema;
    use schemars::JsonSchema;
    use schemars::schema_for;
    use serde_json::Value;
    use std::collections::HashMap;
    use std::sync::OnceLock;

    use crate::errors::Error;
    use crate::types::protocol::{ Message, Response, Request };
    use crate::types::{
        initialize::{ InitializeRequestParams, InitializeResult },
        prompts::{
            CreatePromptParams,
            CreatePromptResult,
            DeletePromptParams,
            DeletePromptResult,
            ListPromptsParams,
            ListPromptsResult,
            RenderPromptParams,
            RenderPromptResult,
            UpdatePromptParams,
            UpdatePromptResult,
        },
        resources::{
            CreateResourceParams,
            CreateResourceResult,
            DeleteResourceParams,
            DeleteResourceResult,
            GetResourceParams,
            GetResourceResult,
            ListResourcesParams,
            ListResourcesResult,
            UpdateResourceParams,
            UpdateResourceResult,
        },
        tools::{ CallToolParams, CallToolResult, ListToolsParams, ListToolsResult },
    };

    // Static reference to compiled full schema
    static FULL_SCHEMA: OnceLock<JSONSchema> = OnceLock::new();

    /// Initialize the full MCP schema from file
    pub fn init_full_schema() -> Result<(), Error> {
        if FULL_SCHEMA.get().is_some() {
            return Ok(());
        }

        // Try to use the embedded schema if available
        let schema_content = include_str!("../src/schema/schema.json");
        let schema_value: Value = serde_json
            ::from_str(schema_content)
            .map_err(|e| Error::SchemaValidation(format!("Failed to parse schema.json: {}", e)))?;

        // Compile the schema
        let compiled = JSONSchema::compile(&schema_value).map_err(|e|
            Error::SchemaValidation(format!("Failed to compile schema: {}", e))
        )?;

        // Store the compiled schema
        FULL_SCHEMA.set(compiled).map_err(|_|
            Error::SchemaValidation("Failed to set compiled schema".to_string())
        )?;

        Ok(())
    }

    /// Validate a message against the full MCP JSON schema
    pub fn validate_against_full_schema(value: &Value) -> Result<(), Error> {
        if let Some(schema) = FULL_SCHEMA.get() {
            let validation = schema.validate(value);
            if let Err(errors) = validation {
                let error_msgs: Vec<String> = errors.map(|e| format!("{}", e)).collect();
                return Err(
                    Error::SchemaValidation(
                        format!("Schema validation failed: {}", error_msgs.join(", "))
                    )
                );
            }
            Ok(())
        } else {
            // Schema not loaded, can't validate
            Ok(())
        }
    }

    /// Validate a request message against the full MCP schema
    pub fn validate_request_against_full_schema(request: &Request) -> Result<(), Error> {
        // Schema is expected to be initialized by the caller
        if FULL_SCHEMA.get().is_none() {
            // Schema not available, just succeed
            return Ok(());
        }

        let json_value = serde_json
            ::to_value(request)
            .map_err(|e| Error::SchemaValidation(format!("Failed to serialize request: {}", e)))?;

        validate_against_full_schema(&json_value)
    }

    /// Validate a response message against the full MCP schema
    pub fn validate_response_against_full_schema(response: &Response) -> Result<(), Error> {
        // Schema is expected to be initialized by the caller
        if FULL_SCHEMA.get().is_none() {
            // Schema not available, just succeed
            return Ok(());
        }

        let json_value = serde_json
            ::to_value(response)
            .map_err(|e| Error::SchemaValidation(format!("Failed to serialize response: {}", e)))?;

        validate_against_full_schema(&json_value)
    }

    /// Validate a generic message against the full MCP schema
    pub fn validate_message_against_full_schema(message: &Message) -> Result<(), Error> {
        // Schema is expected to be initialized by the caller
        if FULL_SCHEMA.get().is_none() {
            // Schema not available, just succeed
            return Ok(());
        }

        let json_value = serde_json
            ::to_value(message)
            .map_err(|e| Error::SchemaValidation(format!("Failed to serialize message: {}", e)))?;

        validate_against_full_schema(&json_value)
    }

    /// Get or create the method parameter schema registry
    fn param_schema_registry() -> &'static HashMap<String, Value> {
        static REGISTRY: OnceLock<HashMap<String, Value>> = OnceLock::new();
        REGISTRY.get_or_init(|| {
            let mut registry = HashMap::new();

            // Initialize method
            registry.insert("initialize".to_string(), generate_schema::<InitializeRequestParams>());

            // Resource methods
            registry.insert("resources/list".to_string(), generate_schema::<ListResourcesParams>());
            registry.insert("resources/get".to_string(), generate_schema::<GetResourceParams>());
            registry.insert(
                "resources/create".to_string(),
                generate_schema::<CreateResourceParams>()
            );
            registry.insert(
                "resources/update".to_string(),
                generate_schema::<UpdateResourceParams>()
            );
            registry.insert(
                "resources/delete".to_string(),
                generate_schema::<DeleteResourceParams>()
            );

            // Tool methods
            registry.insert("tools/list".to_string(), generate_schema::<ListToolsParams>());
            registry.insert("tools/call".to_string(), generate_schema::<CallToolParams>());

            // Prompt methods
            registry.insert("prompts/list".to_string(), generate_schema::<ListPromptsParams>());
            registry.insert("prompts/create".to_string(), generate_schema::<CreatePromptParams>());
            registry.insert("prompts/update".to_string(), generate_schema::<UpdatePromptParams>());
            registry.insert("prompts/delete".to_string(), generate_schema::<DeletePromptParams>());
            registry.insert("prompts/render".to_string(), generate_schema::<RenderPromptParams>());

            registry
        })
    }

    /// Get or create the method result schema registry
    fn result_schema_registry() -> &'static HashMap<String, Value> {
        static REGISTRY: OnceLock<HashMap<String, Value>> = OnceLock::new();
        REGISTRY.get_or_init(|| {
            let mut registry = HashMap::new();

            // Initialize method
            registry.insert("initialize".to_string(), generate_schema::<InitializeResult>());

            // Resource methods
            registry.insert("resources/list".to_string(), generate_schema::<ListResourcesResult>());
            registry.insert("resources/get".to_string(), generate_schema::<GetResourceResult>());
            registry.insert(
                "resources/create".to_string(),
                generate_schema::<CreateResourceResult>()
            );
            registry.insert(
                "resources/update".to_string(),
                generate_schema::<UpdateResourceResult>()
            );
            registry.insert(
                "resources/delete".to_string(),
                generate_schema::<DeleteResourceResult>()
            );

            // Tool methods
            registry.insert("tools/list".to_string(), generate_schema::<ListToolsResult>());
            registry.insert("tools/call".to_string(), generate_schema::<CallToolResult>());

            // Prompt methods
            registry.insert("prompts/list".to_string(), generate_schema::<ListPromptsResult>());
            registry.insert("prompts/create".to_string(), generate_schema::<CreatePromptResult>());
            registry.insert("prompts/update".to_string(), generate_schema::<UpdatePromptResult>());
            registry.insert("prompts/delete".to_string(), generate_schema::<DeletePromptResult>());
            registry.insert("prompts/render".to_string(), generate_schema::<RenderPromptResult>());

            registry
        })
    }

    /// Generate a JSON schema for the given type
    pub fn generate_schema<T: JsonSchema>() -> Value {
        serde_json::to_value(schema_for!(T)).unwrap_or_else(|_| Value::Null)
    }

    /// Validate the given value against the JSON schema for the type
    pub fn validate<T: JsonSchema>(value: &Value) -> Result<(), Error> {
        let schema = generate_schema::<T>();
        validate_against_schema(value, &schema)
    }

    /// Validate the given value against a specific JSON schema
    pub fn validate_against_schema(value: &Value, schema: &Value) -> Result<(), Error> {
        let compiled = JSONSchema::compile(schema).map_err(|e|
            Error::Protocol(format!("Invalid schema: {}", e))
        )?;

        let validation = compiled.validate(value);
        if let Err(errors) = validation {
            let error_msgs: Vec<String> = errors.map(|e| format!("{}", e)).collect();

            return Err(
                Error::InvalidParams(format!("Schema validation failed: {}", error_msgs.join(", ")))
            );
        }

        Ok(())
    }

    /// Get the parameter schema for a specific method
    pub fn get_param_schema(method: &str) -> Option<Value> {
        param_schema_registry().get(method).cloned()
    }

    /// Get the result schema for a specific method
    pub fn get_result_schema(method: &str) -> Option<Value> {
        result_schema_registry().get(method).cloned()
    }

    /// Validate parameters for a specific method
    pub fn validate_method_params(method: &str, params: &Value) -> Result<(), Error> {
        if let Some(schema) = get_param_schema(method) {
            validate_against_schema(params, &schema)
        } else {
            // No schema found for this method - can't validate
            Ok(())
        }
    }

    /// Validate result for a specific method
    pub fn validate_method_result(method: &str, result: &Value) -> Result<(), Error> {
        if let Some(schema) = get_result_schema(method) {
            validate_against_schema(result, &schema)
        } else {
            // No schema found for this method - can't validate
            Ok(())
        }
    }

    /// Generate schemas for all supported types
    pub fn generate_all_schemas() -> Result<HashMap<String, Value>, Error> {
        let mut schemas = HashMap::new();

        // Include all parameter schemas
        for (method, schema) in param_schema_registry().iter() {
            schemas.insert(format!("{}_params", method), schema.clone());
        }

        // Include all result schemas
        for (method, schema) in result_schema_registry().iter() {
            schemas.insert(format!("{}_result", method), schema.clone());
        }

        Ok(schemas)
    }
}

//=============================================================================
// 6. Authentication Utilities
//=============================================================================

/// Authentication utility functions for MCP (if required)
pub mod auth {
    use super::*;

    /// A simple API key for basic authentication
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct ApiKey {
        pub key: String,
    }

    impl ApiKey {
        /// Create a new API key
        pub fn new(key: &str) -> Self {
            Self {
                key: key.to_string(),
            }
        }

        /// Validate the API key
        pub fn validate(&self, expected: &str) -> bool {
            self.key == expected
        }
    }

    /// Generate a simple authentication header for HTTP-based transports
    pub fn generate_auth_header(api_key: &ApiKey) -> String {
        format!("Bearer {}", api_key.key)
    }

    /// Parse an authentication header to extract the API key
    pub fn parse_auth_header(header: &str) -> Result<ApiKey, Error> {
        if let Some(key) = header.strip_prefix("Bearer ") {
            Ok(ApiKey::new(key))
        } else {
            Err(Error::Protocol("Invalid authentication header format".to_string()))
        }
    }
}

//=============================================================================
// 7. Logging and Debugging Utilities
//=============================================================================

/// Logging and debugging utility functions for MCP
pub mod logging {
    use super::*;

    /// Log an MCP message at debug level
    pub fn log_message(msg: &Message) {
        match msg {
            Message::Request(req) => {
                debug!("MCP Request: method={}, id={:?}", req.method, req.id);
                trace!("Request params: {:?}", req.params);
            }
            Message::Response(resp) =>
                match &resp.outcome {
                    ResponseOutcome::Success { result: _ } => {
                        debug!("MCP Response: id={}, success=true", resp.id);
                        trace!("Response result: {:?}", resp.outcome);
                    }
                    ResponseOutcome::Error { error } => {
                        warn!(
                            "MCP Error Response: id={}, code={}, message={}",
                            resp.id,
                            error.code,
                            error.message
                        );
                    }
                }
            Message::Notification(notification) => {
                debug!("MCP Notification: method={}", notification.method);
                trace!("Notification params: {:?}", notification.params);
            }
        }
    }

    /// Pretty-print an MCP message as a string
    pub fn format_message(msg: &Message) -> Result<String, Error> {
        json::to_pretty_string(msg)
    }

    /// Create a debug dump of the message exchange for troubleshooting
    pub struct MessageExchangeDebugger {
        request: Option<Message>,
        response: Option<Message>,
        timestamp: std::time::SystemTime,
    }

    impl MessageExchangeDebugger {
        /// Create a new message exchange debugger
        pub fn new() -> Self {
            Self {
                request: None,
                response: None,
                timestamp: std::time::SystemTime::now(),
            }
        }

        /// Record a request
        pub fn record_request(&mut self, request: Message) {
            self.request = Some(request);
        }

        /// Record a response
        pub fn record_response(&mut self, response: Message) {
            self.response = Some(response);
        }

        /// Generate a debug report
        pub fn generate_report(&self) -> Result<String, Error> {
            let mut report = String::new();

            report.push_str(&format!("MCP Message Exchange Debug Report\n"));
            report.push_str(&format!("Timestamp: {:?}\n\n", self.timestamp));

            if let Some(ref req) = self.request {
                report.push_str("REQUEST:\n");
                report.push_str(&json::to_pretty_string(req)?);
                report.push_str("\n\n");
            } else {
                report.push_str("REQUEST: None recorded\n\n");
            }

            if let Some(ref resp) = self.response {
                report.push_str("RESPONSE:\n");
                report.push_str(&json::to_pretty_string(resp)?);
                report.push_str("\n");
            } else {
                report.push_str("RESPONSE: None recorded\n");
            }

            Ok(report)
        }
    }

    impl Default for MessageExchangeDebugger {
        fn default() -> Self {
            Self::new()
        }
    }
}

// Re-export commonly used utilities
pub use async_utils::timeout;
pub use errors::{ create_error_response, invalid_params, method_not_found };
pub use json::{ from_str, to_string };
pub use logging::log_message;
pub use schema::validate;
pub use uri::{ McpUri, validate_uri };

/// Validation module for request and response validation
pub mod validation {
    use super::schema;
    use crate::errors::Error;
    use crate::types::protocol::{ Request, Response, ResponseOutcome };

    /// Configuration for schema validation
    #[derive(Debug, Clone, Copy)]
    pub struct ValidationConfig {
        /// Whether to validate requests
        pub validate_requests: bool,
        /// Whether to validate responses
        pub validate_responses: bool,
    }

    impl Default for ValidationConfig {
        fn default() -> Self {
            Self {
                validate_requests: true,
                validate_responses: true,
            }
        }
    }

    /// Validate an incoming request against its method schema
    pub fn validate_request(request: &Request, config: &ValidationConfig) -> Result<(), Error> {
        // Skip validation if disabled
        if !config.validate_requests {
            return Ok(());
        }

        // Get method and params
        let method = &request.method;

        // Validate params if they exist
        if let Some(params) = &request.params {
            schema::validate_method_params(method, params)?;
        }

        // Conditionally initialize and use full schema validation
        // We use a soft validation that won't fail if the schema isn't available
        if config.validate_requests {
            // Try to initialize the schema only when needed
            if schema::init_full_schema().is_ok() {
                schema::validate_request_against_full_schema(request).ok();
            }
        }

        Ok(())
    }

    /// Validate an outgoing response against its method schema
    pub fn validate_response(
        response: &Response,
        method: &str,
        config: &ValidationConfig
    ) -> Result<(), Error> {
        // Skip validation if disabled
        if !config.validate_responses {
            return Ok(());
        }

        // Validate result if it's a success response
        if let ResponseOutcome::Success { result } = &response.outcome {
            schema::validate_method_result(method, result)?;
        }

        // Conditionally initialize and use full schema validation
        // We use a soft validation that won't fail if the schema isn't available
        if config.validate_responses {
            // Try to initialize the schema only when needed
            if schema::init_full_schema().is_ok() {
                schema::validate_response_against_full_schema(response).ok();
            }
        }

        Ok(())
    }
}


<file_info>
path: src/transport/sse.rs
name: sse.rs
</file_info>
//! SSE Client Transport
//!
//! This module implements the client-side transport for the SSE (Server-Sent Events)
//! protocol. It allows an MCP client to connect to an SSE server and receive real-time
//! updates via a persistent HTTP connection.

use async_trait::async_trait;
use futures_util::stream::StreamExt;
use reqwest::{ Client as HttpClient, ClientBuilder, header };
use std::collections::HashMap;
use std::sync::Arc;
use std::sync::atomic::AtomicBool;
use std::time::Duration;
use tokio::sync::{ Mutex, mpsc, oneshot };
use url::Url;
use log::{ info, error };

use crate::errors::Error;
use crate::types::protocol::Message;
use crate::transport::Transport;

/// Default timeout for HTTP requests
const DEFAULT_TIMEOUT: Duration = Duration::from_secs(30);
/// Default retry delay for reconnecting
const DEFAULT_RETRY_DELAY: Duration = Duration::from_secs(2);
/// Maximum number of reconnect attempts
const MAX_RECONNECT_ATTEMPTS: usize = 5;
/// Buffer size for message channel
const CHANNEL_BUFFER_SIZE: usize = 100;

/// Options for the SSE client transport
#[derive(Clone, Debug)]
pub struct SseOptions {
    /// Authentication token
    pub auth_token: Option<String>,
    /// Request timeout
    pub timeout: Duration,
    /// Retry delay for reconnection
    pub retry_delay: Duration,
    /// Custom headers
    pub custom_headers: Option<header::HeaderMap>,
    /// Client ID (auto-generated if None)
    pub client_id: Option<String>,
}

impl Default for SseOptions {
    fn default() -> Self {
        Self {
            auth_token: None,
            timeout: DEFAULT_TIMEOUT,
            retry_delay: DEFAULT_RETRY_DELAY,
            custom_headers: None,
            client_id: None,
        }
    }
}

/// Client-side implementation of the SSE transport
pub struct SseTransport {
    /// Base URL for the SSE server
    base_url: String,
    /// URL for the SSE events endpoint
    events_url: String,
    /// URL for the messages endpoint
    messages_url: String,
    /// HTTP client
    http_client: HttpClient,
    /// Channel for incoming messages
    rx: mpsc::Receiver<Message>,
    /// Options for the transport
    options: SseOptions,
    /// Session ID (if assigned by server)
    session_id: Arc<Mutex<String>>,
    /// Whether the transport is connected
    connected: Arc<Mutex<bool>>,
    /// Whether the transport is ready to send/receive messages
    is_ready: Arc<AtomicBool>,
    /// Handle to the background task
    _task_handle: tokio::task::JoinHandle<()>,
    /// Shutdown signal sender
    shutdown_tx: Option<oneshot::Sender<()>>,
}

impl SseTransport {
    /// Create a new SSE transport
    pub async fn new(base_url: &str) -> Result<Self, Error> {
        Self::with_options(base_url, SseOptions::default()).await
    }

    /// Create a new SSE transport with custom options
    pub async fn with_options(base_url: &str, options: SseOptions) -> Result<Self, Error> {
        // Verify the base URL is valid
        let base_url = match Url::parse(base_url) {
            Ok(url) => url,
            Err(e) => {
                return Err(Error::Transport(format!("Invalid base URL: {}", e)));
            }
        };

        // Create the endpoints
        let events_url = base_url
            .join("sse")
            .map_err(|e| Error::Transport(format!("Failed to create events URL: {}", e)))?
            .to_string();

        let messages_url = base_url
            .join("message")
            .map_err(|e| Error::Transport(format!("Failed to create messages URL: {}", e)))?
            .to_string();

        // Create the HTTP client with specified timeout
        let http_client = ClientBuilder::new()
            .timeout(options.timeout)
            .build()
            .map_err(|e| Error::Transport(format!("Failed to create HTTP client: {}", e)))?;

        // Create a channel for incoming messages
        let (tx, rx) = mpsc::channel(100);

        // Create the session ID
        let session_id = Arc::new(Mutex::new(String::new()));

        // Create the connected flag
        let connected = Arc::new(Mutex::new(false));

        // Create the is_ready flag
        let is_ready = Arc::new(AtomicBool::new(false));

        // Create a shutdown signal
        let (shutdown_tx, shutdown_rx) = oneshot::channel::<()>();

        // Clone values for the task
        let events_url_clone = events_url.clone();
        let tx_clone = tx.clone();
        let session_id_clone = session_id.clone();
        let connected_clone = connected.clone();
        let is_ready_clone = is_ready.clone();
        let http_client_clone = http_client.clone();
        let messages_url_clone = messages_url.clone();

        // Spawn a task to handle the SSE connection
        let task_handle = tokio::spawn(async move {
            // Create a task-local shutdown signal
            let mut shutdown_rx = shutdown_rx;

            // Enter the connection loop
            loop {
                // Check if we should shut down
                if shutdown_rx.try_recv().is_ok() {
                    tracing::info!("Received shutdown signal, closing SSE connection");
                    break;
                }

                // Try to connect to the SSE endpoint
                match
                    Self::connect_to_sse(
                        http_client_clone.clone(),
                        events_url_clone.clone(),
                        tx_clone.clone(),
                        session_id_clone.clone(),
                        connected_clone.clone(),
                        is_ready_clone.clone(),
                        messages_url_clone.clone()
                    ).await
                {
                    Ok(_) => {
                        tracing::info!("SSE connection ended normally");
                        break;
                    }
                    Err(e) => {
                        tracing::error!("SSE connection error: {}", e);
                        // Short delay before retry
                        tokio::time::sleep(std::time::Duration::from_secs(2)).await;
                    }
                }
            }

            // Ensure we mark as disconnected
            {
                let mut connected_guard = connected_clone.lock().await;
                *connected_guard = false;
            }

            // Mark is_ready as false since we're no longer connected
            is_ready_clone.store(false, std::sync::atomic::Ordering::Release);
            tracing::info!("SSE connection task ending");

            // Notify final closed state
            info!("SSE transport closed");
        });

        Ok(Self {
            base_url: base_url.to_string(),
            events_url,
            messages_url,
            http_client,
            rx,
            options,
            session_id,
            connected,
            is_ready,
            _task_handle: task_handle,
            shutdown_tx: Some(shutdown_tx),
        })
    }

    /// Connect to the SSE endpoint and process messages
    async fn connect_to_sse(
        http_client: HttpClient,
        events_url: String,
        sender: mpsc::Sender<Message>,
        session_id: Arc<Mutex<String>>,
        connected: Arc<Mutex<bool>>,
        is_ready: Arc<AtomicBool>,
        _messages_url: String
    ) -> Result<(), Error> {
        let mut retries = 0;
        let max_retries = 5;
        let mut retry_delay = std::time::Duration::from_millis(1000);

        loop {
            tracing::info!("Connecting to SSE endpoint: {}", events_url);

            // Reset ready state on new connection attempt
            is_ready.store(false, std::sync::atomic::Ordering::Release);

            // Create a request with headers (no client ID - the server will assign one)
            let req = http_client
                .get(&events_url)
                .header("Accept", "text/event-stream")
                .header("Cache-Control", "no-cache")
                .header("Connection", "keep-alive")
                .build()
                .map_err(|e| Error::Transport(format!("Failed to build SSE request: {}", e)))?;

            // Send the request and check the response
            let response = match http_client.execute(req).await {
                Ok(resp) => {
                    if !resp.status().is_success() {
                        let status = resp.status();
                        let text = resp.text().await.unwrap_or_default();
                        let error = format!(
                            "SSE connection failed with status {}: {}",
                            status,
                            text
                        );
                        tracing::error!("{}", error);

                        // Increase retries and delay before next attempt
                        retries += 1;
                        if retries >= max_retries {
                            return Err(Error::Transport(error));
                        }

                        tracing::info!(
                            "Retrying SSE connection in {:?} (attempt {}/{})",
                            retry_delay,
                            retries,
                            max_retries
                        );
                        tokio::time::sleep(retry_delay).await;
                        retry_delay = std::cmp::min(
                            retry_delay * 2,
                            std::time::Duration::from_secs(30)
                        );
                        continue;
                    }
                    resp
                }
                Err(e) => {
                    let error = format!("Failed to connect to SSE endpoint: {}", e);
                    tracing::error!("{}", error);

                    // Increase retries and delay before next attempt
                    retries += 1;
                    if retries >= max_retries {
                        return Err(Error::Transport(error));
                    }

                    tracing::info!(
                        "Retrying SSE connection in {:?} (attempt {}/{})",
                        retry_delay,
                        retries,
                        max_retries
                    );
                    tokio::time::sleep(retry_delay).await;
                    retry_delay = std::cmp::min(
                        retry_delay * 2,
                        std::time::Duration::from_secs(30)
                    );
                    continue;
                }
            };

            // Update connected status
            *connected.lock().await = true;
            tracing::info!("Successfully connected to SSE endpoint!");

            // Set the transport as ready immediately - we no longer wait for endpoint event
            is_ready.store(true, std::sync::atomic::Ordering::Release);

            // Process the response stream
            match
                Self::process_sse_stream(
                    response,
                    sender.clone(),
                    session_id.clone(),
                    is_ready.clone()
                ).await
            {
                Ok(_) => {
                    tracing::info!("SSE stream processed successfully");
                    break; // Exit loop if stream ended gracefully
                }
                Err(e) => {
                    tracing::error!("Error processing SSE stream: {}", e);

                    // Update connected status
                    *connected.lock().await = false;

                    // Notify error
                    error!("SSE transport error occurred");

                    // Increase retries and delay before next attempt
                    retries += 1;
                    if retries >= max_retries {
                        return Err(e);
                    }

                    tracing::info!(
                        "Retrying SSE connection in {:?} (attempt {}/{})",
                        retry_delay,
                        retries,
                        max_retries
                    );
                    tokio::time::sleep(retry_delay).await;
                    retry_delay = std::cmp::min(
                        retry_delay * 2,
                        std::time::Duration::from_secs(30)
                    );
                }
            }
        }

        Ok(())
    }

    async fn process_sse_stream(
        response: reqwest::Response,
        sender: mpsc::Sender<Message>,
        session_id: Arc<Mutex<String>>,
        is_ready: Arc<AtomicBool>
    ) -> Result<(), Error> {
        let mut stream = response.bytes_stream();
        let mut buffer = String::new();
        let mut event_type = String::new();
        let mut event_data = String::new();

        tracing::debug!("Starting to process SSE stream");

        while let Some(chunk_result) = stream.next().await {
            match chunk_result {
                Ok(chunk) => {
                    // Convert bytes to string and append to buffer
                    let chunk_str = std::str
                        ::from_utf8(&chunk)
                        .map_err(|e| {
                            Error::Transport(format!("Invalid UTF-8 in SSE stream: {}", e))
                        })?;

                    buffer.push_str(chunk_str);

                    // Process complete lines in the buffer
                    let mut pos = 0;
                    while let Some(next_newline) = buffer[pos..].find('\n') {
                        let line_end = pos + next_newline;
                        let line = buffer[pos..line_end].trim();
                        pos = line_end + 1;

                        tracing::debug!("Received SSE line: {}", line);

                        if line.is_empty() {
                            // Empty line marks the end of an event
                            if !event_type.is_empty() && !event_data.is_empty() {
                                // Process the complete event - only for message events
                                if event_type == "message" {
                                    Self::process_message_event(&event_data, &sender).await?;
                                } else if event_type == "error" {
                                    tracing::error!("Received error event: {}", event_data);
                                }

                                // Reset event state
                                event_type.clear();
                                event_data.clear();
                            }
                        } else if let Some(data) = line.strip_prefix("data:") {
                            // Append to event data
                            if !event_data.is_empty() {
                                event_data.push('\n');
                            }
                            event_data.push_str(data.trim());
                        } else if let Some(event) = line.strip_prefix("event:") {
                            // Set event type
                            event_type = event.trim().to_string();
                        }
                    }

                    // Remove processed content from buffer
                    if pos < buffer.len() {
                        buffer = buffer[pos..].to_string();
                    } else {
                        buffer.clear();
                    }
                }
                Err(e) => {
                    return Err(Error::Transport(format!("Error reading SSE stream: {}", e)));
                }
            }
        }

        tracing::info!("SSE stream ended");
        Ok(())
    }

    async fn process_message_event(
        event_data: &str,
        sender: &mpsc::Sender<Message>
    ) -> Result<(), Error> {
        tracing::debug!("Processing message event: {}", event_data);

        // Try to parse the message from JSON
        match serde_json::from_str::<Message>(event_data) {
            Ok(message) => {
                // Send the message to the receiver
                if let Err(e) = sender.send(message).await {
                    tracing::error!("Failed to send message to channel: {}", e);
                    return Err(Error::Transport("Failed to process message".to_string()));
                }
                Ok(())
            }
            Err(e) => {
                tracing::error!("Failed to parse message from event data: {}", e);
                Err(Error::Transport(format!("Invalid message format: {}", e)))
            }
        }
    }

    // Message filtering based on ID
    async fn handle_sse_event(
        event_type: &str,
        event_data: &str,
        sender: &mpsc::Sender<Message>,
        pending_requests: &Arc<Mutex<HashMap<u64, oneshot::Sender<Result<Message, Error>>>>>
    ) -> Result<(), Error> {
        if event_type != "message" {
            return Ok(());
        }

        // Parse message
        let message: Message = serde_json::from_str(event_data)?;

        // If message is a response, check if we have a pending request for it
        if let Message::Response(response) = &message {
            // Convert i32 ID to u64 for HashMap lookup
            let id = response.id as u64;

            // Check if we have a pending request for this ID
            let mut pending = pending_requests.lock().await;
            if let Some(sender) = pending.remove(&id) {
                // Send response to the waiting call
                let _ = sender.send(Ok(message.clone()));
                return Ok(());
            }
        }

        // Otherwise, forward the message
        sender
            .send(message).await
            .map_err(|e| Error::Transport(format!("Failed to forward message: {}", e)))?;

        Ok(())
    }
}

#[async_trait]
impl Transport for SseTransport {
    /// Start the transport - for the client this is a no-op as initialization
    /// happens in the constructor
    async fn start(&mut self) -> Result<(), Error> {
        // Check if we're already connected
        let connected = *self.connected.lock().await;
        if connected {
            return Ok(());
        }

        // Otherwise, just log that we're ready
        tracing::info!("SSE transport ready");
        Ok(())
    }

    async fn receive(&mut self) -> Result<(Option<String>, Message), Error> {
        // Wait for the transport to be ready
        if !self.is_ready.load(std::sync::atomic::Ordering::Acquire) {
            return Err(Error::Transport("Transport not ready".to_string()));
        }

        // Receive a message from the channel
        match self.rx.recv().await {
            Some(msg) => Ok((None, msg)),
            None => Err(Error::Transport("Channel closed".to_string())),
        }
    }

    async fn send(&mut self, message: &Message) -> Result<(), Error> {
        self.send_to("", message).await
    }

    async fn send_to(&mut self, _client_id: &str, message: &Message) -> Result<(), Error> {
        // Wait for the transport to be ready
        if !self.is_ready.load(std::sync::atomic::Ordering::Acquire) {
            return Err(Error::Transport("Transport not ready".to_string()));
        }

        // Serialize the message to JSON
        let message_json = serde_json
            ::to_string(message)
            .map_err(|e| Error::Transport(format!("Failed to serialize message: {}", e)))?;

        // Send the message to the server via HTTP POST
        let response = self.http_client
            .post(&self.messages_url)
            .header("Content-Type", "application/json")
            .body(message_json)
            .send().await
            .map_err(|e| Error::Transport(format!("Failed to send message: {}", e)))?;

        // Check if the response is successful
        if !response.status().is_success() {
            let status = response.status();
            let text = response.text().await.unwrap_or_default();
            return Err(
                Error::Transport(
                    format!("Failed to send message, received status {}: {}", status, text)
                )
            );
        }

        Ok(())
    }

    async fn is_connected(&self) -> bool {
        let connected = self.connected.lock().await;
        *connected
    }

    async fn close(&mut self) -> Result<(), Error> {
        // Check if already closed
        if !self.is_connected().await {
            return Ok(());
        }

        // Send the shutdown signal
        if let Some(tx) = self.shutdown_tx.take() {
            let _ = tx.send(());
        }

        // Wait for the task to finish
        tokio::time::sleep(std::time::Duration::from_millis(100)).await;

        Ok(())
    }
}


<file_info>
path: src/types/prompts.rs
name: prompts.rs
</file_info>
//! MCP Prompt Types
//!
//! This module defines types related to prompts in the MCP protocol, including
//! `Prompt` and `PromptArgument`, which are used to manage and template interactive
//! user inputs or AI queries.

use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// A type of content that can be sent in a message
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
#[serde(tag = "type", content = "content")]
pub enum ContentPart {
    /// Text content
    #[serde(rename = "text")]
    Text(String),
    /// Image content (referenced by resource URI)
    #[serde(rename = "image")]
    Image { uri: String },
    /// Tool call content
    #[serde(rename = "tool_call")]
    ToolCall {
        /// Name of the tool to call
        tool_name: String,
        /// Parameters for the tool call
        parameters: HashMap<String, serde_json::Value>,
    },
    /// Tool result content
    #[serde(rename = "tool_result")]
    ToolResult {
        /// Name of the tool that was called
        tool_name: String,
        /// Result of the tool call
        result: serde_json::Value,
    },
}

/// Role of a message sender
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
#[serde(rename_all = "lowercase")]
pub enum Role {
    /// System message
    System,
    /// Human user message
    User,
    /// AI assistant message
    Assistant,
    /// Tool message (for tool calls or results)
    Tool,
}

/// A message in a prompt template
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct Message {
    /// Role of the message sender
    pub role: Role,
    /// Content of the message
    pub content: Vec<ContentPart>,
}

/// Represents a template argument
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct PromptArgument {
    /// Name of the argument
    pub name: String,
    /// Type of the argument (e.g., "string", "number")
    #[serde(rename = "type")]
    pub type_name: String,
    /// Description of the argument
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// Whether the argument is required
    #[serde(skip_serializing_if = "Option::is_none")]
    pub required: Option<bool>,
    /// Default value for the argument
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default: Option<serde_json::Value>,
    /// Schema for the argument, if complex
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema: Option<serde_json::Value>,
}

/// Represents a prompt template
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct Prompt {
    /// Unique name for the prompt
    pub name: String,
    /// Description of the prompt
    pub description: String,
    /// Template messages
    pub messages: Vec<Message>,
    /// Arguments for templating
    #[serde(skip_serializing_if = "Option::is_none")]
    pub arguments: Option<Vec<PromptArgument>>,
}

/// Parameters for listing prompts
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct ListPromptsParams {
    /// Optional pagination token
    #[serde(skip_serializing_if = "Option::is_none")]
    pub page_token: Option<String>,
    /// Optional limit on the number of prompts to return
    #[serde(skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i32>,
}

/// Result of listing prompts
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct ListPromptsResult {
    /// List of prompts
    pub prompts: Vec<Prompt>,
    /// Token for the next page (if there are more prompts)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_page_token: Option<String>,
}

/// Parameters for creating a prompt
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct CreatePromptParams {
    /// Unique name for the prompt
    pub name: String,
    /// Description of the prompt
    pub description: String,
    /// Template messages
    pub messages: Vec<Message>,
    /// Arguments for templating
    #[serde(skip_serializing_if = "Option::is_none")]
    pub arguments: Option<Vec<PromptArgument>>,
}

/// Result of creating a prompt
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct CreatePromptResult {
    /// The created prompt
    pub prompt: Prompt,
}

/// Parameters for updating a prompt
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct UpdatePromptParams {
    /// Name of the prompt to update
    pub name: String,
    /// New description for the prompt
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// New template messages
    #[serde(skip_serializing_if = "Option::is_none")]
    pub messages: Option<Vec<Message>>,
    /// New arguments for templating
    #[serde(skip_serializing_if = "Option::is_none")]
    pub arguments: Option<Vec<PromptArgument>>,
}

/// Result of updating a prompt
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct UpdatePromptResult {
    /// The updated prompt
    pub prompt: Prompt,
}

/// Parameters for deleting a prompt
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct DeletePromptParams {
    /// Name of the prompt to delete
    pub name: String,
}

/// Result of deleting a prompt
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct DeletePromptResult {
    /// Indicates whether the prompt was successfully deleted
    pub success: bool,
}

/// Parameters for rendering a prompt
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct RenderPromptParams {
    /// Name of the prompt to render
    pub name: String,
    /// Arguments for template substitution
    pub arguments: HashMap<String, serde_json::Value>,
}

/// Result of rendering a prompt
#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct RenderPromptResult {
    /// Rendered messages
    pub messages: Vec<Message>,
}


<file_info>
path: src/server/resources/mod.rs
name: mod.rs
</file_info>
/// Resource lifecycle state
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ResourceLifecycleState {
    /// Resource is created but not fully initialized
    Created,

    /// Resource is initialized and ready for use
    Ready,

    /// Resource has been modified
    Modified,

    /// Resource is being closed
    Closing,

    /// Resource is closed
    Closed,
}

/// Trait for resource implementations
#[async_trait]
pub trait ResourceImpl: Send + Sync + 'static {
    /// Get the resource content
    async fn read(&self) -> Result<Vec<u8>, Error>;

    /// Write content to the resource
    async fn write(&mut self, content: &[u8]) -> Result<(), Error>;

    /// Close the resource and release any associated resources
    async fn close(&mut self) -> Result<(), Error>;
}

/// Base resource structure
#[derive(Clone)]
pub struct Resource {
    /// Resource URI
    pub uri: String,

    /// Resource name
    pub name: String,

    /// Resource description
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,

    /// Resource mime type
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mime_type: Option<String>,

    /// Resource implementation
    #[serde(skip)]
    pub implementation: Arc<Mutex<Option<Box<dyn ResourceImpl>>>>,

    /// Resource lifecycle state
    #[serde(skip)]
    pub lifecycle_state: Arc<Mutex<ResourceLifecycleState>>,

    /// Subscribers to resource changes
    #[serde(skip)]
    pub subscribers: Arc<Mutex<Vec<mpsc::Sender<ResourceChangeNotification>>>>,
}

impl Resource {
    /// Create a new resource
    pub fn new(uri: String, name: String) -> Self {
        Self {
            uri,
            name,
            description: None,
            mime_type: None,
            implementation: Arc::new(Mutex::new(None)),
            lifecycle_state: Arc::new(Mutex::new(ResourceLifecycleState::Created)),
            subscribers: Arc::new(Mutex::new(Vec::new())),
        }
    }

    /// Set the resource implementation
    pub async fn set_implementation(
        &self,
        implementation: Box<dyn ResourceImpl>
    ) -> Result<(), Error> {
        let mut impl_guard = self.implementation.lock().await;
        *impl_guard = Some(implementation);

        // Update lifecycle state
        let mut state_guard = self.lifecycle_state.lock().await;
        *state_guard = ResourceLifecycleState::Ready;

        Ok(())
    }

    /// Read the resource content
    pub async fn read(&self) -> Result<Vec<u8>, Error> {
        // Check lifecycle state
        {
            let state_guard = self.lifecycle_state.lock().await;
            if *state_guard == ResourceLifecycleState::Closed {
                return Err(Error::Resource("Resource is closed".to_string()));
            }
        }

        // Get implementation
        let impl_guard = self.implementation.lock().await;
        match &*impl_guard {
            Some(implementation) => implementation.read().await,
            None => Err(Error::Resource("Resource has no implementation".to_string())),
        }
    }

    /// Write to the resource
    pub async fn write(&self, content: &[u8]) -> Result<(), Error> {
        // Check lifecycle state
        {
            let state_guard = self.lifecycle_state.lock().await;
            if *state_guard == ResourceLifecycleState::Closed {
                return Err(Error::Resource("Resource is closed".to_string()));
            }
        }

        // Get implementation
        let mut impl_guard = self.implementation.lock().await;
        match &mut *impl_guard {
            Some(implementation) => {
                let result = implementation.write(content).await;

                // Update lifecycle state
                if result.is_ok() {
                    let mut state_guard = self.lifecycle_state.lock().await;
                    *state_guard = ResourceLifecycleState::Modified;

                    // Notify subscribers
                    self.notify_change().await;
                }

                result
            }
            None => Err(Error::Resource("Resource has no implementation".to_string())),
        }
    }

    /// Close the resource
    pub async fn close(&self) -> Result<(), Error> {
        // Check lifecycle state
        {
            let state_guard = self.lifecycle_state.lock().await;
            if *state_guard == ResourceLifecycleState::Closed {
                return Ok(());
            }
        }

        // Update lifecycle state
        {
            let mut state_guard = self.lifecycle_state.lock().await;
            *state_guard = ResourceLifecycleState::Closing;
        }

        // Get implementation
        let mut impl_guard = self.implementation.lock().await;
        let result = match &mut *impl_guard {
            Some(implementation) => implementation.close().await,
            None => Ok(()),
        };

        // Update lifecycle state
        {
            let mut state_guard = self.lifecycle_state.lock().await;
            *state_guard = ResourceLifecycleState::Closed;
        }

        // Clear subscribers
        {
            let mut subscribers_guard = self.subscribers.lock().await;
            subscribers_guard.clear();
        }

        result
    }

    /// Subscribe to resource changes
    pub async fn subscribe(&self) -> mpsc::Receiver<ResourceChangeNotification> {
        let (tx, rx) = mpsc::channel(10);

        // Add subscriber
        {
            let mut subscribers_guard = self.subscribers.lock().await;
            subscribers_guard.push(tx);
        }

        rx
    }

    /// Notify subscribers of a change
    async fn notify_change(&self) {
        let notification = ResourceChangeNotification {
            uri: self.uri.clone(),
            timestamp: std::time::SystemTime::now().into(),
        };

        let mut subscribers_guard = self.subscribers.lock().await;
        subscribers_guard.retain(|tx| { tx.try_send(notification.clone()).is_ok() });
    }
}


<file_info>
path: src/transport/sse_server.rs
name: sse_server.rs
</file_info>
//! Server-side implementation of the SSE transport
//!
//! This module provides an SSE server implementation that:
//! - Accepts SSE connections from clients at the `/sse` endpoint
//! - Accepts HTTP POST requests from clients at the `/message` endpoint
//! - Routes messages between clients and the MCP server

use crate::errors::Error;
use crate::types::protocol::Message;
use crate::transport::connection_manager::ConnectionManager;
pub use crate::transport::connection_manager::MessageEventHandler;
use async_stream;

use axum::{
    Router,
    extract::{ Query, State },
    http::StatusCode,
    response::{ IntoResponse, Sse, sse::Event },
    routing::{ get, post },
};

use http::Method;
use serde_json;
use std::collections::HashMap;
use std::convert::Infallible;
use std::net::SocketAddr;
use std::sync::Arc;
use std::time::{ Duration, SystemTime };
use tokio::sync::mpsc;
use tower_http::cors::{ Any, CorsLayer };
use uuid;
use crate::transport::TransportMessageHandler;

/// Configuration options for the SSE server
#[derive(Debug, Clone)]
pub struct SseServerOptions {
    /// Address to bind the server to
    pub bind_address: String,
    /// Optional authentication token to validate requests
    pub auth_token: Option<String>,
    /// Connection timeout in seconds
    pub connection_timeout: std::time::Duration,
    /// Keep-alive interval in seconds
    pub keep_alive_interval: u64,
    /// CORS allowed origins
    pub allowed_origins: Option<Vec<String>>,
    /// Whether to require authentication
    pub require_auth: bool,
    /// Message transmitter channel
    pub message_tx: Option<mpsc::Sender<(Option<String>, Result<Message, Error>)>>,
}

impl Default for SseServerOptions {
    fn default() -> Self {
        Self {
            bind_address: "127.0.0.1:8090".to_string(),
            auth_token: None,
            connection_timeout: std::time::Duration::from_secs(30),
            keep_alive_interval: 30,
            allowed_origins: None,
            require_auth: false,
            message_tx: None,
        }
    }
}

/// Connection events emitted by the SSE server
#[derive(Debug, Clone)]
pub enum ConnectionEvent {
    /// Client connected
    ClientConnected(String),
    /// Client disconnected
    ClientDisconnected(String),
    /// Client activity (heartbeat, message, etc.)
    ClientActivity(String),
    /// Client property changed
    ClientPropertyChanged(String, String, String),
}

/// Type for connection event handlers
pub type ConnectionEventHandler = Box<dyn Fn(ConnectionEvent) + Send + Sync + 'static>;

/// Message processing event types for the event-based architecture
#[derive(Debug, Clone)]
pub enum MessageEvent {
    /// A new message was received from a client
    MessageReceived(Option<String>, Message),

    /// A message was sent to a client
    MessageSent(String, Message),

    /// A message processing error occurred
    MessageError(Option<String>, Error),
}

/// Application state for the SSE server
struct AppState {
    /// Connection manager
    connection_manager: Arc<ConnectionManager>,

    /// Authentication token (if required)
    auth_token: Option<String>,

    /// Whether authentication is required
    require_auth: bool,

    /// Allowed origins for CORS
    allowed_origins: Option<Vec<String>>,

    /// Server reference for direct handler calls
    server: Option<Arc<dyn TransportMessageHandler + Send + Sync>>,
}

impl AppState {
    fn new(
        connection_manager: Arc<ConnectionManager>,
        auth_token: Option<String>,
        require_auth: bool,
        allowed_origins: Option<Vec<String>>
    ) -> Self {
        Self {
            connection_manager,
            auth_token,
            require_auth,
            allowed_origins,
            server: None,
        }
    }
}

/// Create a transport error
fn transport_error<S: Into<String>>(message: S) -> Error {
    Error::Transport(message.into())
}

/// Server-side implementation of the SSE transport
#[derive(Clone)]
pub struct SseServerTransport {
    /// Options for SSE server
    options: SseServerOptions,

    /// Connection manager
    connection_manager: Arc<ConnectionManager>,

    /// Server socket address
    server_addr: Option<SocketAddr>,

    /// Application state
    app_state: Arc<tokio::sync::RwLock<Option<Arc<AppState>>>>,

    /// Message handler (if registered)
    message_handler: Option<Arc<dyn TransportMessageHandler + Send + Sync>>,

    /// Server task handle
    server_handle: Arc<tokio::sync::RwLock<Option<tokio::task::JoinHandle<Result<(), Error>>>>>,
}

impl SseServerTransport {
    /// Create a new SSE server transport with the given options
    pub fn new(options: SseServerOptions) -> Self {
        let connection_timeout = options.connection_timeout;
        Self {
            options: options.clone(),
            connection_manager: Arc::new(ConnectionManager::new(connection_timeout)),
            server_addr: None,
            app_state: Arc::new(tokio::sync::RwLock::new(None)),
            message_handler: None,
            server_handle: Arc::new(tokio::sync::RwLock::new(None)),
        }
    }

    /// Get the current app state
    async fn get_app_state(&self) -> Option<Arc<AppState>> {
        let guard = self.app_state.read().await;
        guard.clone()
    }

    /// Set the app state
    async fn set_app_state(&self, state: Arc<AppState>) {
        let mut guard = self.app_state.write().await;
        *guard = Some(state);
    }

    /// Register message handler
    pub fn register_message_handler<H>(&mut self, handler: H)
        where H: TransportMessageHandler + Send + Sync + 'static
    {
        self.message_handler = Some(Arc::new(handler));
    }

    /// Register server message handler
    pub async fn configure_server(
        &mut self,
        server: Arc<dyn TransportMessageHandler + Send + Sync>
    ) {
        tracing::info!("Configuring server handler");

        // Store it for direct access
        self.message_handler = Some(server.clone());

        // Update app state if it exists, or create it if it doesn't
        if let Some(app_state) = self.get_app_state().await {
            // Create a new AppState with the server included
            let new_app_state = Arc::new(AppState {
                connection_manager: app_state.connection_manager.clone(),
                auth_token: app_state.auth_token.clone(),
                require_auth: app_state.require_auth,
                allowed_origins: app_state.allowed_origins.clone(),
                server: Some(server),
            });

            // Replace the old app state
            self.set_app_state(new_app_state).await;
        } else {
            // Create a new AppState
            let new_app_state = Arc::new(
                AppState::new(
                    self.connection_manager.clone(),
                    self.options.auth_token.clone(),
                    self.options.require_auth,
                    self.options.allowed_origins.clone()
                )
            );

            // Update the AppState with the server
            let app_state_with_server = Arc::new(AppState {
                connection_manager: new_app_state.connection_manager.clone(),
                auth_token: new_app_state.auth_token.clone(),
                require_auth: new_app_state.require_auth,
                allowed_origins: new_app_state.allowed_origins.clone(),
                server: Some(server),
            });

            // Set the new app state
            self.set_app_state(app_state_with_server).await;
            tracing::info!("Created new AppState during server configuration");
        }
    }

    /// Start the SSE server transport
    pub async fn start(&mut self) -> Result<(), Error> {
        if self.server_handle.read().await.is_some() {
            // Already started
            tracing::warn!("SSE server already started");
            return Ok(());
        }

        let addr_str = self.options.bind_address.clone();
        let addr = addr_str.parse::<SocketAddr>().map_err(|e| {
            tracing::error!("Failed to parse bind address: {}", e);
            transport_error(format!("Invalid bind address: {}", e))
        })?;

        self.server_addr = Some(addr);

        // Create a new connection manager
        let connection_manager = self.connection_manager.clone();

        // Get message handler
        let message_handler = self.message_handler.clone();

        // Create app state
        let app_state = Arc::new(AppState {
            connection_manager: connection_manager.clone(),
            auth_token: self.options.auth_token.clone(),
            require_auth: self.options.require_auth,
            allowed_origins: self.options.allowed_origins.clone(),
            server: message_handler,
        });

        tracing::debug!("Created new AppState for server start");

        // Update the app state
        self.set_app_state(app_state.clone()).await;

        let cors = CorsLayer::new()
            .allow_methods([Method::GET, Method::POST, Method::OPTIONS])
            .allow_headers(Any)
            .allow_origin(Any);

        let app = Router::new()
            .route("/sse", get(handle_sse_connection))
            .route("/message", post(handle_client_message))
            .layer(cors)
            .with_state(app_state);

        let server_addr = addr.clone();
        let server_handle = tokio::spawn(async move {
            tracing::info!("Starting SSE server on {}", addr_str);
            let listener = tokio::net::TcpListener
                ::bind(server_addr).await
                .map_err(|e| {
                    transport_error(format!("Failed to bind to {}: {}", server_addr, e))
                })?;

            axum
                ::serve(listener, app.into_make_service()).await
                .map_err(|e| { transport_error(format!("Server error: {}", e)) })?;

            Ok(())
        });

        let mut handle = self.server_handle.write().await;
        *handle = Some(server_handle);

        Ok(())
    }

    /// Close the transport
    pub async fn close(&mut self) -> Result<(), Error> {
        tracing::info!("Closing SSE server transport");

        // Abort the server task if it exists
        let server_handle_opt = {
            let mut server_handle_guard = self.server_handle.write().await;
            server_handle_guard.take()
        };

        if let Some(handle) = server_handle_opt {
            handle.abort();
        }

        // Shutdown the connection manager
        self.connection_manager.shutdown().await?;

        tracing::info!("SSE server transport closed");

        Ok(())
    }
}

/// Handle an SSE connection
async fn handle_sse_connection(State(state): State<Arc<AppState>>) -> impl IntoResponse {
    // Generate client ID and session ID
    let client_id = uuid::Uuid::new_v4().to_string();
    let session_id = uuid::Uuid::new_v4().to_string();

    tracing::info!("New SSE connection: client_id = {client_id}, session_id = {session_id}");

    // Create the session-specific message endpoint URI
    let session_uri = format!("/message?session_id={}", session_id);

    // Register client with connection manager
    let client = state.connection_manager.register_client(client_id.clone(), session_id.clone());

    // Create the SSE stream
    let stream =
        async_stream::stream! {
        let endpoint_event = Event::default().event("endpoint").data(session_uri.clone());
        yield Ok::<_, Infallible>(endpoint_event);

        let keep_alive_interval = Duration::from_secs(30);
        let mut interval = tokio::time::interval(keep_alive_interval);
        let mut message_rx = client.message_sender.subscribe();

        loop {
            tokio::select! {
                msg = message_rx.recv() => {
                    match msg {
                        Ok(message) => {
                            let json_data = serde_json::to_string(&message).unwrap_or_else(|e| format!("{{\"error\":\"Serialization error: {}\"}}", e));
                            let event = Event::default().event("message").data(json_data);
                            yield Ok::<_, Infallible>(event);
                        }
                        Err(e) => {
                            tracing::error!("Error receiving client message: {}", e);
                            break;
                        }
                    }
                }
                _ = interval.tick() => {
                    let event = Event::default().event("keep-alive").data(format!("{{\"time\":{}}}", SystemTime::now().duration_since(SystemTime::UNIX_EPOCH).unwrap_or_default().as_secs()));
                    yield Ok::<_, Infallible>(event);
                    state.connection_manager.update_client_activity(&client_id);
                }
            }
        }
    };

    Sse::new(stream).into_response()
}

/// Handle a message from a client
async fn handle_client_message(
    Query(params): Query<HashMap<String, String>>,
    State(state): State<Arc<AppState>>,
    body: String
) -> Result<String, StatusCode> {
    // Extract session_id from query params
    let session_id = params.get("session_id").ok_or(StatusCode::BAD_REQUEST)?;

    // Get client by session ID
    let client = state.connection_manager
        .get_client_by_session(session_id).await
        .ok_or(StatusCode::UNAUTHORIZED)?;

    // Update activity and await the result
    state.connection_manager.update_client_activity(&client.client_id);

    let message = serde_json::from_str::<Message>(&body).map_err(|e| {
        tracing::error!("Failed to parse message: {}", e);
        StatusCode::BAD_REQUEST
    })?;

    // Process the message with the server handler if available
    if let Some(server) = &state.server {
        match server.handle_message(&client.client_id, &message).await {
            Ok(Some(response)) => {
                // Got a response, send it directly to the client
                if
                    let Some(client_obj) = state.connection_manager.get_client(
                        &client.client_id
                    ).await
                {
                    if let Err(e) = client_obj.message_sender.send(response) {
                        tracing::error!("Failed to send response to client: {}", e);
                    }
                }
            }
            Ok(None) => {
                // No response needed
                tracing::debug!("No response needed for message from client {}", client.client_id);
            }
            Err(e) => {
                tracing::error!("Error processing message from client {}: {}", client.client_id, e);
            }
        }
    } else {
        tracing::error!("No server handler registered");
    }

    // Generate unique ID for acknowledgement
    let id = uuid::Uuid::new_v4().to_string();
    Ok(format!("{{\"id\":\"{}\"}}", id))
}


<file_info>
path: src/transport/message_handler.rs
name: message_handler.rs
</file_info>
//! Transport message handler implementation

use std::sync::Arc;

use tracing::debug;

use crate::errors::Error;
use crate::types::protocol::Message;
use crate::server::server::Server;

/// Server message handler for processing messages from transports
pub struct ServerMessageHandler<S> {
    /// Reference to the server
    server: Arc<Server<S>>,
}

impl<S> ServerMessageHandler<S> where S: Clone + Send + Sync + 'static {
    /// Create a new server message handler
    pub fn new(server: Arc<Server<S>>) -> Self {
        Self { server }
    }
}

#[async_trait::async_trait]
impl<S> crate::transport::TransportMessageHandler
    for ServerMessageHandler<S>
    where S: Clone + Send + Sync + 'static
{
    async fn handle_message(
        &self,
        client_id: &str,
        message: &Message
    ) -> Result<Option<Message>, Error> {
        // Process the message using the server and directly return the response
        debug!("Processing message from client {}: {:?}", client_id, message);
        self.server.process_message(client_id, message).await
    }
}


<file_info>
path: src/server/tools/mod.rs
name: mod.rs
</file_info>
//! Tool Support for MCP-rs
//!
//! This module provides implementations for the tool execution system,
//! including process management, progress tracking, and tool registration.

pub mod tool_registry;
pub mod process_manager;
pub mod progress;
pub mod message_parser;

// Re-export commonly used types
pub use tool_registry::ToolRegistry;
pub use process_manager::ToolProcessManager;
pub use progress::ToolProgressTracker;


<file_info>
path: src/server/tools/message_parser.rs
name: message_parser.rs
</file_info>
// src/tools/message_parser.rs
//! Message Parser for Tool Communication
//!
//! This module provides a buffered message parser for reading structured messages
//! from tool processes, handling partial reads and message boundaries correctly.

use std::io::Error as IoError;
use tokio::io::{ AsyncBufReadExt, BufReader };

/// A parser for reading line-delimited messages from an async reader
pub struct MessageParser<R> {
    /// The buffered reader
    reader: BufReader<R>,
    /// Internal buffer for partial messages
    buffer: String,
}

impl<R: tokio::io::AsyncRead + Unpin> MessageParser<R> {
    /// Create a new message parser for the given reader
    pub fn new(reader: R) -> Self {
        Self {
            reader: BufReader::new(reader),
            buffer: String::new(),
        }
    }

    /// Read the next complete message, waiting for a newline delimiter
    pub async fn next_message(&mut self) -> Result<Option<String>, IoError> {
        loop {
            // Check if we have a complete message in the buffer
            if let Some(pos) = self.buffer.find('\n') {
                let message = self.buffer[..pos].to_string();
                self.buffer = self.buffer[pos + 1..].to_string();
                return Ok(Some(message));
            }

            // Read more data
            let bytes_read = self.reader.read_line(&mut self.buffer).await?;
            if bytes_read == 0 {
                // EOF
                if self.buffer.is_empty() {
                    return Ok(None);
                } else {
                    // Return remaining data as a message
                    let message = std::mem::take(&mut self.buffer);
                    return Ok(Some(message));
                }
            }
        }
    }

    /// Read multiple messages until EOF or the provided limit is reached
    pub async fn read_messages(&mut self, limit: Option<usize>) -> Result<Vec<String>, IoError> {
        let mut messages = Vec::new();
        let limit = limit.unwrap_or(usize::MAX);

        while messages.len() < limit {
            match self.next_message().await? {
                Some(message) => messages.push(message),
                None => {
                    break;
                }
            }
        }

        Ok(messages)
    }

    /// Read all available messages without waiting
    pub async fn read_available(&mut self) -> Result<Vec<String>, IoError> {
        let mut messages = Vec::new();

        // First check the buffer for any complete messages
        while let Some(pos) = self.buffer.find('\n') {
            let message = self.buffer[..pos].to_string();
            self.buffer = self.buffer[pos + 1..].to_string();
            messages.push(message);
        }

        // Then try to read more without blocking
        match
            tokio::time::timeout(std::time::Duration::from_millis(1), self.reader.fill_buf()).await
        {
            Ok(Ok(buf)) => {
                if !buf.is_empty() {
                    // More data available, process it
                    let mut read_messages = self.read_messages(None).await?;
                    messages.append(&mut read_messages);
                }
            }
            _ => (), // Timeout or error, just return what we have
        }

        Ok(messages)
    }
}


<file_info>
path: src/server/handlers/initialize_handler.rs
name: initialize_handler.rs
</file_info>
//! Handler for initialization messages

use async_trait::async_trait;
use tracing::{ debug, error, info, warn };

use crate::errors::Error;
use crate::types::protocol::{ Message, RequestMessage, ResponseMessage, error_response };
use crate::server::MessageHandler;
use crate::types::initialize::{
    ServerCapabilities,
    Implementation,
    ResourceCapabilities,
    ToolCapabilities,
    PromptCapabilities,
    LoggingCapabilities,
    InitializeResult,
};

/// Handler for Initialize messages
pub struct InitializeHandler {
    /// Server capabilities to report to the client
    server_capabilities: ServerCapabilities,
    /// Server information
    server_info: Implementation,
    /// Protocol version
    protocol_version: String,
}

impl InitializeHandler {
    /// Create a new instance of the initialization handler
    pub fn new() -> Self {
        Self {
            server_capabilities: ServerCapabilities::default(),
            server_info: Implementation {
                name: "MCP-RS".to_string(),
                version: Some(env!("CARGO_PKG_VERSION").to_string()),
            },
            protocol_version: "0.1.0".to_string(),
        }
    }

    /// Set server information
    pub fn with_server_info(mut self, name: String, version: Option<String>) -> Self {
        self.server_info = Implementation {
            name,
            version,
        };
        self
    }

    /// Set protocol version
    pub fn with_protocol_version(mut self, version: String) -> Self {
        self.protocol_version = version;
        self
    }

    /// Set resource capabilities
    pub fn with_resource_capabilities(mut self, list_changed: bool, subscribe: bool) -> Self {
        self.server_capabilities.resources = Some(ResourceCapabilities {
            list_changed,
            subscribe,
        });
        self
    }

    /// Set tool capabilities
    pub fn with_tool_capabilities(mut self, list_changed: bool) -> Self {
        self.server_capabilities.tools = Some(ToolCapabilities {
            list_changed,
        });
        self
    }

    /// Set prompt capabilities
    pub fn with_prompt_capabilities(mut self, list_changed: bool) -> Self {
        self.server_capabilities.prompts = Some(PromptCapabilities {
            list_changed,
        });
        self
    }

    /// Add logging capabilities
    pub fn with_logging_capabilities(mut self) -> Self {
        self.server_capabilities.logging = Some(LoggingCapabilities {});
        self
    }

    /// Add experimental capabilities
    pub fn with_experimental_capabilities(mut self, capabilities: serde_json::Value) -> Self {
        self.server_capabilities.experimental = Some(capabilities);
        self
    }
}

#[async_trait]
impl MessageHandler for InitializeHandler {
    async fn handle(&self, _client_id: &str, message: &Message) -> Result<Option<Message>, Error> {
        match message {
            Message::Request(req) if req.method == "initialize" => {
                // Parse into typed request
                match Message::parse_request(req) {
                    Ok(RequestMessage::Initialize { params }) => {
                        // Log details from params
                        info!(
                            "Initialize request with protocol version: {}",
                            params.protocol_version
                        );
                        if let Some(client_info) = &params.client_info {
                            info!(
                                "Client info: {} {}",
                                client_info.name,
                                client_info.version.as_deref().unwrap_or("unknown")
                            );
                        }

                        // Create the initialize result
                        let result = InitializeResult {
                            capabilities: self.server_capabilities.clone(),
                            server_info: Some(self.server_info.clone()),
                            protocol_version: self.protocol_version.clone(),
                            instructions: None,
                        };

                        // Create the response message
                        let response_message = ResponseMessage::Initialize {
                            result,
                            meta: None,
                        };

                        // Convert to JSON-RPC Response
                        match Message::response_from_typed(req.id, response_message) {
                            Ok(response) => Ok(Some(Message::Response(response))),
                            Err(e) => {
                                debug!("Error creating response: {}", e);
                                Ok(
                                    Some(
                                        Message::Response(
                                            error_response(
                                                req.id,
                                                -32700,
                                                &format!("Error creating response: {}", e),
                                                None
                                            )
                                        )
                                    )
                                )
                            }
                        }
                    }
                    Ok(_) => {
                        // This shouldn't happen, but handle it just in case
                        warn!(
                            "Request didn't parse as Initialize despite method being 'initialize'"
                        );
                        Ok(
                            Some(
                                Message::Response(
                                    error_response(
                                        req.id,
                                        -32700,
                                        "Parse error: Request method is 'initialize' but didn't parse as Initialize",
                                        None
                                    )
                                )
                            )
                        )
                    }
                    Err(e) => {
                        error!("Error parsing initialize request: {}", e);
                        Ok(
                            Some(
                                Message::Response(
                                    error_response(
                                        req.id,
                                        -32700,
                                        &format!("Parse error: {}", e),
                                        None
                                    )
                                )
                            )
                        )
                    }
                }
            }
            _ => {
                // This handler only handles initialize requests
                Err(Error::Transport("Non-initialize message received".into()))
            }
        }
    }
}


<file_info>
path: src/transport/stdio.rs
name: stdio.rs
</file_info>
//! STDIO Transport
//!
//! This module implements the STDIO transport for the MCP library, enabling
//! communication via standard input and output streams. It is particularly useful
//! for local subprocess communication in CLI-based MCP servers.

use std::sync::Arc;

use crate::errors::Error;
use crate::types::protocol::Message;
use crate::transport::{ Transport, TransportMessageHandler };
use async_trait::async_trait;
use std::collections::HashMap;
use tokio::io::{ AsyncBufReadExt, AsyncWriteExt };
use tracing;
use std::process::Stdio;
use tokio::process;
use tokio::sync::mpsc;

/// Channels used for process communication
struct StdioChannels {
    /// Receiver for incoming messages
    message_rx: mpsc::Receiver<Result<Message, Error>>,
    /// Sender for outgoing messages
    outgoing_tx: mpsc::Sender<Message>,
    /// Task handle for reader
    #[allow(dead_code)]
    reader_task: tokio::task::JoinHandle<()>,
    /// Task handle for writer
    #[allow(dead_code)]
    writer_task: tokio::task::JoinHandle<()>,
}

/// A transport implementation that uses standard input and output
pub struct StdioTransport {
    /// Child process
    process: Option<process::Child>,

    /// Process command
    command: String,

    /// Process arguments
    args: Vec<String>,

    /// Process environment variables
    env: Option<HashMap<String, String>>,

    /// Process communication channels
    channels: Option<StdioChannels>,

    /// Is the transport connected
    connected: bool,

    /// Standard input for direct I/O mode
    stdin: Option<tokio::io::Stdin>,

    /// Standard output for direct I/O mode
    stdout: Option<tokio::io::Stdout>,

    /// Buffered reader for stdin
    reader: Option<tokio::io::BufReader<tokio::io::Stdin>>,

    /// Message handler (if registered)
    message_handler: Option<Arc<dyn TransportMessageHandler + Send + Sync>>,
}

impl StdioTransport {
    /// Create a new STDIO transport
    pub fn new() -> Self {
        Self {
            process: None,
            command: String::new(),
            args: Vec::new(),
            env: None,
            channels: None,
            connected: false,
            stdin: None,
            stdout: None,
            reader: None,
            message_handler: None,
        }
    }

    /// Start the process and establish communication channels
    async fn start_process(&mut self) -> Result<(), Error> {
        // Notify starting
        tracing::info!("STDIO transport starting");

        let mut command = tokio::process::Command::new(&self.command);
        command.args(&self.args);

        // Set environment
        if let Some(env) = &self.env {
            for (key, value) in env {
                command.env(key, value);
            }
        }

        // Configure stdio
        command.stdin(Stdio::piped());
        command.stdout(Stdio::piped());
        command.stderr(Stdio::inherit());

        // Spawn process
        let mut child = command
            .spawn()
            .map_err(|e| Error::Transport(format!("Failed to spawn process: {}", e)))?;

        // Get stdio handles
        let stdin = child.stdin
            .take()
            .ok_or_else(|| Error::Transport("Failed to get stdin handle".to_string()))?;
        let stdout = child.stdout
            .take()
            .ok_or_else(|| Error::Transport("Failed to get stdout handle".to_string()))?;

        // Create channels
        let (message_tx, message_rx) = mpsc::channel(100);
        let (outgoing_tx, outgoing_rx) = mpsc::channel(100);

        // Start reader and writer tasks
        let reader_task = tokio::spawn(stdio_reader(stdout, message_tx.clone()));
        let writer_task = tokio::spawn(stdio_writer(stdin, outgoing_rx));

        // Store everything
        self.process = Some(child);
        self.channels = Some(StdioChannels {
            message_rx,
            outgoing_tx,
            reader_task,
            writer_task,
        });

        self.connected = true;

        // Notify started
        tracing::info!("STDIO transport started");

        Ok(())
    }

    /// Register a message handler
    pub fn register_message_handler<H>(&mut self, handler: H)
        where H: TransportMessageHandler + Send + Sync + 'static
    {
        self.message_handler = Some(Arc::new(handler));
    }
}

/// Process stdout from a child process and forward messages
async fn stdio_reader(
    stdout: process::ChildStdout,
    tx: mpsc::Sender<Result<Message, Error>>
) -> () {
    let mut reader = tokio::io::BufReader::new(stdout);
    let mut line = String::new();

    loop {
        line.clear();
        match reader.read_line(&mut line).await {
            Ok(0) => {
                // EOF
                break;
            }
            Ok(_) => {
                // Parse the JSON message
                match serde_json::from_str::<Message>(&line) {
                    Ok(message) => {
                        let _ = tx.send(Ok(message)).await;
                    }
                    Err(e) => {
                        let _ = tx.send(Err(Error::Json(e))).await;
                    }
                }
            }
            Err(e) => {
                let _ = tx.send(Err(Error::Io(e))).await;
                break;
            }
        }
    }
}

/// Process outgoing messages and write to stdin
async fn stdio_writer(mut stdin: process::ChildStdin, mut rx: mpsc::Receiver<Message>) -> () {
    while let Some(message) = rx.recv().await {
        match serde_json::to_string(&message) {
            Ok(json) => {
                // Write the JSON followed by a newline
                if stdin.write_all(json.as_bytes()).await.is_err() {
                    break;
                }
                if stdin.write_all(b"\n").await.is_err() {
                    break;
                }
                if stdin.flush().await.is_err() {
                    break;
                }
            }
            Err(_) => {
                // Ignore serialization errors
                continue;
            }
        }
    }
}

#[async_trait]
impl Transport for StdioTransport {
    /// Start the transport - for stdio this initializes the process
    async fn start(&mut self) -> Result<(), Error> {
        // Check if we're already started
        if self.connected {
            return Ok(());
        }

        // If we have a command, start the process
        if !self.command.is_empty() {
            self.start_process().await?;
        } else {
            // Otherwise just use stdin/stdout directly
            if self.stdin.is_none() {
                self.stdin = Some(tokio::io::stdin());
                self.stdout = Some(tokio::io::stdout());
                self.reader = Some(tokio::io::BufReader::new(tokio::io::stdin()));
            }
            self.connected = true;
        }

        Ok(())
    }

    async fn receive(&mut self) -> Result<(Option<String>, Message), Error> {
        if !self.connected {
            return Err(Error::Transport("Transport is not connected".to_string()));
        }

        let mut line = String::new();

        if let Some(reader) = &mut self.reader {
            match reader.read_line(&mut line).await {
                Ok(0) => {
                    // EOF
                    self.connected = false;
                    Err(Error::Transport("EOF reached".to_string()))
                }
                Ok(_) => {
                    // Parse the JSON message
                    serde_json
                        ::from_str(&line)
                        .map_err(Error::Json)
                        .map(|msg| (None, msg)) // StdioTransport has no client ID concept
                }
                Err(e) => {
                    self.connected = false;
                    Err(Error::Io(e))
                }
            }
        } else if let Some(channels) = &mut self.channels {
            match channels.message_rx.recv().await {
                Some(result) => result.map(|msg| (None, msg)), // StdioTransport has no client ID concept
                None => {
                    self.connected = false;
                    Err(Error::Transport("Channel closed".to_string()))
                }
            }
        } else {
            Err(Error::Transport("Transport is not properly initialized".to_string()))
        }
    }

    async fn send(&mut self, message: &Message) -> Result<(), Error> {
        if !self.connected {
            return Err(Error::Transport("Transport is not connected".to_string()));
        }

        // Serialize the message to JSON
        let json = serde_json::to_string(message).map_err(Error::Json)?;

        if let Some(channels) = &mut self.channels {
            // Send through process channels
            channels.outgoing_tx
                .send(message.clone()).await
                .map_err(|_| Error::Transport("Failed to send message".to_string()))?;
        } else if let Some(stdout) = &mut self.stdout {
            // Write directly to stdout using tokio async operations
            stdout.write_all(json.as_bytes()).await.map_err(Error::Io)?;
            stdout.write_all(b"\n").await.map_err(Error::Io)?;
            stdout.flush().await.map_err(Error::Io)?;
        } else {
            return Err(Error::Transport("Transport is not properly initialized".to_string()));
        }

        Ok(())
    }

    async fn send_to(&mut self, _client_id: &str, message: &Message) -> Result<(), Error> {
        // For STDIO transport, there's only one client, so send_to behaves the same as send
        self.send(message).await
    }

    async fn is_connected(&self) -> bool {
        self.connected
    }

    async fn close(&mut self) -> Result<(), Error> {
        // First drop the channels if they exist, which will signal the tasks to shut down
        if let Some(channels) = self.channels.take() {
            // Abort reader and writer tasks
            channels.reader_task.abort();
            channels.writer_task.abort();
        }

        // Close child process if any
        if let Some(mut child) = self.process.take() {
            // Kill the process
            if let Err(e) = child.kill().await {
                tracing::warn!("Failed to kill child process: {}", e);
            }
        }

        self.connected = false;
        tracing::info!("STDIO transport closed");
        Ok(())
    }
}

#[async_trait::async_trait]
impl TransportMessageHandler for StdioTransport {
    async fn handle_message(
        &self,
        client_id: &str,
        message: &Message
    ) -> Result<Option<Message>, Error> {
        if let Some(handler) = &self.message_handler {
            // Forward to the registered handler
            handler.handle_message(client_id, message).await
        } else {
            Err(Error::Transport("No message handler registered".to_string()))
        }
    }
}

impl Default for StdioTransport {
    fn default() -> Self {
        Self::new()
    }
}


<file_info>
path: src/server/handlers/tool_handler.rs
name: tool_handler.rs
</file_info>
//! Handler for tool-related messages

use async_trait::async_trait;
use tracing::{ info, error };
use std::sync::Arc;

use crate::errors::Error;
use crate::types::protocol::{ Message, RequestMessage, ResponseMessage };
use crate::types::tools::{ CallToolParams, ListToolsParams, ListToolsResult };
use crate::server::MessageHandler;
use crate::server::tools::tool_registry::ToolRegistry;

/// Handler for tool-related requests
#[derive(Clone)]
pub struct ToolHandler {
    /// Tool registry to manage available tools
    tool_registry: Arc<ToolRegistry>,
}

impl ToolHandler {
    /// Create a new instance of the tool handler
    pub fn new(tool_registry: Arc<ToolRegistry>) -> Self {
        Self {
            tool_registry,
        }
    }

    /// Handle tools/list request
    async fn handle_list_tools(
        &self,
        params: ListToolsParams,
        client_id: &str,
        req: &crate::types::protocol::Request
    ) -> Result<Option<Message>, Error> {
        info!("TOOL LIST request from client {}", client_id);

        // Get all tools from registry
        let all_tools = self.tool_registry.list_tools().await;

        // Apply pagination
        let page_size = match params.page_size {
            Some(size) => size.min(100) as usize, // Max 100 items per page
            None => 20, // Default to 20 items per page
        };

        let start_index = match params.page_token {
            Some(ref token) => token.parse::<usize>().unwrap_or(0),
            None => 0,
        };

        // Slice the tools based on pagination
        let end_index = (start_index + page_size).min(all_tools.len());
        let tools = all_tools[start_index..end_index].to_vec();

        // Generate next page token if there are more tools
        let next_page_token = if end_index < all_tools.len() {
            Some(end_index.to_string())
        } else {
            None
        };

        // Create the result
        let result = ListToolsResult {
            tools,
            next_page_token,
        };

        // Create response message
        let response_message = ResponseMessage::ListTools {
            result,
            meta: None,
        };

        // Convert to JSON-RPC Response
        match Message::response_from_typed(req.id, response_message) {
            Ok(response) => Ok(Some(Message::Response(response))),
            Err(e) => {
                error!("Error creating response: {}", e);
                let error_resp = crate::utils::errors::tool_execution_error(
                    req.id,
                    "list_tools",
                    &format!("Failed to serialize response: {}", e)
                );
                Ok(Some(Message::Response(error_resp)))
            }
        }
    }

    /// Handle tools/call request
    async fn handle_call_tool(
        &self,
        client_id: &str,
        req: &crate::types::protocol::Request,
        params: CallToolParams
    ) -> Result<Option<Message>, Error> {
        info!("TOOL CALL {} from client {}", params.name, client_id);
        // Check if tool exists
        if !self.tool_registry.has_tool(&params.name.clone()).await {
            let error_resp = crate::utils::errors::tool_not_found(req.id, &params.name);
            return Ok(Some(Message::Response(error_resp)));
        }

        // Execute the tool directly using the registry
        match self.tool_registry.execute_tool_with_params(params.clone()).await {
            Ok(result) => {
                // Create response message
                let response_message = ResponseMessage::CallTool {
                    result,
                    meta: None,
                };

                // Convert to JSON-RPC Response
                match Message::response_from_typed(req.id, response_message) {
                    Ok(response) => Ok(Some(Message::Response(response))),
                    Err(e) => {
                        error!("Error creating response: {}", e);
                        let error_resp = crate::utils::errors::tool_execution_error(
                            req.id,
                            &params.name,
                            &format!("Failed to serialize response: {}", e)
                        );
                        Ok(Some(Message::Response(error_resp)))
                    }
                }
            }
            Err(e) => {
                error!("Error executing tool {}: {}", params.name, e);
                let error_resp = crate::utils::errors::tool_execution_error(
                    req.id,
                    &params.name,
                    &format!("Error executing tool: {}", e)
                );
                Ok(Some(Message::Response(error_resp)))
            }
        }
    }
}

#[async_trait]
impl MessageHandler for ToolHandler {
    async fn handle(&self, client_id: &str, message: &Message) -> Result<Option<Message>, Error> {
        match message {
            Message::Request(req) => {
                match Message::parse_request(req) {
                    Ok(RequestMessage::ListTools { params }) => {
                        self.handle_list_tools(params, client_id, req).await
                    }

                    Ok(RequestMessage::CallTool { params }) => {
                        self.handle_call_tool(client_id, req, params).await
                    }

                    _ => {
                        // Not a tool-related request
                        Err(Error::MethodNotFound("Not a tool-related request".into()))
                    }
                }
            }
            _ => {
                // Not a request message
                Err(Error::MethodNotFound("Not a request message".into()))
            }
        }
    }
}


<file_info>
path: src/transport/websocket_server.rs
name: websocket_server.rs
</file_info>
//! Server-side WebSocket transport implementation using Axum
//!
//! This module provides a WebSocket server implementation built on Axum that:
//! - Accepts WebSocket connections from clients at the configured endpoint
//! - Routes messages between clients and the MCP server
//! - Supports bidirectional real-time communication
//! - Provides client tracking and management

use crate::errors::Error;
use crate::types::protocol::Message;
use crate::transport::Transport;
use async_trait::async_trait;
use axum::{
    Extension,
    Router,
    extract::ws::{ Message as AxumWsMessage, WebSocket, WebSocketUpgrade },
    response::IntoResponse,
    routing::get,
};
use futures_util::{ SinkExt, StreamExt };
use http::HeaderValue;
use scopeguard;
use serde_json::{ self };
use std::collections::HashMap;
use std::net::SocketAddr;
use std::sync::{ Arc, Mutex };
use std::time::{ Duration, SystemTime };
use tokio::sync::{ broadcast, mpsc, oneshot };
use tower_http::cors::{ Any, CorsLayer };
use uuid::Uuid;

/// Maximum number of concurrent clients
const MAX_CLIENTS: usize = 100;

/// Default connection timeout
const DEFAULT_CONNECTION_TIMEOUT: Duration = Duration::from_secs(30);
/// Default heartbeat interval
const DEFAULT_HEARTBEAT_INTERVAL: Duration = Duration::from_secs(30);
/// Default reconnection delay
const DEFAULT_RECONNECT_DELAY: Duration = Duration::from_secs(2);

/// Configuration options for the WebSocket server
#[derive(Debug, Clone)]
pub struct WebSocketServerOptions {
    /// Address to bind the server to
    pub bind_address: SocketAddr,
    /// Path for the WebSocket endpoint
    pub websocket_path: String,
    /// Optional authentication token to validate requests
    pub auth_token: Option<String>,
    /// Connection timeout
    pub connection_timeout: Duration,
    /// Heartbeat interval
    pub heartbeat_interval: Duration,
    /// Whether to require authentication
    pub require_auth: bool,
    /// CORS allowed origins
    pub allowed_origins: Option<Vec<String>>,
}

impl Default for WebSocketServerOptions {
    fn default() -> Self {
        Self {
            bind_address: "127.0.0.1:9000".parse().unwrap(),
            websocket_path: "/ws".to_string(),
            auth_token: None,
            connection_timeout: DEFAULT_CONNECTION_TIMEOUT,
            heartbeat_interval: DEFAULT_HEARTBEAT_INTERVAL,
            require_auth: false,
            allowed_origins: None,
        }
    }
}

/// A client connection
#[derive(Debug)]
struct ClientConnection {
    id: String,
    connected_at: SystemTime,
    last_activity: SystemTime,
    sender: broadcast::Sender<String>, // Using String to avoid Clone bound issues
}

/// Shared application state for WebSocket server
#[derive(Clone)]
struct AppState {
    clients: Arc<Mutex<HashMap<String, ClientConnection>>>,
    message_tx: mpsc::Sender<(String, Result<Message, Error>)>,
}

/// Server-side implementation of the WebSocket transport using Axum
pub struct WebSocketServerTransport {
    /// Map of client IDs to connection info
    clients: Arc<Mutex<HashMap<String, ClientConnection>>>,
    /// Channel for incoming messages from clients
    message_rx: mpsc::Receiver<(String, Result<Message, Error>)>,
    /// Channel for sending messages to specific clients
    message_tx: mpsc::Sender<(String, Result<Message, Error>)>,
    /// Channel to notify when the server should shut down
    shutdown_tx: Option<oneshot::Sender<()>>,
    /// Server options
    options: WebSocketServerOptions,
    /// Server handle
    server_handle: Option<tokio::task::JoinHandle<()>>,
    /// Is the transport connected
    connected: bool,
}

impl WebSocketServerTransport {
    /// Create a new WebSocket server transport with default options
    pub fn new() -> Self {
        Self::with_options(WebSocketServerOptions::default())
    }

    /// Create a new WebSocket server transport with the specified options
    pub fn with_options(options: WebSocketServerOptions) -> Self {
        let (message_tx, message_rx) = mpsc::channel(100);

        Self {
            clients: Arc::new(Mutex::new(HashMap::new())),
            message_rx,
            message_tx,
            shutdown_tx: None,
            options,
            server_handle: None,
            connected: false,
        }
    }

    /// Start the WebSocket server
    pub async fn start(&mut self) -> Result<(), Error> {
        if self.connected {
            return Err(Error::Transport("WebSocket server already running".to_string()));
        }

        // Notify Starting lifecycle event
        tracing::info!("WebSocket server transport starting");

        // Create the app state
        let app_state = AppState {
            clients: self.clients.clone(),
            message_tx: self.message_tx.clone(),
        };

        // Create a CORS layer
        let cors = match &self.options.allowed_origins {
            Some(origins) => {
                let mut layer = CorsLayer::new();
                for origin in origins {
                    layer = layer.allow_origin(origin.parse::<HeaderValue>().unwrap());
                }
                layer.allow_methods(Any).allow_headers(Any).max_age(Duration::from_secs(86400))
            }
            None => CorsLayer::permissive(),
        };

        // Build the router
        let app = Router::new()
            .route(&self.options.websocket_path, get(ws_handler))
            .layer(Extension(app_state))
            .layer(cors);

        // Create a shutdown channel
        let (shutdown_tx, shutdown_rx) = oneshot::channel::<()>();
        self.shutdown_tx = Some(shutdown_tx);

        // Start the server
        let bind_address = self.options.bind_address;
        let server_handle = tokio::spawn(async move {
            tracing::info!("Starting WebSocket server on {}", bind_address);

            // Build our application with the specified routes
            let listener = tokio::net::TcpListener::bind(&bind_address).await.unwrap();
            tracing::info!("Listening on {}", bind_address);

            // Start the Axum server
            axum::serve(listener, app)
                .with_graceful_shutdown(async {
                    let _ = shutdown_rx.await;
                    tracing::info!("WebSocket server shutting down");
                }).await
                .unwrap_or_else(|e| {
                    tracing::error!("Server error: {}", e);
                })
        });

        self.server_handle = Some(server_handle);
        self.connected = true;
        tracing::info!(
            "WebSocket server started at ws://{}{}",
            self.options.bind_address,
            self.options.websocket_path
        );

        // Notify Started lifecycle event
        tracing::info!("WebSocket server transport started");

        Ok(())
    }

    /// Get the number of connected clients
    pub fn connected_clients(&self) -> usize {
        self.clients.lock().unwrap().len()
    }
}

/// WebSocket connection handler
async fn ws_handler(
    ws: WebSocketUpgrade,
    Extension(state): Extension<AppState>
) -> impl IntoResponse {
    // Upgrade the connection to WebSocket
    ws.on_upgrade(move |socket| handle_socket(socket, state))
}

/// Handle WebSocket connection
async fn handle_socket(socket: WebSocket, state: AppState) {
    let clients = state.clients.clone();
    let message_tx = state.message_tx.clone();

    // Check if we've reached maximum clients
    {
        let clients_map = clients.lock().unwrap();
        if clients_map.len() >= MAX_CLIENTS {
            // Too many clients connected
            tracing::warn!("Maximum client connections reached");
            return;
        }
    }

    // Generate a client ID
    let client_id = Uuid::new_v4().to_string();

    // Create broadcast channel for this client
    let (sender, _) = broadcast::channel(100);

    // Register the client
    {
        let mut clients_map = clients.lock().unwrap();
        clients_map.insert(client_id.clone(), ClientConnection {
            id: client_id.clone(),
            connected_at: SystemTime::now(),
            last_activity: SystemTime::now(),
            sender: sender.clone(),
        });
    }

    tracing::info!("New WebSocket client connected: {}", client_id);

    // Split the socket
    let (mut sender_socket, mut receiver_socket) = socket.split();

    // Clone for cleanup
    let clients_for_cleanup = clients.clone();
    let client_id_for_cleanup = client_id.clone();

    // Ensure client is removed when connection is closed
    let _cleanup = scopeguard::guard((), move |_| {
        let mut clients_map = clients_for_cleanup.lock().unwrap();
        if clients_map.remove(&client_id_for_cleanup).is_some() {
            tracing::info!("WebSocket client disconnected: {}", client_id_for_cleanup);
        }
    });

    // Create receiver for messages to send to this client
    let mut client_receiver = {
        let clients_map = clients.lock().unwrap();
        if let Some(client) = clients_map.get(&client_id) {
            client.sender.subscribe()
        } else {
            return; // Client already disconnected
        }
    };

    // Process incoming messages from the client
    let client_id_clone = client_id.clone();
    let message_tx_clone = message_tx.clone();
    let receive_task = tokio::spawn(async move {
        while let Some(result) = receiver_socket.next().await {
            match result {
                Ok(msg) => {
                    // Handle message from client
                    match msg {
                        AxumWsMessage::Text(text) => {
                            match serde_json::from_str::<Message>(&text) {
                                Ok(message) => {
                                    // Forward message to MCP server
                                    if
                                        message_tx_clone
                                            .send((client_id_clone.clone(), Ok(message))).await
                                            .is_err()
                                    {
                                        break;
                                    }
                                }
                                Err(e) => {
                                    tracing::error!("Failed to parse message: {}", e);
                                    // Send error to MCP server
                                    if
                                        message_tx_clone
                                            .send((
                                                client_id_clone.clone(),
                                                Err(Error::Json(e)),
                                            )).await
                                            .is_err()
                                    {
                                        break;
                                    }
                                }
                            }
                        }
                        AxumWsMessage::Binary(data) => {
                            // Try to parse binary data as JSON message
                            if let Ok(text) = std::str::from_utf8(&data) {
                                match serde_json::from_str::<Message>(text) {
                                    Ok(message) => {
                                        if
                                            message_tx_clone
                                                .send((client_id_clone.clone(), Ok(message))).await
                                                .is_err()
                                        {
                                            break;
                                        }
                                    }
                                    Err(e) => {
                                        tracing::error!("Failed to parse binary message: {}", e);
                                        if
                                            message_tx_clone
                                                .send((
                                                    client_id_clone.clone(),
                                                    Err(Error::Json(e)),
                                                )).await
                                                .is_err()
                                        {
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                        AxumWsMessage::Close(_) => {
                            break;
                        }
                        // Ignore other message types like Ping/Pong
                        _ => {}
                    }
                }
                Err(e) => {
                    tracing::error!("WebSocket error: {}", e);
                    break;
                }
            }
        }
    });

    // Forward messages from server to client
    let send_task = tokio::spawn(async move {
        while let Ok(json) = client_receiver.recv().await {
            if sender_socket.send(AxumWsMessage::Text(json.into())).await.is_err() {
                break;
            }
        }
    });

    // Wait for either task to complete
    tokio::select! {
        _ = receive_task => {}
        _ = send_task => {}
    }
}

// Implement the Transport trait for WebSocketServerTransport
#[async_trait]
impl Transport for WebSocketServerTransport {
    /// Start the transport - this initializes the websocket server
    async fn start(&mut self) -> Result<(), Error> {
        // Call the existing start method if we're not already connected
        if !self.connected {
            self.start().await?;
        }

        Ok(())
    }

    async fn receive(&mut self) -> Result<(Option<String>, Message), Error> {
        // Check if the server is running, if not return an error (start() should have been called)
        if !self.connected {
            return Err(
                Error::Transport(
                    "WebSocket server not started yet - call start() first".to_string()
                )
            );
        }

        // Wait for a message from the client using the message channel
        match self.message_rx.try_recv() {
            Ok((client_id, result)) => {
                match result {
                    Ok(message) => Ok((Some(client_id), message)),
                    Err(e) => Err(e),
                }
            }
            Err(_) => {
                // No message available, wait a bit and return a timeout error
                tokio::time::sleep(std::time::Duration::from_millis(100)).await;
                Err(Error::Timeout("No messages available".to_string()))
            }
        }
    }

    async fn send_to(&mut self, client_id: &str, message: &Message) -> Result<(), Error> {
        if !self.connected {
            return Err(Error::Transport("WebSocket server not running".to_string()));
        }

        // Serialize the message
        let json = serde_json::to_string(message).map_err(Error::Json)?;

        // Find the specific client
        let clients_map = self.clients.lock().unwrap();
        if let Some(client) = clients_map.get(client_id) {
            // Send the message to only this client
            if client.sender.send(json).is_err() {
                return Err(
                    Error::Transport(format!("Failed to send message to client: {}", client_id))
                );
            }
            Ok(())
        } else {
            Err(Error::Transport(format!("Client not found: {}", client_id)))
        }
    }

    async fn send(&mut self, message: &Message) -> Result<(), Error> {
        if !self.connected {
            return Err(Error::Transport("WebSocket server not running".to_string()));
        }

        // Serialize the message
        let json = serde_json::to_string(message).map_err(Error::Json)?;

        // Send to all clients
        {
            let clients_map = self.clients.lock().unwrap();
            if clients_map.is_empty() {
                return Err(Error::Transport("No connected clients".to_string()));
            }

            // Broadcast to all clients
            for (_, client) in clients_map.iter() {
                let _ = client.sender.send(json.clone());
            }
        }

        Ok(())
    }

    async fn is_connected(&self) -> bool {
        self.connected
    }

    async fn close(&mut self) -> Result<(), Error> {
        if !self.connected {
            return Ok(());
        }

        // Notify Closing lifecycle event
        tracing::info!("WebSocket server transport closing");

        // Trigger server shutdown
        if let Some(tx) = self.shutdown_tx.take() {
            let _ = tx.send(());
        }

        // Wait for server to shut down
        if let Some(handle) = self.server_handle.take() {
            let _ = handle.await;
        }

        // Clear all clients
        {
            let mut clients_map = self.clients.lock().unwrap();
            clients_map.clear();
        }

        self.connected = false;
        tracing::info!("WebSocket server stopped");

        // Notify Closed lifecycle event
        tracing::info!("WebSocket server transport closed");

        Ok(())
    }
}


<file_info>
path: examples/sseserver_with_handlers.rs
name: sseserver_with_handlers.rs
</file_info>
//! Example server with transport and message handlers
//!
//! This example shows how to set up an MCP server with handlers
//! for different message types, such as initialization and requests.

use mcp_rs::errors::Error;
use mcp_rs::server::Server;
use mcp_rs::server::tools::tool_registry::ToolRegistry;
use mcp_rs::transport::TransportType;
use mcp_rs::types::tools::{
    ToolBuilder,
    ToolParameterBuilder,
    ToolParameterType,
    CallToolParams,
    CallToolResult,
};

use std::sync::Arc;
use tracing::Level;

#[tokio::main]
async fn main() -> Result<(), Error> {
    // Use tracing for better logging
    tracing_subscriber::fmt().with_max_level(Level::DEBUG).init();
    println!("---> Starting MCP server");

    // 1. Create server configuration
    let config = mcp_rs::server::server::ServerConfig {
        name: "MCP-RS Example Server".to_string(),
        version: "0.1.0".to_string(),
    };

    // 2. Create application state
    #[derive(Clone)]
    struct AppState {
        _name: String,
    }

    let app_state = AppState {
        _name: "ExampleServer".to_string(),
    };

    // 3. Set up the tool registry
    let tool_registry = Arc::new(ToolRegistry::new());

    // 4. Register a calculator tool
    let calculator_tool = ToolBuilder::new("calculator", "Performs basic arithmetic")
        .add_parameter(
            ToolParameterBuilder::new("a", ToolParameterType::Number).required(true).build()
        )
        .add_parameter(
            ToolParameterBuilder::new("b", ToolParameterType::Number).required(true).build()
        )
        .add_parameter(
            ToolParameterBuilder::new("operation", ToolParameterType::String)
                .enum_values(
                    vec![
                        "add".to_string(),
                        "subtract".to_string(),
                        "multiply".to_string(),
                        "divide".to_string()
                    ]
                )
                .required(true)
                .build()
        )
        .build();

    // Register the calculator tool
    tool_registry
        .register_in_process_tool(calculator_tool, |params: CallToolParams| {
            let a = params.arguments
                .get("a")
                .and_then(|v| v.as_f64())
                .ok_or_else(|| Error::InvalidParams("Missing parameter 'a'".to_string()))?;

            let b = params.arguments
                .get("b")
                .and_then(|v| v.as_f64())
                .ok_or_else(|| Error::InvalidParams("Missing parameter 'b'".to_string()))?;

            let operation = params.arguments
                .get("operation")
                .and_then(|v| v.as_str())
                .ok_or_else(|| Error::InvalidParams("Missing parameter 'operation'".to_string()))?;

            let result = match operation {
                "add" => a + b,
                "subtract" => a - b,
                "multiply" => a * b,
                "divide" => {
                    if b == 0.0 {
                        return Err(Error::InvalidParams("Cannot divide by zero".to_string()));
                    }
                    a / b
                }
                _ => {
                    return Err(Error::InvalidParams(format!("Unknown operation: {}", operation)));
                }
            };

            // Create a properly formatted TextContent object
            Ok(CallToolResult {
                content: vec![
                    serde_json::json!({
                    "type": "text",
                    "text": format!("The result of {} {} {} is {}", a, operation, b, result)
                })
                ],
                is_error: false,
            })
        }).await
        .expect("Failed to register calculator tool");

    // 6. Create and configure the server with method chaining
    let server = Server::with_config(app_state.clone(), config)
        .with_tool_registry(tool_registry)
        .with_default_handlers();

    // 7. Add transport and start server
    let server_handle = server.with_transport(TransportType::sse("127.0.0.1:8090")).start().await?;

    // Wait for shutdown signal
    tokio::signal::ctrl_c().await?;
    println!("---> Received shutdown signal");

    // Clean shutdown
    server_handle.shutdown().await?;
    println!("---> Server stopped");

    Ok(())
}


<file_info>
path: src/transport/websocket.rs
name: websocket.rs
</file_info>
//! WebSocket Transport
//!
//! This module implements the WebSocket transport for the MCP library, enabling
//! full-duplex communication over WebSockets. It is suitable for web-based
//! and networked applications requiring real-time communication.

use async_trait::async_trait;
use futures::future::{ FutureExt };
use futures::{ SinkExt, StreamExt };
use std::sync::Arc;
use std::time::Duration;
use tokio::sync::{ Mutex, mpsc, oneshot };
use tokio_tungstenite::{ connect_async, tungstenite::protocol::Message as WsMessage };
use url::Url;

use crate::errors::Error;
use crate::types::protocol::Message;
use crate::transport::Transport;

/// Default connection timeout
const DEFAULT_CONNECTION_TIMEOUT: Duration = Duration::from_secs(30);
/// Default heartbeat interval
const DEFAULT_HEARTBEAT_INTERVAL: Duration = Duration::from_secs(30);
/// Maximum reconnection attempts
const MAX_RECONNECT_ATTEMPTS: usize = 5;
/// Default reconnection delay
const DEFAULT_RECONNECT_DELAY: Duration = Duration::from_secs(2);

/// WebSocket transport options
#[derive(Debug, Clone)]
pub struct WebSocketOptions {
    /// Connection timeout
    pub connection_timeout: Duration,
    /// Heartbeat interval
    pub heartbeat_interval: Duration,
    /// Reconnection delay
    pub reconnect_delay: Duration,
    /// Authentication token
    pub auth_token: Option<String>,
    /// Custom headers
    pub headers: Option<Vec<(String, String)>>,
}

impl Default for WebSocketOptions {
    fn default() -> Self {
        Self {
            connection_timeout: DEFAULT_CONNECTION_TIMEOUT,
            heartbeat_interval: DEFAULT_HEARTBEAT_INTERVAL,
            reconnect_delay: DEFAULT_RECONNECT_DELAY,
            auth_token: None,
            headers: None,
        }
    }
}

/// WebSocket transport for MCP
pub struct WebSocketTransport {
    /// The WebSocket URL
    url: String,
    /// Receiver for incoming messages
    rx: Arc<Mutex<mpsc::Receiver<Result<Message, Error>>>>,
    /// Sender for outgoing messages
    tx: mpsc::Sender<Message>,
    /// Connection status
    connected: Arc<Mutex<bool>>,
    /// WebSocket options
    options: WebSocketOptions,
    /// New flag to track if the transport is ready for sending
    ready: Arc<Mutex<bool>>,
    /// Connection task
    connection_task: Option<tokio::task::JoinHandle<()>>,
    /// Signal to indicate the transport is shutting down
    shutdown: Arc<Mutex<bool>>,
}

impl WebSocketTransport {
    /// Create a new WebSocket transport with default options
    pub async fn new(url: String) -> Result<Self, Error> {
        Self::with_options(url, WebSocketOptions::default()).await
    }

    /// Create a new WebSocket transport with custom options
    pub async fn with_options(url: String, options: WebSocketOptions) -> Result<Self, Error> {
        // Validate URL
        let _ = Url::parse(&url).map_err(|e|
            Error::Transport(format!("Invalid WebSocket URL: {}", e))
        )?;

        // Create message channels
        let (tx_in, rx_in) = mpsc::channel::<Result<Message, Error>>(100);
        let (tx_out, rx_out) = mpsc::channel::<Message>(100);

        let connected = Arc::new(Mutex::new(false));
        let ready = Arc::new(Mutex::new(false));
        let shutdown = Arc::new(Mutex::new(false));

        // Notify Starting lifecycle event
        tracing::info!("WebSocket transport starting");

        let connected_clone = connected.clone();
        let ready_clone = ready.clone();
        let shutdown_clone = shutdown.clone();
        let url_clone = url.clone();
        let options_clone = options.clone();

        // Start background task for WebSocket communication
        let connection_task = tokio::spawn(async move {
            tracing::info!("Starting WebSocket connection task");
            Self::run_connection_loop(
                url_clone,
                options_clone,
                tx_in,
                rx_out,
                connected_clone,
                ready_clone,
                shutdown_clone
            ).await;
            tracing::info!("WebSocket connection task completed");
        });

        Ok(Self {
            url,
            rx: Arc::new(Mutex::new(rx_in)),
            tx: tx_out,
            connected,
            options,
            ready,
            connection_task: Some(connection_task),
            shutdown,
        })
    }

    /// Run the WebSocket connection loop
    async fn run_connection_loop(
        url: String,
        options: WebSocketOptions,
        tx_in: mpsc::Sender<Result<Message, Error>>,
        rx_out: mpsc::Receiver<Message>,
        connected: Arc<Mutex<bool>>,
        ready: Arc<Mutex<bool>>,
        shutdown: Arc<Mutex<bool>>
    ) {
        // Create a new channel for reconnection signals
        let (reconnect_tx, _reconnect_rx) = mpsc::channel::<()>(1);
        let mut reconnect_attempts = 0;

        // Instead of trying to handle complex reconnection logic with ownership issues,
        // let's simplify and just retry connection in a loop when it fails
        loop {
            if reconnect_attempts >= MAX_RECONNECT_ATTEMPTS {
                let err = Error::Transport(
                    format!("Failed to connect after {} attempts", MAX_RECONNECT_ATTEMPTS)
                );
                let _ = tx_in.send(Err(err)).await;

                // Notify Error lifecycle event
                tracing::error!("WebSocket transport error occurred");
                break;
            }

            let result = Self::handle_connection(
                url.clone(),
                options.clone(),
                tx_in.clone(),
                rx_out,
                connected.clone(),
                ready.clone(),
                shutdown.clone()
            ).await;

            if result {
                // Connection ended normally, reset reconnect attempts
                reconnect_attempts = 0;
            } else {
                // Connection failed, increment reconnect attempts
                reconnect_attempts += 1;

                // Notify Error lifecycle event
                tracing::error!("WebSocket transport error occurred");

                // Wait with exponential backoff before reconnecting
                let backoff =
                    (2_u64).pow(reconnect_attempts.min(10) as u32) *
                    (options.reconnect_delay.as_millis() as u64);
                tracing::info!(
                    "Reconnecting in {} ms (attempt {}/{})",
                    backoff,
                    reconnect_attempts,
                    MAX_RECONNECT_ATTEMPTS
                );
                tokio::time::sleep(Duration::from_millis(backoff)).await;
            }

            // We can't reconnect because rx_out was moved into handle_connection
            // In a real implementation, we would need to create a new channel
            // and integrate it with the client's message loop
            break;
        }

        // Mark as disconnected
        *connected.lock().await = false;
        *ready.lock().await = false;

        // Notify Closed lifecycle event
        tracing::info!("WebSocket transport closed");
    }

    /// Handle a single WebSocket connection
    /// Returns true if connection ended normally, false if it failed
    async fn handle_connection(
        url: String,
        options: WebSocketOptions,
        tx_in: mpsc::Sender<Result<Message, Error>>,
        mut rx_out: mpsc::Receiver<Message>,
        connected: Arc<Mutex<bool>>,
        ready: Arc<Mutex<bool>>,
        shutdown: Arc<Mutex<bool>>
    ) -> bool {
        tracing::info!("Connecting to WebSocket at {}", url);

        // Check if we're shutting down
        if *shutdown.lock().await {
            tracing::info!("Shutdown signal received, aborting connection");
            return false;
        }

        // First, explicitly set connected and ready to false at the start
        {
            let mut connected_guard = connected.lock().await;
            *connected_guard = false;
            tracing::debug!("Set connected flag to false during connection setup");
        }

        {
            let mut ready_guard = ready.lock().await;
            *ready_guard = false;
            tracing::debug!("Set ready flag to false during connection setup");
        }

        let mut url_with_auth = url.clone();
        if let Some(token) = &options.auth_token {
            url_with_auth.push_str(&format!("?token={}", token));
        }

        match connect_async(&url_with_auth).await {
            Ok((ws_stream, _)) => {
                tracing::info!("WebSocket connection established");

                // Set connected flag to true
                {
                    let mut connected_guard = connected.lock().await;
                    *connected_guard = true;
                    tracing::debug!("Set connected flag to true after successful connection");
                }

                // Notify Started lifecycle event
                tracing::info!("WebSocket transport started");

                let (mut ws_sender, mut ws_receiver) = ws_stream.split();
                let tx_in_clone = tx_in.clone();
                let ready_clone = ready.clone();

                // Create a channel for the sender task to signal it's ready
                let (sender_ready_tx, sender_ready_rx) = oneshot::channel();

                let sender_handle = tokio::spawn(async move {
                    tracing::info!("Starting WebSocket sender task");

                    // Signal that the sender is ready
                    if sender_ready_tx.send(()).is_err() {
                        tracing::error!("Failed to signal sender ready");
                        return;
                    }

                    while let Some(msg) = rx_out.recv().await {
                        match serde_json::to_string(&msg) {
                            Ok(json) => {
                                tracing::debug!("Sending message: {}", json);
                                if let Err(e) = ws_sender.send(WsMessage::Text(json.into())).await {
                                    tracing::error!("WebSocket send error: {}", e);
                                    break;
                                }
                            }
                            Err(e) => {
                                tracing::error!("JSON serialization error: {}", e);
                                continue;
                            }
                        }
                    }
                    tracing::warn!("WebSocket sender task ended");
                });

                let receiver_handle = tokio::spawn(async move {
                    tracing::info!("Starting WebSocket receiver task");
                    while let Some(result) = ws_receiver.next().await {
                        match result {
                            Ok(ws_msg) => {
                                if ws_msg.is_text() {
                                    let text = ws_msg.to_text().unwrap();
                                    tracing::debug!("Received raw message: {}", text);
                                    match serde_json::from_str::<Message>(text) {
                                        Ok(message) => {
                                            tracing::debug!("Parsed message: {:?}", message);
                                            if tx_in_clone.send(Ok(message)).await.is_err() {
                                                tracing::error!(
                                                    "Failed to forward message to client"
                                                );
                                                break;
                                            }
                                        }
                                        Err(e) => {
                                            tracing::warn!("Failed to parse message: {}", e);
                                            if tx_in_clone.send(Err(Error::Json(e))).await.is_err() {
                                                break;
                                            }
                                        }
                                    }
                                } else if ws_msg.is_close() {
                                    tracing::info!("WebSocket closed by server");
                                    break;
                                }
                            }
                            Err(e) => {
                                tracing::error!("WebSocket receiver error: {}", e);
                                let _ = tx_in_clone.send(
                                    Err(Error::Transport(e.to_string()))
                                ).await;
                                break;
                            }
                        }
                    }
                    tracing::warn!("WebSocket receiver task ended");
                });

                // Wait for the sender task to signal it's ready
                match
                    tokio::time::timeout(tokio::time::Duration::from_secs(5), sender_ready_rx).await
                {
                    Ok(Ok(())) => {
                        tracing::info!("WebSocket sender task is ready");

                        // Set ready flag to true
                        let mut ready_guard = ready_clone.lock().await;
                        *ready_guard = true;
                        tracing::debug!("Set ready flag to true after sender signaled ready");
                        drop(ready_guard); // Explicitly drop the guard to release the lock
                    }
                    Ok(Err(_)) => {
                        tracing::error!("Sender task failed to signal ready");
                        return false;
                    }
                    Err(_) => {
                        tracing::error!("Timed out waiting for sender task to be ready");
                        return false;
                    }
                }

                tokio::select! {
                    _ = sender_handle => {
                        tracing::info!("Sender task completed");
                        let mut ready_guard = ready.lock().await;
                        *ready_guard = false;
                        tracing::debug!("Set ready flag to false after sender task completed");
                        false
                    }
                    _ = receiver_handle => {
                        tracing::info!("Receiver task completed");
                        let mut ready_guard = ready.lock().await;
                        *ready_guard = false;
                        tracing::debug!("Set ready flag to false after receiver task completed");
                        false
                    }
                }
            }
            Err(e) => {
                tracing::error!("WebSocket connection error: {}", e);
                let err = Error::Transport(format!("WebSocket connection error: {}", e));
                let _ = tx_in.send(Err(err)).await;

                // Ensure flags are set to false on error
                {
                    let mut connected_guard = connected.lock().await;
                    *connected_guard = false;
                    tracing::debug!("Set connected flag to false after connection error");
                }

                {
                    let mut ready_guard = ready.lock().await;
                    *ready_guard = false;
                    tracing::debug!("Set ready flag to false after connection error");
                }

                false
            }
        }
    }
}

impl Drop for WebSocketTransport {
    fn drop(&mut self) {
        if let Some(handle) = self.connection_task.take() {
            handle.abort();
        }
    }
}

#[async_trait]
impl Transport for WebSocketTransport {
    /// Start the transport - for websocket client, this is a no-op as connection
    /// is established in the constructor
    async fn start(&mut self) -> Result<(), Error> {
        // Check if we're already connected
        let connected = *self.connected.lock().await;
        if connected {
            return Ok(());
        }

        // Otherwise, just log that we're ready
        tracing::info!("WebSocket transport ready");
        Ok(())
    }

    async fn receive(&mut self) -> Result<(Option<String>, Message), Error> {
        let mut rx = self.rx.lock().await;
        rx.recv().await
            .ok_or_else(|| Error::Transport("WebSocket receive channel closed".to_string()))?
            .map(|msg| (None, msg)) // Client transport, so no client ID
    }

    async fn send(&mut self, message: &Message) -> Result<(), Error> {
        tracing::debug!("WebSocketTransport.send called");

        // First check connection without locking 'ready'
        {
            let connected = *self.connected.lock().await;
            if !connected {
                tracing::error!("WebSocket is not connected");
                return Err(Error::Transport("WebSocket is not connected".to_string()));
            }
            tracing::debug!("WebSocket is connected");
        }

        // Check the ready flag first before waiting, using a short-lived lock
        let start = std::time::Instant::now();
        let timeout = std::time::Duration::from_secs(10); // 10 second timeout

        let mut is_ready = false;
        tracing::debug!("Checking if WebSocket is ready...");

        // Loop but release the lock each time to avoid deadlock
        while !is_ready {
            // Short-lived lock to check ready state
            {
                let ready_guard = self.ready.lock().await;
                is_ready = *ready_guard;
                if is_ready {
                    tracing::debug!("WebSocket is ready for sending");
                    break;
                }
            }

            // Check timeout without holding any locks
            if start.elapsed() > timeout {
                tracing::error!("Timeout waiting for WebSocket to be ready");
                return Err(
                    Error::Transport(
                        "Timeout waiting for WebSocket to be ready for sending".to_string()
                    )
                );
            }

            // Log and sleep without holding any locks
            tracing::debug!("WebSocket not ready yet, waiting...");
            tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
        }

        tracing::debug!("Sending message via WebSocket channel: {:?}", message);
        match self.tx.send(message.clone()).await {
            Ok(_) => {
                tracing::debug!("Message sent to channel successfully");
                Ok(())
            }
            Err(e) => {
                tracing::error!("Failed to send message to WebSocket channel: {}", e);
                Err(Error::Transport("Failed to send message to WebSocket channel".to_string()))
            }
        }
    }

    async fn send_to(&mut self, _client_id: &str, message: &Message) -> Result<(), Error> {
        // For client transports, send_to is the same as send since there's only one connection
        self.send(message).await
    }

    async fn is_connected(&self) -> bool {
        *self.connected.lock().await
    }

    async fn close(&mut self) -> Result<(), Error> {
        tracing::info!("Closing WebSocket transport");

        // Notify Closing lifecycle event
        tracing::info!("WebSocket transport closing");

        // Set shutdown flag first
        let mut shutdown_guard = self.shutdown.lock().await;
        *shutdown_guard = true;
        drop(shutdown_guard);

        // Abort the connection task
        if let Some(handle) = self.connection_task.take() {
            tracing::debug!("Aborting WebSocket connection task");
            handle.abort();
            tracing::debug!("WebSocket connection task aborted");
        }

        // Set connected and ready to false
        *self.connected.lock().await = false;
        *self.ready.lock().await = false;

        // Notify Closed lifecycle event
        tracing::info!("WebSocket transport closed");

        Ok(())
    }
}


<file_info>
path: src/transport/mod.rs
name: mod.rs
</file_info>
//! Transport module for MCP communication
//!
//! This module defines the Transport trait and various implementations,
//! such as SSE and STDIO transports.

use async_trait::async_trait;
use std::sync::Arc;
use std::time::Duration;
use tokio::task::JoinHandle;
use tokio::sync::Mutex;

use crate::errors::Error;
use crate::types::protocol::Message;

/// Handler for messages from the transport
#[async_trait]
pub trait TransportMessageHandler: Send + Sync {
    /// Handle a message and return an optional response
    ///
    /// # Arguments
    /// * `client_id` - The ID of the client sending the message
    /// * `message` - The message to handle
    ///
    /// # Returns
    /// * `Ok(Some(response))` - A response message to send back to the client
    /// * `Ok(None)` - No response needed
    /// * `Err(error)` - An error occurred while processing the message
    async fn handle_message(
        &self,
        client_id: &str,
        message: &Message
    ) -> Result<Option<Message>, Error>;
}

pub mod sse_server;
pub mod stdio;
pub mod message_handler;
pub mod connection_manager;

pub use message_handler::ServerMessageHandler;

/// Factory for creating transports
#[derive(Clone)]
pub enum TransportType {
    /// Server-Sent Events (SSE) transport
    Sse(sse_server::SseServerOptions),
    /// Standard input/output transport
    Stdio,
}

impl TransportType {
    /// Create an SSE transport with default options on the specified address
    pub fn sse(address: &str) -> Self {
        let options = sse_server::SseServerOptions {
            bind_address: address.to_string(),
            auth_token: None,
            connection_timeout: Duration::from_secs(120),
            keep_alive_interval: 30,
            allowed_origins: None,
            require_auth: false,
            message_tx: None,
        };

        TransportType::Sse(options)
    }
}

/// Handle for a running server, used for shutdown
pub struct ServerHandle {
    sse_transport: Option<sse_server::SseServerTransport>,
    stdio_transport: Option<stdio::StdioTransport>,
    sse_transport_arc: Option<Arc<Mutex<sse_server::SseServerTransport>>>,
    stdio_transport_arc: Option<Arc<Mutex<stdio::StdioTransport>>>,
    join_handle: Option<JoinHandle<Result<(), Error>>>,
}

impl ServerHandle {
    /// Create a new server handle for SSE transport
    pub fn new_sse(transport: sse_server::SseServerTransport) -> Self {
        Self {
            sse_transport: Some(transport),
            stdio_transport: None,
            sse_transport_arc: None,
            stdio_transport_arc: None,
            join_handle: None,
        }
    }

    /// Create a new server handle for stdio transport
    pub fn new_stdio(transport: stdio::StdioTransport) -> Self {
        Self {
            sse_transport: None,
            stdio_transport: Some(transport),
            sse_transport_arc: None,
            stdio_transport_arc: None,
            join_handle: None,
        }
    }

    /// Create a new server handle for Arc-wrapped SSE transport
    pub fn new_sse_arc(transport: Arc<Mutex<sse_server::SseServerTransport>>) -> Self {
        Self {
            sse_transport: None,
            stdio_transport: None,
            sse_transport_arc: Some(transport),
            stdio_transport_arc: None,
            join_handle: None,
        }
    }

    /// Create a new server handle for Arc-wrapped stdio transport
    pub fn new_stdio_arc(transport: Arc<Mutex<stdio::StdioTransport>>) -> Self {
        Self {
            sse_transport: None,
            stdio_transport: None,
            sse_transport_arc: None,
            stdio_transport_arc: Some(transport),
            join_handle: None,
        }
    }

    /// Create a new server handle for SSE transport with a join handle
    pub fn new_sse_with_handle(
        transport: sse_server::SseServerTransport,
        handle: JoinHandle<Result<(), Error>>
    ) -> Self {
        Self {
            sse_transport: Some(transport),
            stdio_transport: None,
            sse_transport_arc: None,
            stdio_transport_arc: None,
            join_handle: Some(handle),
        }
    }

    /// Shutdown the server
    pub async fn shutdown(self) -> Result<(), Error> {
        // First, close any direct transport instances
        if let Some(mut transport) = self.sse_transport {
            let _ = transport.close().await;
        }

        if let Some(mut transport) = self.stdio_transport {
            let _ = transport.close().await;
        }

        // Next, close any Arc-wrapped transports
        if let Some(transport_arc) = self.sse_transport_arc {
            let mut transport = transport_arc.lock().await;
            let _ = transport.close().await;
        }

        if let Some(transport_arc) = self.stdio_transport_arc {
            let mut transport = transport_arc.lock().await;
            let _ = transport.close().await;
        }

        // Finally, handle the join handle if present
        if let Some(handle) = self.join_handle {
            // Try graceful shutdown first
            if let Err(e) = tokio::time::timeout(std::time::Duration::from_secs(5), handle).await {
                tracing::warn!("Server task did not complete within timeout: {}", e);
                // Handle was moved into the timeout, we don't need to abort
            }
        }

        Ok(())
    }
}

/// Transport trait for different communication channels
#[async_trait]
pub trait Transport: Send + Sync {
    /// Receive a message from the transport
    async fn receive(&mut self) -> Result<(Option<String>, Message), Error>;

    /// Send a message to the transport
    async fn send(&mut self, message: &Message) -> Result<(), Error>;

    /// Send a message to a specific client
    async fn send_to(&mut self, client_id: &str, message: &Message) -> Result<(), Error>;

    /// Check if the transport is connected
    async fn is_connected(&self) -> bool;

    /// Close the transport
    async fn close(&mut self) -> Result<(), Error>;

    /// Start the transport
    async fn start(&mut self) -> Result<(), Error>;
}


<file_info>
path: src/server/server.rs
name: server.rs
</file_info>
//! Server implementation for managing message handling

use std::collections::HashMap;
use std::sync::Arc;

use tokio::sync::RwLock;
use tracing::{ debug, error };

use crate::errors::Error;
use crate::types::protocol::Message;
use crate::server::handlers::{ NotificationHandler, RequestHandler };
use crate::server::{ MessageHandler, MessageType, RequestType, NotificationType, ResponseType };
use crate::transport::{ TransportType, ServerHandle };

use super::handlers::InitializeHandler;

/// Server configuration
pub struct ServerConfig {
    /// Name of the server
    pub name: String,
    /// Version of the server
    pub version: String,
}

impl Default for ServerConfig {
    fn default() -> Self {
        Self {
            name: "MCP Server".to_string(),
            version: env!("CARGO_PKG_VERSION").to_string(),
        }
    }
}

/// Server state - this can be generic and depend on the application
#[derive(Clone)]
pub struct ServerState<S> {
    /// Application-specific state
    pub app_state: S,
}

impl<S> ServerState<S> {
    /// Create a new server state
    pub fn new(app_state: S) -> Self {
        Self { app_state }
    }
}

/// Server implementation
pub struct Server<S> {
    /// Server configuration
    config: ServerConfig,

    /// Server state
    state: Arc<RwLock<ServerState<S>>>,

    /// Message handlers, keyed by message type
    handlers: HashMap<MessageType, Arc<dyn MessageHandler + 'static>>,
}

impl<S: Clone + Send + Sync + 'static> Server<S> {
    /// Create a new server instance
    pub fn new(state: S) -> Self {
        let server = Self {
            config: ServerConfig::default(),
            state: Arc::new(RwLock::new(ServerState::new(state))),
            handlers: HashMap::new(),
        };
        server
    }
    /// Add default handlers to the server
    pub fn with_default_handlers(mut self) -> Self {
        self.register_handler(
            MessageType::Notification(NotificationType::Other("*".to_string())),
            NotificationHandler::new()
        );
        self.register_handler(
            MessageType::Request(RequestType::Other("*".to_string())),
            RequestHandler::new()
        );
        // Create and register handlers
        let initialize_handler = InitializeHandler::new()
            .with_server_info(self.config.name.clone(), Some(self.config.version.clone()))
            .with_protocol_version("2024-11-05".to_string())
            .with_resource_capabilities(true, true)
            .with_tool_capabilities(true) // Enable tool capabilities!
            .with_prompt_capabilities(true)
            .with_logging_capabilities();

        // Register initialize handler
        self.register_handler(MessageType::Request(RequestType::Initialize), initialize_handler);

        self
    }

    /// Create a new server with custom configuration
    pub fn with_config(state: S, config: ServerConfig) -> Self {
        Self {
            config,
            state: Arc::new(RwLock::new(ServerState::new(state))),
            handlers: HashMap::new(),
        }
    }

    /// Register a message handler for a specific message type
    pub fn register_handler<H>(&mut self, message_type: MessageType, handler: H)
        where H: MessageHandler + 'static
    {
        debug!("Registering handler for message type: {:?}", message_type);
        self.handlers.insert(message_type, Arc::new(handler));
    }

    /// Register a handler for a specific request type
    pub fn register_request_handler<H>(&mut self, request_type: RequestType, handler: H)
        where H: MessageHandler + 'static
    {
        self.register_handler(MessageType::Request(request_type), handler);
    }

    /// Register a handler for a specific notification type
    pub fn register_notification_handler<H>(
        &mut self,
        notification_type: NotificationType,
        handler: H
    )
        where H: MessageHandler + 'static
    {
        self.register_handler(MessageType::Notification(notification_type), handler);
    }

    /// Register a handler for a specific response type
    pub fn register_response_handler<H>(&mut self, response_type: ResponseType, handler: H)
        where H: MessageHandler + 'static
    {
        self.register_handler(MessageType::Response(response_type), handler);
    }

    /// Register a domain handler for multiple request types
    pub fn register_domain_handler<H>(&mut self, request_types: Vec<RequestType>, handler: H)
        where H: MessageHandler + 'static + Clone
    {
        for request_type in request_types {
            self.register_request_handler(request_type, handler.clone());
        }
    }

    /// Process an incoming message by delegating to the appropriate handler
    pub async fn process_message(
        &self,
        client_id: &str,
        message: &Message
    ) -> Result<Option<Message>, Error> {
        let message_type = message.message_type();

        debug!("Processing message of type {:?} from client {}", message_type, client_id);

        if let MessageType::Response(_) = message_type {
            debug!("Skipping processing for Response message type");
            return Ok(None);
        }

        // First try to find a specific handler for this message type
        if let Some(handler) = self.handlers.get(&message_type) {
            return handler.handle(client_id, message).await;
        }

        // If no specific handler found, try to find a wildcard handler
        match &message_type {
            MessageType::Request(_) => {
                if
                    let Some(handler) = self.handlers.get(
                        &MessageType::Request(RequestType::Other("*".to_string()))
                    )
                {
                    return handler.handle(client_id, message).await;
                }
            }
            MessageType::Notification(_) => {
                if
                    let Some(handler) = self.handlers.get(
                        &MessageType::Notification(NotificationType::Other("*".to_string()))
                    )
                {
                    return handler.handle(client_id, message).await;
                }
            }
            MessageType::Response(_) => {
                if
                    let Some(handler) = self.handlers.get(
                        &MessageType::Response(ResponseType::Other("*".to_string()))
                    )
                {
                    return handler.handle(client_id, message).await;
                }
            }
        }

        // No handler found
        error!("No handler registered for message type: {:?}", message_type);
        Err(Error::MethodNotFound(format!("No handler for message type: {:?}", message_type)))
    }

    /// Get a reference to the server state
    pub async fn get_state(&self) -> ServerState<S> {
        self.state.read().await.clone()
    }

    /// Update the server state
    pub async fn update_state<F, E>(&self, update_fn: F) -> Result<(), E>
        where F: FnOnce(&mut ServerState<S>) -> Result<(), E>
    {
        let mut state = self.state.write().await;
        update_fn(&mut state)
    }

    /// Add a transport to the server
    pub fn with_transport(self, transport_type: TransportType) -> ServerWithTransport<S> {
        ServerWithTransport {
            server: self,
            transport_type,
        }
    }

    /// Add a tool registry to the server
    pub fn with_tool_registry(
        mut self,
        tool_registry: Arc<crate::server::tools::tool_registry::ToolRegistry>
    ) -> Self {
        // Create a tool handler for the registry
        let tool_handler = crate::server::handlers::ToolHandler::new(tool_registry);

        // Register handlers for tool-related requests
        self.register_handler(MessageType::Request(RequestType::ListTools), tool_handler.clone());
        self.register_handler(MessageType::Request(RequestType::CallTool), tool_handler);

        self
    }
}

/// Clone implementation for the server
impl<S: Clone + Send + Sync + 'static> Clone for Server<S> {
    fn clone(&self) -> Self {
        Self {
            config: ServerConfig {
                name: self.config.name.clone(),
                version: self.config.version.clone(),
            },
            state: self.state.clone(),
            handlers: self.handlers.clone(),
        }
    }
}

/// A server with an associated transport, ready to start
pub struct ServerWithTransport<S> {
    server: Server<S>,
    transport_type: TransportType,
}

impl<S: Clone + Send + Sync + 'static> ServerWithTransport<S> {
    /// Start the server with the configured transport
    pub async fn start(self) -> Result<ServerHandle, Error> {
        // Create Arc for server to share with the handler
        let server_arc = Arc::new(self.server);

        // Create the handler
        let handler = crate::transport::message_handler::ServerMessageHandler::new(server_arc);

        // Start the appropriate transport type and attach handler
        match self.transport_type {
            TransportType::Sse(options) => {
                // Create and start SSE transport
                let mut transport = crate::transport::sse_server::SseServerTransport::new(options);

                // First register the handler
                transport.register_message_handler(handler);

                // Then start the transport (which will use the handler in app state)
                transport.start().await?;

                // Return the server handle
                Ok(ServerHandle::new_sse(transport))
            }
            TransportType::Stdio => {
                // Currently not supported in this implementation
                let transport = crate::transport::stdio::StdioTransport::new();

                // Just return a handle without registering the handler for now
                Ok(ServerHandle::new_stdio(transport))
            }
        }
    }
}


